<!-- # SoC计算机系统 -->
# SoC Computer System

<!-- > #### info::总线讲义更新 -->
> #### info::Bus Lecture Notes Updated
<!-- > 我们在2023年11月29日在总线部分的讲义中追加了UART和CLINT的练习, 完成它们有利于接下来SoC的接入. -->
> We added exercises on UART and CLINT to the bus section of our lecture notes on November 29, 2023. Completing these exercises will be beneficial for the upcoming SoC integration.

<!-- 实现总线之后, 我们就可以将NPC接入到"一生一芯"的SoC环境中, 为流片做好准备!
SoC是System On Chip的缩写, 这意味着SoC不仅仅只包含一个处理器,
还有诸多的外围设备, 以及连接处理器和外围设备之间的总线.
在这里, 我们把存储器也看成一种广义的设备, 毕竟对于SoC来说,
存储器和其他狭义的设备没有区别, 都是一段可以访问的地址空间. -->
After implementing the bus, we can connect the NPC to the OSOC SoC environment, preparing for tape-out! SoC stands for System On Chip, which means that the SoC contains not just a processor, but also numerous peripheral devices, as well as the bus that connects the processor to these peripherals. Here, we consider memory as a type of peripheral device in a broad sense, since, for an SoC, memory and other narrower-defined devices are indistinguishable, which are all addressable spaces.

<!-- ## ysyxSoC -->
## ysyxSoC

<!-- 我们提供一个可以在verilator上运行的SoC环境, 称为ysyxSoC.
我们提前让大家接入ysyxSoC, 一方面是为了让大家学习其中的细节,
另一方面也是尽早在SoC环境中测试你的NPC,
从而帮助你缩短从完成流片考核到提交代码之间的时间.
当然, 在接入ysyxSoC后你还需要完成一些优化工作, 才能达成B阶段的流片指标. -->
We provide an SoC environment that can run on Verilator, called ysyxSoC. We allow early access to ysyxSoC for two reasons: firstly, to make everyone learn about its details, and secondly, to test your NPC in the SoC environment as soon as possible. This helps shorten the time from completing the tape-out assessment to code submission. Of course, after integrating with ysyxSoC, you will still need to complete some optimization work to achieve the tape-out requirements for Phase B.

<!-- ### ysyxSoC介绍 -->
### ysyxSoC Introduction

<!-- 我们先给出ysyxSoC包含的外围设备和相应的地址空间. -->
First, we present the peripheral devices included in ysyxSoC and their corresponding address spaces.

<!--
TODO: 加个总线和设备的框图
-->

<!-- | 设备           | 地址空间                 |
| ---            | ---                      |
| CLINT          | `0x0200_0000~0x0200_ffff`|
| SRAM           | `0x0f00_0000~0x0fff_ffff`|
| UART16550      | `0x1000_0000~0x1000_0fff`|
| SPI master     | `0x1000_1000~0x1000_1fff`|
| GPIO           | `0x1000_2000~0x1000_200f`|
| PS2            | `0x1001_1000~0x1001_1007`|
| MROM           | `0x2000_0000~0x2000_0fff`|
| VGA            | `0x2100_0000~0x211f_ffff`|
| Flash          | `0x3000_0000~0x3fff_ffff`|
| ChipLink MMIO  | `0x4000_0000~0x7fff_ffff`|
| PSRAM          | `0x8000_0000~0x9fff_ffff`|
| SDRAM          | `0xa000_0000~0xbfff_ffff`|
| ChipLink MEM   | `0xc000_0000~0xffff_ffff`|
| Reverse        | 其他                      | -->
Devices | Address Spaces
--- | ---
CLINT | `0x0200_0000~0x0200_ffff`
SRAM | `0x0f00_0000~0x0fff_ffff`
UART16550 | `0x1000_0000~0x1000_0fff`
SPI master | `0x1000_1000~0x1000_1fff`
GPIO | `0x1000_2000~0x1000_200f`
PS2 | `0x1001_1000~0x1001_1007`
MROM | `0x2000_0000~0x2000_0fff`
VGA | `0x2100_0000~0x211f_ffff`
Flash | `0x3000_0000~0x3fff_ffff`
ChipLink MMIO | `0x4000_0000~0x7fff_ffff`
PSRAM | `0x8000_0000~0x9fff_ffff`
SDRAM | `0xa000_0000~0xbfff_ffff`
ChipLink MEM | `0xc000_0000~0xffff_ffff`
Reverse | Others

<!-- 图中除了AXI以外, 还有[APB][apb manual], [wishbone][wishbone manual]和[SPI][spi manual]这些总线.
不过这些总线都比AXI简单, 甚至比AXI-Lite还简单.
你已经了解AXI-Lite了, 因此学习这些总线协议也并不难, 需要时可查阅相关手册. -->
In addition to AXI, there are buses such as [APB][apb manual] , [wishbone][wishbone manual] and [SPI][spi manual] in the figure. However, these buses are simpler than AXI, even simpler than AXI-Lite. You already know AXI-Lite, so it is not difficult to learn these bus protocols. You can read relevant manuals when necessary.

[apb manual]: https://developer.arm.com/documentation/ihi0024/latest/
[wishbone manual]: https://cdn.opencores.org/downloads/wbspec_b3.pdf
[spi manual]: https://www.mouser.com/pdfdocs/tn15_spi_interface_specification.PDF

<!-- > #### danger::一些设备和地址空间在将来可能会产生变化
> 为了获得更好的展示效果, “一生一芯”项目组正在重新设计SoC,
> 一些设备和地址空间可能会在将来发生变化,
> 最终的设备地址空间分配情况以流片版本为准.
> 不过这并不影响目前的学习, 你可以安全地忽略这一情况. -->
> #### danger::Some devices and address spaces may change in the future
> In order to obtain a better display effect, the OSOC project team is redesigning the SoC. Some devices and address spaces may change in the future. The final device address space allocation is subject to the tape-out version. However, this does not affects your current learning, you can safely ignore this situation.

<!-- -->
<!-- > #### todo::获取ysyxSoC的代码
> 你需要克隆[ysyxSoC](https://github.com/OSCPU/ysyxSoC)项目:
> ```bash
> cd ysyx-workbench
> git clone git@github.com:OSCPU/ysyxSoC.git
> ```
> 接下来你将会使用ysyxSoc提供的设备进行仿真, 来验证NPC可以正确访问SoC中的设备.
> 我们将在下文介绍具体如何接入.
>
> 需要注意的是, ysyxSoC与最终流片使用的SoC仍有一定差异.
> 因此, 通过ysyxSoC的测试并不代表最终也能通过流片SoC仿真环境的测试.
> 但即使这样, 也可以借助ysyxSoC项目提前暴露一部分问题,
> 若将来接入流片SoC时仍有问题, 则可重点关注两者差异带来的影响. -->
> #### todo::Get the source code of ysyxSoC
>
> You need to clone [the ysyxSoC](https://github.com/OSCPU/ysyxSoC) project:
>
> ```bash
> cd ysyx-workbench
> git clone git@github.com:OSCPU/ysyxSoC.git
> ```
>
> Next, you will use the devices provided by ysyxSoC for simulation in order to verify that the NPC can correctly access the devices in the SoC. We will introduce how to access it below.
>
> It should be noted that there are still some differences between ysyxSoC and the SoC used in the final tape-out. Therefore, passing the test of ysyxSoC does not mean that it will eventually pass the test of the tape-out SoC simulation environment. But even so, some problems can be exposed in advance with the help of the ysyxSoC project, if there are still problems when connecting to the tape-out SoC in the future, you can focus on the impact of the differences between the two.

<!-- 对大家来说, ysyxSoC项目有两部分值得大家关注. 第一部分是ysyxSoC的总线部分,
我们主要借助开源社区[rocket-chip][rocket-chip]项目的[diplomacy][diplomacy]框架来实现它,
相关代码在`ysyxSoC/soc/`目录下.
借助diplomacy, 我们可以很容易地将一个具备总线接口的设备接入ysyxSoC.
例如, 我们只需要改动以下两行Chisel代码, 即可实例化一个AXI接口的MROM设备,
同时指定其地址空间为`0x2000_0000~0x2000_0fff`, 并将其连接到AXI Xbar的下游.
如果采用传统的Verilog方式来接入, 仅仅是端口声明就要添加将近100行代码,
这还没计算对AXI Xbar的修改. -->
For everyone, there are two parts of the ysyxSoC project that deserve your attention. The first part is the bus of ysyxSoC, which we mainly use the [diplomacy][diplomacy] framework of the open source community [rocket-chip][rocket-chip] project to implement it, the relevant code is in the `ysyxSoC/soc/` directory. With diplomacy, we can easily connect the device with a bus interface to ysyxSoC. For example, we only need to change the following two lines of Chisel code to instantiate an AXI interface MROM device, specify its address space as `0x2000_0000~0x2000_0fff`, and connect it to the downstream of AXI Xbar. If you use the traditional Verilog method, just port declaration will add nearly 100 lines of code, not counting the modification to AXI Xbar.


[rocket-chip]: https://github.com/chipsalliance/rocket-chip
[diplomacy]: https://github.com/chipsalliance/rocket-chip/blob/master/docs/src/diplomacy/adder_tutorial.md

```diff
diff --git a/soc/SoC.scala b/soc/SoC.scala
index dd84776c..758fb8d1 100644
--- a/soc/SoC.scala
+++ b/soc/SoC.scala
@@ -35,9 +35,10 @@ class ysyxSoCASIC(implicit p: Parameters) extends LazyModule {
     AddressSet.misaligned(0x10001000, 0x1000) ++    // SPI controller
     AddressSet.misaligned(0x30000000, 0x10000000)   // XIP flash
   ))
+  val lmrom = LazyModule(new AXI4MROM(AddressSet.misaligned(0x20000000, 0x1000)))

   List(lspi.node, luart.node).map(_ := apbxbar)
-  List(chiplinkNode, apbxbar := AXI4ToAPB()).map(_ := xbar)
+  List(chiplinkNode, apbxbar := AXI4ToAPB(), lmrom.node).map(_ := xbar)
   xbar := cpu.masterNode

   override lazy val module = new Impl
```

<!-- 第二部分是ysyxSoC的设备部分, 我们收集了一些设备控制器的开源项目,
相关代码在`ysyxSoC/perip/`目录下.
部分设备通过直接实例化rocket-chip项目中的IP来实现,
这部分设备并不在`ysyxSoC/perip/`目录下, 具体可以参考`ysyxSoC/soc/`中的相关代码. -->
The second part is the device of ysyxSoC. We have collected some open source projects of device controllers. The relevant codes are in `ysyxSoC/perip/` directory. Some devices are implemented by directly instantiating the IP in the rocket-chip project. This part of the devices is not in `ysyxSoC/perip/` directory. For details, please refer to the relevant code in `ysyxSoC/soc/` .

<!-- ### 接入ysyxSoC -->
### Access ysyxSoC

<!-- 由于SoC中包含多个设备, 这些设备的属性可能有所不同, 这将会带来一些新问题.
例如, `ysyxSoC/perip/uart16550/rtl/uart_defines.v`中有如下代码: -->
Since the SoC contains multiple devices, the properties of these devices may be different, which will bring some new problems. For example, `ysyxSoC/perip/uart16550/rtl/uart_defines.v` has the following code:

```
// Register addresses
`define UART_REG_RB `UART_ADDR_WIDTH'd0  // receiver buffer
`define UART_REG_IE `UART_ADDR_WIDTH'd1  // Interrupt enable
`define UART_REG_II `UART_ADDR_WIDTH'd2  // Interrupt identification
`define UART_REG_LC `UART_ADDR_WIDTH'd3  // Line Control
```

<!-- 上述代码定义了UART中一些设备寄存器的地址, 由于UART位于`0x1000_0000`,
因此上述4个寄存器的地址分别是`0x1000_0000`, `0x1000_0001`, `0x1000_0002`, `0x1000_0003`.
假设UART通过AXI-Lite总线连接Xbar, 考虑通过AXI-Lite读取receiver buffer中的内容.
显然, `araddr`信号应为`0x1000_0000`, 但如果要读取4字节,
是否会同时读出后面3个设备寄存器的内容呢? -->
The above code defines the addresses of some device registers in the UART. Since the UART is located at `0x1000_0000` , the addresses of the above four registers are `0x1000_0000` , `0x1000_0001` , `0x1000_0002` , `0x1000_0003` . Assuming that the UART is connected to Xbar through the AXI-Lite bus, consider reading contents of the receiver buffer through AXI-Lite. Obviously, `araddr` signal should be `0x1000_0000` , but if you want to read 4 bytes, will the contents of the next three device registers be read at the same time?

<!-- 我们之前没有考虑"读多长"的问题, 是因为对内存进行读操作时, 并不会改变内存中存储数据的状态,
因此无论CPU期望读出多少字节, 总线都可以一次读出4字节或8字节, 让CPU从中选出目标数据.
这甚至有助于一些带有缓存的CPU提高性能:
从内存中读取一次数据一般需要较长时间, 如果能充分利用总线的带宽,
一次多读出一些数据, 就有可能减少将来真正访问内存的次数. -->
We did not consider the issue of "how much to read" before because when reading the memory, it does not change the state of the data stored in the memory. Therefore, no matter how many bytes the CPU expects to read, the bus can read 4 bytes or 8 bytes at a time, allowing the CPU to select the target data. This even helps some CPUs with caches to improve performance: reading data from memory once generally takes a long time. If the bandwidth of the bus can be fully utilized, it is possible to reduce the number of actual memory accesses by fetching more data during once access in the future.

<!-- 不过对于设备的访问, 上述前提不再成立:
访问设备寄存器可能会改变设备的状态!
这意味着, 对于设备来说, 读出1字节和读出4字节, 最终导致的行为可能不同.
如果我们没有按照设备寄存器的约定来访问它们, 可能会导致设备进入不可预测的状态.
因此在通过总线访问设备时, 我们需要仔细地处理这个问题. -->
However, for device access, the above premise is no longer true, accessing device registers may change the state of the devices! This means that for devices, reading 1 byte and reading 4 bytes may ultimately lead to different behaviors. If we do not access device registers according to their conventions, it may lead the devices to an unpredictable state. Therefore, we need to handle this issue carefully when accessing devices through the bus.

<!-- 但是, AXI-Lite总线并不能解决上述问题, 其AR通道中没有足够的信号用于编码读取长度信息,
设备只能认为实际访问的数据位宽与AXI-Lite总线的数据位宽相同.
因此, 若AXI-Lite总线上的单个读请求覆盖多个设备寄存器, 则可能导致设备状态出错.
也正因为这个原因, 并非所有设备都适合通过AXI-Lite总线接入. -->
However, the AXI-Lite bus cannot solve the above problem. There is not enough signals in its AR channel to encode the read length information. The device can only think that the actually accessed data bit width is the same as the data bit width of the AXI-Lite bus. Therefore. , if a single read request on the AXI-Lite bus covers multiple device registers, it may cause an error in the device status. For this reason, not all devices are suitable for access through the AXI-Lite bus.

<!-- 例如, 上述UART就不能通过数据位宽为32位的AXI-Lite总线接入,
因为UART中设备寄存器的间隔只有1字节, 这意味着通过AXI-Lite读出其中的一个设备寄存器,
也会影响相应的设备寄存器的状态, 这并不是我们期望的.
对于另一款设备寄存器地址空间如下的UART, 则可以通过数据位宽为32位的AXI-Lite总线接入,
因为这些寄存器的间隔为4字节, 正好能在不影响相邻寄存器状态的情况下读出其中某个寄存器. -->
For example, the above UART cannot be accessed through the AXI-Lite bus with a data bit width of 32 bits, because the interval between device registers in the UART is only 1 byte, which means that reading one of the device registers through AXI-Lite will also affect the status of the corresponding device register, which is not what we expect. For another UART whose device register address space is as follows, it can be accessed through the AXI-Lite bus with a data bit width of 32 bits, because the interval between these registers is 4 bytes, just enough to read one of the registers without affecting the status of adjacent registers.

```
// Register addresses
`define UART_REG_RB `UART_ADDR_WIDTH'd0  // receiver buffer
`define UART_REG_IE `UART_ADDR_WIDTH'd4  // Interrupt enable
`define UART_REG_II `UART_ADDR_WIDTH'd8  // Interrupt identification
`define UART_REG_LC `UART_ADDR_WIDTH'd12 // Line Control
```

<!-- 为了解决AXI-Lite的上述问题, 完整的AXI总线协议通过`arsize`/`awsize`信号来指示实际访问的数据位宽,
同时引入"窄传输"的概念, 用于指示"实际数据位宽小于总线数据位宽"的情况.
这两个"数据位宽"的概念并非完全一致, 具体地, 总线数据位宽是在硬件设计时静态决定的,
它表示一次总线传输的最大数据位宽, 也用于计算总线的理论带宽;
而实际数据位宽(即`arsize`/`awsize`信号的值)则由软件访存指令中的位宽信息动态决定,
它表示一次总线传输的实际数据位宽, 例如, `lb`指令只访问1字节, 而`lw`指令则访问4字节. -->
In order to solve the above problems of AXI-Lite, the complete AXI bus protocol uses the `arsize` / `awsize` signal to indicate the actual accessed data bit width, and also introduces the concept of "narrow transmission" to indicate that "the actual data bit width is less than the bus data bit width" situation. These two concepts of "data bit width" are not completely consistent. Specifically, the bus data bit width is statically determined during hardware design. It represents the maximum data bit width of a bus transmission and is also used to calculate the theoretical bandwidth of the bus. The actual data bit width (i.e., the value of the `arsize` / `awsize` signal) is dynamically determined by the bit width information in the software memory access instruction, which represents the actual data bit width of a bus transmission. For example, `lb` instruction only accesses 1 byte, while `lw` instruction accesses 4 bytes.


<!-- 有了`arsize`/`awsize`信号, 设备就可以得知软件需要访问的实际数据位宽,
从而在若干设备寄存器的地址紧密排布时, 亦可仅访问其中的某个寄存器, 避免意外改变设备的状态. -->
With `arsize` / `awsize` signal, the device will know the actual data bit width that the software needs to access, so that when the addresses of several device registers are closely arranged, it can only access one of the registers to avoid accidentally changing the state of the device.

> #### todo::接入ysyxSoC
> 依次按照以下步骤将NPC接入ysyxSoC:
> 1. 依照`ysyxSoC/spec/cpu-interface.md`中的`master`总线, 将之前实现的AXI4Lite协议扩展到完整的AXI4
> 1. 调整NPC顶层接口, 使其与`ysyxSoC/spec/cpu-interface.md`中的接口命名规范<font color=red>**完全一致**</font>,
>    包括信号方向, 命名和数据位宽
>    * 对于不使用的顶层输出端口, 需要将其赋值为常数`0`
>    * 对于不使用的顶层输入端口, 悬空即可
>    * 为了兼容前几期的设计, 我们采用64位数据位宽的接口,
>      如果NPC是32位, 目前只需要使用数据的低32位即可, 后面我们会再次讨论这个问题
> 1. 将`ysyxSoC/perip`目录及其子目录下的所有`.v`文件加入verilator的Verilog文件列表
> 1. 将`ysyxSoC/perip/uart16550/rtl`和`ysyxSoC/perip/spi/rtl`两个目录加入verilator的include搜索路径中
>    * 具体如何加入, 请RTFM(`man verilator`或verilator的官方手册)
>      * 如果你从来没有查阅过verilator有哪些选项, 我们建议你趁这次机会认真阅读一下手册中的`argument summary`,
>        你很可能会发现一些新的宝藏
> 1. 在verilator编译选项中添加`--timescale "1ns/1ns"`和`--no-timing`
> 1. 将`ysyxSoCFull`模块(在`ysyxSoC/generated/ysyxSoCFull.v`中定义)设置为verilator仿真的顶层模块
>    * 如果你不知道如何加入, RTFM
> 1. 将`ysyxSoC/generated/ysyxSoCFull.v`中的`ysyx_00000000`模块名修改为你的处理器的模块名
>    * 注意, 这个模块不应该包含之前作为习题的AXI4-Lite接口的SRAM和UART,
>      我们将使用ysyxSoC中的存储器和UART替代它们
>    * 但这个模块应该包含CLINT, 它将作为流片工程中的一个模块, ysyxSoC不包含它
> 1. 在仿真的cpp文件中加入如下内容, 用于解决链接时找不到`flash_read`和`mrom_read`的问题
>    ```cpp
>    extern "C" void flash_read(uint32_t addr, uint32_t *data) { assert(0); }
>    extern "C" void mrom_read(uint32_t addr, uint32_t *data) { assert(0); }
>    ```
> 1. 在仿真环境的`main`函数中仿真开始前的位置加入语句`Verilated::commandArgs(argc, argv);`,
>    用于解决运行时plusargs功能报错的问题
> 1. 通过verilator编译出仿真可执行文件
>    * 如果你遇到了组合回环的错误, 请自行修改你的RTL代码
> 1. 尝试开始仿真, 你将观察到代码进入了仿真的主循环, 但NPC无有效输出.
>    我们将在接下来解决这个问题
>
> `ysyxSoC`中还有一些代码检查相关的步骤说明, 但你后续还要改进NPC,
> 因此我们将要求你在考核前再进行代码检查.
> 如果你感兴趣, 目前开展代码检查的工作亦可, 我们不做强制要求.
> #### todo::Access ysyxSoC
> Follow the steps below to access the NPC to ysyxSoC:
> 1. According to `master` bus in `ysyxSoC/spec/cpu-interface.md` , the previously implemented AXI4Lite protocol is extended to the complete AXI4
> 1. Adjust the NPC top-level interface to <font color="red"><strong>be completely consistent</strong></font> with the interface naming specification in <code>ysyxSoC/spec/cpu-interface.md</code> , including signal direction, naming and data bit width
>     * For unused top-level output ports, they need to be assigned a constant value of `0`
>     * For unused top-level input ports, just leave them floating.
>     * In order to be compatible with previous designs, we adopt a 64-bit data width interface. If your NPC is 32 bits, currently only the lower 32 bits of the data need to be used. We will discuss this issue again later.
> 1. Add all `.v` files in the `ysyxSoC/perip` directory and its subdirectories to verilator's Verilog file list
> 1. Add the two directories `ysyxSoC/perip/uart16550/rtl` and `ysyxSoC/perip/spi/rtl` to the include search path of verilator
>     * For details on how to join, please RTFM ( `man verilator` or verilator’s official manual)
>         * If you have never looked up the options of verilator, we recommend that you take this opportunity to carefully read `argument summary` in the manual. You may well discover some new treasures.
> 1. Add `--timescale "1ns/1ns"` and `--no-timing` to verilator compilation options
> 1. Set the `ysyxSoCFull` module (defined in `ysyxSoC/generated/ysyxSoCFull.v` ) as the top-level module for verilator simulation
>     * If you don't know how to join, RTFM
> 1. Change the `ysyx_00000000` module name in `ysyxSoC/generated/ysyxSoCFull.v` to the module name of your processor
>     * Note that this module should not contain the SRAM and UART of the AXI4-Lite interface as an exercise before, we will replace them with the memory and UART in ysyxSoC
>     * But this module should contain CLINT, which will be used as a module in the tape-out project, which ysyxSoC does not include.
> 1. Add the following content to the simulated cpp file to solve the problem of `flash_read` and `mrom_read` not being found during linking
>     ```cpp
>     extern "C" void flash_read(uint32_t addr, uint32_t *data) { assert(0); }
>     extern "C" void mrom_read(uint32_t addr, uint32_t *data) { assert(0); }
>     ```
> 1. Add the statement `Verilated::commandArgs(argc, argv);` in `main` function of the simulation environment before the simulation starts to solve the problem of runtime errors reported by the plusargs function.
> 1. Compile the simulation executable file through verilator
>     * If you encounter a combined loopback error, please modify your RTL code yourself
> 1. Try to start the simulation, you will observe that the code enters the main loop of the simulation, but the NPC has no valid output. We will solve this problem next
>
> There are also some step instructions related to code inspection in `ysyxSoC` , but you will also need to improve the NPC in the future, so we will ask you to conduct code inspection before the assessment. If you are interested, you can also carry out code inspection at present, we will not require it.

<!-- 接下来我们会依次介绍ysyxSoC中的设备, 以及如何让程序使用它们.
一些任务会要求你在RTL层面对一些设备模块进行实现或增强,
对于这些任务的大部分, 你都可以选择采用Chisel或者Verilog来完成.
特别地, 如果你选择使用Chisel, 你仍然需要阅读一些Verilog代码来帮助你完成任务. -->
Next, we will introduce the devices and how to let the program use them in ysyxSoC one by one. Some tasks will require you to implement or enhance some device modules on the RTL level. For most of these tasks, you can choose to use Chisel or Verilog to complete. In particular, if you choose to use Chisel, you will still need to read some Verilog code to help you complete the task.

<!-- > #### option::获取rocket-chip的代码
> 如果你偏向于使用Chisel完成后续任务, 或者对ysyxSoC总线部分的细节感兴趣,
> 可以通过如下方式获取命令获取rocket-chip的代码:
> 1. 去除`ysyxSoC/Makefile`开头变量定义的注释
> 1. 在`ysyxSoC/`目录下运行`make dev-init`命令
>
> 为了生成Verilog代码, 你还需要将firtool的所在目录加入`PATH`环境变量中,
> 然后在`ysyxSoC/`目录下运行`make verilog`命令.
> 关于firtool的添加, 具体可参考我们提供的Chisel开发环境. -->
> #### option::Get the code of rocket-chip
> If you prefer to use Chisel to complete subsequent tasks, or are interested in the details of the ysyxSoC bus part, you can obtain the rocket-chip code by obtaining the command as follows:
> 1. Remove the comments of variable definitions at the beginning of `ysyxSoC/Makefile`
> 2. Run the `make dev-init` command in the `ysyxSoC/` directory
>
> In order to generate Verilog code, you also need to add the directory where firtool is located to `PATH` environment variable, and then run `make verilog` command in `ysyxSoC/` directory. For details on adding firtool, please refer to the Chisel development environment we provide.

<!-- ## 最简单的SoC

回想TRM的其中两个要素, 有程序可以执行, 并且可以输出.
在之前的仿真过程中, 这两点都是通过仿真环境来实现的:
仿真环境将程序的镜像文件放到存储器中, NPC取第一条指令的时候, 程序已经位于存储器中了;
为了输出, 我们借助DPI-C函数`pmem_read()`调用仿真环境的功能, 并通过仿真环境的`putchar()`函数来实现输出.
但在真实的SoC中, 板卡上电后并没有仿真环境或运行时环境提供上述功能, 因此需要通过硬件来实现这些基本功能. -->
## The simplest SoC

Recall that two of the elements of TRM are that a program can be executed and can be output. In the previous simulation process, these two points were realized through the simulation environment. The simulation environment puts the image file of the program into the memory, and when NPC fetches the first instruction, the program is already in the memory; for output, we use the DPI-C function `pmem_read()` to call the function of the simulation environment, and realize the output through `putchar()` function of the simulation environment. But in the real SoC , there is no simulation environment or runtime environment to provide the above functions after the board is powered on, so these basic functions need to be implemented through hardware.

<!-- ### 程序的存放

首先需要考虑程序放在哪里.
一般的存储器是易失存储器(volatile memory), 例如SRAM和DRAM, 它们在上电时并没有存放有效数据.
如果上电后CPU直接从内存中读取指令执行, 存储器读出什么数据是未定义的,
因此整个系统的行为也是未定义的, 从而无法让CPU执行预期的程序.

因此, 需要使用一种非易失存储器(non-volatile memory)来存放最初的程序,
使其内容能在断电时保持, 并在上电时能让CPU马上从中取出指令.
一个最简单的解决方案就是ROM(Read-Only Memory), 每次从ROM中相同位置读出的内容都是相同的.

ROM的实现有很多种, 总体上都是通过某种方式来将信息(在这里也是程序)存储在ROM中,
而且这种存储方式不会受到断电的影响, 从而具备非易失的属性.
如果考虑在ysyxSoC中的易用性, 最合适的就是mask ROM(掩膜ROM), 简称MROM,
其本质是将信息"硬编码"在门电路中, 因此对NPC来说访问方式非常直接.

不过因为MROM的某些问题, 我们并不打算在流片的时候使用它.
但MROM作为ysyxSoC中的第一个简单的非易失存储器来存放程序, 对我们测试ysyxSoC的接入还是非常合适的.
我们已经在ysyxSoC中添加了一个AXI4接口的MROM控制器, 其地址空间是`0x2000_0000~0x2000_0fff`. -->
### Program storage

First, you need to consider where the program is placed. General memories are volatile memories, such as SRAM and DRAM, which do not store valid data when powered on. If the CPU directly reads instructions from the memory after powering on,  what data is read out of the memory is undefined, so the behavior of the entire system is also undefined, making it impossible for the CPU to execute the expected program.

Therefore, it is necessary to use a non-volatile memory to store the original program so that its contents can be retained when the power is turned off, and the CPU can immediately retrieve instructions from it when the power is turned on. The simplest solution is ROM (Read-Only Memory). The content read from the same location in ROM is the same every time.

There are many ways to implement ROM. Generally speaking, information (also programs here) is stored in ROM in some way, and this storage method will not be affected by power outages, so it has non-volatile properties.  If you consider the ease of use in ysyxSoC, the most suitable one is mask ROM (mask ROM), referred to as MROM. Its essence is to "hard-code" information in the gate circuit, so the access method is very direct for NPC.

However, due to some problems with MROM, we do not plan to use it during tape-out. However, MROM, as the first simple non-volatile memory in ysyxSoC to store programs, is very suitable for us to test the access of ysyxSoC. We have added an AXI4 interface MROM controller to ysyxSoC, and its address space is `0x2000_0000~0x2000_0fff`.

<!-- > #### todo::测试MROM的访问
> 修改NPC的复位PC值, 使其从MROM中取出第一条指令,
> 并修改`mrom_read()`函数, 使其总是返回一条`ebreak`指令.
> 如果你的实现正确, NPC取到的第一条指令即是`ebreak`指令, 从而结束仿真.
>
> 因为NEMU还没有添加MROM的支持, 而NPC此时需要从MROM中取指, 故此时DiffTest机制不能正确工作.
> 不过目前的测试程序规模还很小, 你可以先关闭DiffTest功能, 后面我们再回过头来处理DiffTest的问题. -->
> #### todo::Test MROM access
>
> Modify the reset PC value of NPC so that it fetches the first instruction from MROM, and modify the `mrom_read()` function so that it always returns an `ebreak` instruction. If your implementation is correct, the first instruction fetched by NPC is `ebreak` to end the simulation.
>
> Because NEMU has not yet added MROM support, and NPC needs to fetch instructions from MROM at this time, the DiffTest cannot work correctly at this time. However, the current test program is still very small, you can turn off the DiffTest function first, and we will come back later to deal with DiffTest problems.

<!-- ### 输出第一个字符

可以存放程序之后, 我们就需要考虑如何输出了.
为此, SoC中还需要提供一个最基本的输出设备.
真实的SoC中通常使用UART16550, 它包含一些设备寄存器, 用于设置字符长度, 波特率等信息.
在发送队列未满时, 即可通过写入对应的设备寄存器来发送字符.

ysyxSoC中已经集成了一个UART16550控制器.
为了测试它, 我们先编写一个最简单的程序`char-test`, 它直接输出一个字符之后就陷入死循环:

```c
#define UART_BASE 0x?L
#define UART_TX   ?
void _start() {
  *(volatile char *)(UART_BASE + UART_TX) = 'A';
  *(volatile char *)(UART_BASE + UART_TX) = '\n';
  while (1);
}
``` -->
### Output the first character

After implementing that the program can be stored, we need to consider how to output. To this end, the SoC also needs to provide a most basic output device. UART16550 is usually used in real SoC, which contains some device registers for setting the character length, baud rate and other information. When sending queue not full, characters can be sent by writing to the corresponding device register.

A UART16550 controller has been integrated into ysyxSoC. In order to test it, we first write the simplest program `char-test` , which directly outputs a character and then falls into an infinite loop:

```c
#define UART_BASE 0x?L
#define UART_TX   ?
void _start() {
  *(volatile char *)(UART_BASE + UART_TX) = 'A';
  *(volatile char *)(UART_BASE + UART_TX) = '\n';
  while (1);
}
```

<!-- > #### danger::bug修复
> 我们修复了在特定情况下APB请求发送错误的问题.
> 如果你在2024/01/10 20:00:00之前获取`ysyxSoC`的代码, 请获取新版代码:
> ```bash
> cd ysyxSoC
> git pull origin ysyx6
> ``` -->
> #### danger::bug fix
>
> We fixed an issue where APB requests were sent incorrectly under certain circumstances. If you obtained the code for `ysyxSoC` before 2024/01/10 20:00:00, please obtain the new version of code:
>
> ```bash
> cd ysyxSoC
> git pull origin ysyx6
> ```

<!-- -->
<!-- > #### todo::在ysyxSoC中输出第一个字符
> 你需要:
> 1. 根据ysyxSoC中的设备地址空间约定, 以及UART手册(在`ysyxSoC/perip/`下的相关子目录中)中输出寄存器的地址,
>    来填写上述C代码中的`?`处, 使代码可以正确访问输出寄存器来输出一个字符
> 1. 通过`gcc`和`objcopy`命令编译`char-test`, 并将ELF文件中的代码节单独抽取到`char-test.bin`中
> 1. 修改仿真环境的相关代码, 读入`char-test.bin`并将其作为MROM的内容,
>    然后正确实现`mrom_read()`函数, 使其根据参数`addr`返回MROM中相应位置的内容
>
> 如果你的实现正确, 仿真过程将会在终端输出一个字符`A`.
>
> Hint: 如果你不知道如何通过`gcc`和`objcopy`命令实现上述功能,
> 你可以参考"一生一芯"某节课的视频或课件. 如果你不知道应该参考哪一节课,
> 我们建议你把所有视频和课件都查看一遍, 相信这能帮助你补上很多你还不了解的知识点. -->
> #### todo::Output the first character in ysyxSoC
> You need to:
> 1. According to the device address space convention in ysyxSoC and the address of the output register in the UART manual (in the relevant subdirectory under `ysyxSoC/perip/` ), fill in `?` in the above C code so that the code can correctly access the output register for output a character
> 1. Compile `char-test` through `gcc` and `objcopy` commands, and extract the code sections in the ELF file separately into `char-test.bin`
> 1. Modify the relevant code of the simulation environment, read `char-test.bin` and use it as the content of the MROM, and then correctly implement `mrom_read()` function so that it returns the content of the corresponding location in the MROM according to the parameter `addr` .
>
> If your implementation is correct, the simulation process will output the character `A` to the terminal.
>
> Hint: If you don’t know how to implement the above functions through `gcc` and `objcopy` commands, you can refer to the video or courseware of a certain class of OSOC. If you don’t know which class to refer to, we recommend that you combine all the videos and Check out the courseware, I believe it will help you catch up on a lot of knowledge you don’t understand yet.

<!-- -->
<!-- > #### hint::RTFM理解总线协议
> 如果你发现仿真过程中发现总线的行为难以理解, 先尝试RTFM尽可能理解手册中的所有细节.
> 随着项目复杂度的增加, 你将要为不仔细RTFM付出越来越大的代价.

如果你通过`objdump`等工具查看生成的ELF文件,
你会发现代码节的地址位于地址`0`附近, 与MROM的地址空间不一致.
实际上, 这个程序很小, 我们很容易确认, 无论将它放在哪个地址, 都能正确地按预期执行.
对于更复杂的程序, 上述条件不一定能满足, 我们需要显式地将程序链接到一个正确的位置,
使得NPC复位后可以正确地执行程序. 我们将在后面解决这个问题.

此外, 在真实的硬件场景下, 串口还需要根据波特率来将字符转换成串行的输出信号,
通过线缆传送到串口的接收端, 因此发送端在发送字符前, 软件还需要在串口的配置寄存器中设置正确的除数.
但当前的ysyxSoC仿真环境中并没有串口的接收端, 因此我们在串口控制器的RTL代码中添加了若干打印语句,
直接将串口发送队列中的字符打印出来, 这样软件也无需设置除数.
也因此, 上述代码在真实的硬件场景中并不一定能正常工作,
但作为前期测试, 这可以方便我们快速检查字符是否被正确写入串口发送队列.
我们将在成功运行足够多程序后, 再添加除数的设置, 使得代码可以在真实的硬件场景中工作. -->
> #### hint::RTFM to understand the bus protocol
>
> If you find that the behavior of the bus is difficult to understand during simulation, try RTFM first to understand all the details in the manual as much as possible. As the complexity of the project increases, you will pay an increasing price for not RTFM carefully.

If you view the generated ELF file through tools such as `objdump` , you will find that the address of the code section is located near address `0` , which is inconsistent with the address space of the MROM. In fact, this program is small and we can easily confirm that no matter what address it is placed, it can be executed correctly as expected. For more complex programs, the above conditions may not be met, and we need to explicitly link the program to a correct location so that the program can be executed correctly after the NPC is reset. We will solve this problem later.

In addition, in a real hardware scenario, the serial port also needs to convert the characters into a serial output signal according to the baud rate, and transmit it to the receiving end of the serial port through wires. Therefore, before the sending end sends characters, the software also needs to set the correct divisor in the configuration register. However, there is no serial port receiving end in the current ysyxSoC simulation environment, so we added several print statements to the RTL code of the serial port controller to directly print the characters in the serial port sending queue. In this way, the software does not need to set the divisor. Therefore, the above code may not work properly in real hardware scenarios, but as a preliminary test, this can facilitate us to quickly check whether the characters are correctly written to the serial port sending queue. After successfully running enough programs, we will add divisor settings so that the code can work in real hardware scenarios.

<!-- > #### todo::去掉换行也能输出
> 上述`char-test`在输出字符`A`之后, 还输出一个换行符.
> 尝试仅仅输出字符`A`而不输出换行符, 你应该会观察到仿真过程连字符`A`都不输出了.
> 但如果每次输出一个字符之后都紧接着输出一个换行符, 打印出的信息将很难阅读.
>
> 为了解决这个问题, 你只需要给verilator传递一个选项.
> 尝试根据你对这个问题的理解, 通过RTFM找到并添加这个选项.
> 如果你添加了正确的选项, 你将会看到即使上述程序仅输出单个字符`A`, 也能成功输出.
>
> Hint: PA讲义已经在好几处讨论过相关问题了.
> 如果你对此没有任何印象, 我们建议你重新仔细阅读讲义的每一处细节来查缺补漏. -->
> > #### todo::output even if line breaks are removed
>
> The above `char-test` also outputs a newline character after outputting the character `A` Try to output only the character `A` without outputting the newline character. You should observe that even the character `A` is not output during the simulation process. But if you output a newline each time after a character, the printed information will be difficult to read.
>
> To solve this problem, you just need to pass an option to verilator. Try to find and add this option through RTFM based on your understanding of the problem. If you add the correct option, you will see that even the above program only outputs a single character `A`, it can also be output successfully.
>
> Hint: The PA lecture notes have discussed related issues in several parts. If you have no impression of this, we recommend that you re-read every detail of the lecture notes to check for any gaps.

<!-- ## 更实用的SoC

确认ysyxSoC可以输出一个字符之后, 我们认为NPC访问设备的数据通路基本上打通.
不过, MROM虽然可以很好地实现程序的存放, 但它有一个很大的问题: 不支持写入操作.
但大多数程序都需要向存储器写入数据, 例如, C语言的调用约定允许被调用函数在栈上创建栈桢, 并通过栈桢存取数据.
因此, 一个仅包含MROM作为存储器的SoC可能无法支持那些需要调用函数的程序, 显然这并不实用.
为了支持写入操作, 我们需要添加RAM作为存储器, 并将程序的数据分配在RAM中.

最简单的RAM就是我们之前提到的SRAM, 我们可以在SoC中集成SRAM存储器.
SRAM能够使用与处理器制造相同的工艺进行生产, 同时读写延迟只有1周期, 因此速度很快.
但SRAM的存储密度较低, 需要占用一定的芯片面积, 因此从流片价格的角度来计算, 成本是十分昂贵的.
考虑到流片成本, 我们只在SoC中提供8KB的SRAM.
我们已经在ysyxSoC中添加了一个AXI4接口的SRAM控制器, 其地址空间是`0x0f00_0000~0x0f00_1fff`.
注意到在前文的介绍中, SRAM的地址空间是`0x0f00_0000~0x0fff_ffff`, 共16MB,
这只是说明ysyxSoC中给SRAM预留了16MB的地址空间, 但考虑到实际的成本, 只使用了其中的8KB,
剩余的地址空间是空闲的, NPC不应该访问这部分空闲的地址空间.

有了这部分SRAM的空间, 我们就可以考虑将栈分配在SRAM空间, 从而支持一些AM程序的执行了. -->
## A more practical SoC

After confirming that ysyxSoC can output a character, we believe that the data path for NPC to access the device is basically set up. However, although MROM can store programs very well, it has a big problem: it does not support write operations. But most programs need to write data to memory. For example, the calling convention of the C language allows the called function to create a stack frame on the stack and access data through the stack frame. Therefore, an SoC that only contains MROM as memory may not be able to support those Programs that need to call functions are obviously not practical. In order to support write operations, we need to add RAM as memory and allocate the program's data in RAM.

The simplest RAM is the SRAM we mentioned before. We can integrate SRAM memory in SoC. SRAM can be produced using the same process as processor manufacturing, and the read and write latency is only 1 cycle, so it is very fast. But the storage density of SRAM is low and requires a certain chip area, so the cost is very expensive from the perspective of tape-out price. Considering the tape-out cost, we only provide 8KB SRAM in SoC. We have added a SRAM controller with AXI4 interface  to ysyxSoC, whose address space is `0x0f00_0000~0x0f00_1fff` . Note that in the previous introduction, the SRAM address space is `0x0f00_0000~0x0fff_ffff` , a total of 16MB. This only means that ysyxSoC reserves 16MB of address space for SRAM, but considering the actual cost, only 8KB of it is used. The remaining address space is not used, and NPC should not access this part of the invalid address space.

With this part of SRAM space, we can consider allocating the stack in SRAM space to support the execution of some AM programs.

<!-- ### 为ysyxSoC添加AM运行时环境 -->
### Add AM runtime environment for ysyxSoC

<!-- 为了运行更多程序, 我们需要基于ysyxSoC提供向程序提供相应的运行时环境.
噢, 这不就是实现一个新的AM吗? 这对你来说已经很熟悉了.
不过我们还是需要考虑ysyxSoC的一些属性对于运行时环境带来的影响. -->
In order to run more programs, we need to provide corresponding runtime environments for programs based on ysyxSoC. Oh, isn't this just about implementing a new AM? This is already familiar to you. However, we still need to consider the impact of some attributes of ysyxSoC on the runtime environment.

<!-- 首先我们来看TRM. 回顾TRM的内容, 我们需要考虑如何在ysyxSoC上实现TRM的API: -->
First let's look at TRM. Reviewing the content of TRM, we need to consider how to implement TRM's API on ysyxSoC:

<!-- * 可以用来自由计算的内存区间 - 堆区
  * 堆区需要分配在可写的内存区间, 因此可以分配在SRAM中
* 程序 "入口" - `main(const char *args)`
  * `main()`函数由AM上的程序提供, 但我们需要考虑整个运行时环境的入口,
    即需要将程序链接到MROM的地址空间, 并保证TRM的第一条指令与NPC复位后的PC值一致
* "退出"程序的方式 - `halt()`
  * ysyxSoC不支持"关机"等功能, 为方便起见, 可借助`ebreak`指令让仿真环境结束仿真
* 打印字符 - `putch()`
  * 可通过ysyxSoC中的UART16550进行输出 -->
* Memory area that can be used for calculations freely - heap area
    * The heap area needs to be allocated in a writable memory area, so it can be allocated in SRAM
* Program "entry" - `main(const char *args)`
    * `main()` function is provided by the program on AM, but we need to consider the entry of the entire runtime environment, that is, we need to link the program to the address space of MROM, and ensure that the first instruction of TRM is consistent with the PC value after NPC reset
* Way to "exit" a program - `halt()`
    * ysyxSoC does not support functions such as "shutdown". For convenience, you can use `ebreak` command to let the simulation environment end the simulation.
* Print characters - `putch()`
    * Output available via UART16550 in ysyxSoC

<!-- 由于NPC复位后从MROM开始执行, 而MROM不支持写入操作, 因此我们需要额外注意:
1. 程序中不能包含对全局变量的写入操作
2. 栈区需要分配在可写的SRAM中 -->
Since NPC starts execution from MROM after reset, and MROM does not support write operations, we need to pay extra attention:
1. The program cannot contain writing operations to global variables
1. The stack area needs to be allocated in writable SRAM

<!-- > #### todo::为ysyxSoC添加AM运行时环境
> 添加一个`riscv32e-ysyxsoc`的新AM, 并按照上述方式提供TRM的API.
> 添加后, 将`cpu-tests`中的`dummy`测试编译到`riscv32e-ysyxsoc`,
> 并尝试在ysyxSoC的仿真环境中运行它.
>
> Hint: 为了完成这个任务, 你需要一些链接的知识.
> 如果你不熟悉, 可以参考"一生一芯"相关的视频和课件. -->
> #### todo::Add AM runtime environment for ysyxSoC
> Add a new AM of `riscv32e-ysyxsoc` and provide TRM's API as mentioned above. After adding, compile the `dummy` test in `cpu-tests` to `riscv32e-ysyxsoc` and try to run it in the simulation environment of ysyxSoC.
> 
> Hint: In order to complete this task, you need some knowledge of links. If you are not familiar with it, you can refer to the videos and courseware related to OSOC.

<!-- -->
<!-- > #### option::无法运行的测试
> 尝试在ysyxSoC中运行`cpu-tests`中的`fib`, 你发现运行失败.
> 尝试阅读提示信息, 你觉得应该如何解决这个问题? -->
> #### option::Tests that unable to run
> Try to run `fib` in `cpu-tests` on ysyxSoC, and you find that the operation fails. Try reading the prompt message, how do you think you should solve this problem?

<!-- -->
<!-- > #### todo::重新添加DiffTest
> 我们新增了MROM和SRAM, 接下来一段时间我们都会在MROM和SRAM上运行程序.
> 但目前NEMU并没有MROM和SRAM, 如果我们在DiffTest的时候跳过MROM和SRAM和访问,
> 将会跳过所有指令的执行, 使得DiffTest将无法起到预期的作用.
>
> 为了重新添加DiffTest, 你需要在NEMU中添加MROM和SRAM,
> 并在NPC的仿真环境初始化DiffTest时, 将MROM中的内容同步到NEMU中,
> 然后检查在MROM中执行的每一条指令.
>
> 你可以按照你的想法修改NEMU的代码, 但我们还是建议你尽量不添加新的DiffTest API,
> 框架代码提供的DiffTest API已经足够实现上述功能了. -->
> #### todo::Re-add DiffTest
> We have added MROM and SRAM, and we will run programs on MROM and SRAM in the next period of time. But currently NEMU does not have MROM and SRAM. If we skip MROM and SRAM and access during DiffTest, we will skip all the execution of the instruction, which makes DiffTest unable to function as expected.
>
> In order to re-add DiffTest, you need to add MROM and SRAM to NEMU, and when initializing DiffTest in the NPC simulation environment, synchronize the contents of MROM to NEMU, and then check every instruction executed in MROM.
>
> You can modify the NEMU code according to your ideas, but we still recommend that you try not to add a new DiffTest API. The DiffTest API provided by the framework code is enough to implement the above functions.

<!-- -->
<!-- > #### option::让NPC抛出Access Fault异常
> 尽管这不是强制性的, 我们建议你在NPC中添加Access Fault的实现.
> 在系统运行发生意外导致访问了未分配的地址空间, 或者设备返回错误时,
> ysyxSoC可以通过AXI的`resp`信号传递相关的错误信息.
> 即使程序未启动CTE, 也可以让NPC在发生这些事件时跳转到地址`0`,
> 让你感觉到程序运行不正常.
> 相比于放过这些错误事件让NPC继续运行, 这也许能帮助你节省大量的调试时间. -->
> #### option::Make NPC throw Access Fault exception
> Although not mandatory, we recommend that you add the implementation of Access Fault in NPC. When the system operation unexpectedly causes access to an unallocated address space, or the device returns an error, ysyxSoC can return the relevant error information through the AXI `resp` signal. Even if the program does not start the CTE, you can let NPC jump to address `0` when these events occur, making you feel that the program is not running properly. Compared with missing these error events and let NPC continue to run, this may help you save a lot of debugging time.

<!-- ### 内存访问测试 -->
### Memory access test

<!-- 可以执行`dummy`测试后, 我们认为NPC基本上能成功访问ysyxSoC的SRAM了.
我们知道, 访存是程序运行的基础. 为了对访存行为进行更充分的测试,
我们需要编写一个程序`mem-test`来测试更大范围的内存.

从范围上看, `mem-test`希望能测试所有可写内存区域.
但`mem-test`本身的运行需要栈区的支持, 而栈区需要分配在可写内存区域,
因此在测试时需要绕开栈区, 避免栈区内容被覆盖, 导致`mem-test`本身运行出错.
我们可以把栈区放在SRAM的末尾, 并把堆区的起始地址设置在SRAM的开始,
堆区的结束地址设置在栈区的起始地址(即栈顶的初值).
设置好堆区的范围之后, 就可以把堆区作为`mem-test`的测试范围.

从测试方式上看, 我们采用一种最直观的方式: 先往内存区间写入若干数据, 再读出并检查.
我们可以让写入的数据与内存的地址相关, 从而方便检查, 例如`data = addr & len_mask`.
以下示意图展示了通过8位, 16位, 32位, 64位的写入地址和地址之间的关系. -->
After `dummy` test can be executed successfully, we think that NPC can basically successfully access the SRAM of ysyxSoC. We know that memory access is the basis for running programs. In order to more fully test the memory access behavior, we need to write a program `mem-test` to test a larger range of memory.

Regarding to scope, `mem-test` hopes to test all writable memory areas. However, the execution of `mem-test` itself requires the support of the stack, and the stack needs to be allocated in the writable memory area, so the stack area needs to be bypassed during testing to avoid the content of the stack area being overwritten, causing `mem-test` itself to run incorrectly. We can put the stack area at the end of SRAM, set the initial address of the heap area at the beginning of SRAM, and set the end address of the heap area at the beginning address of stack (that is, the initial value of the top of the stack). After setting the range of the heap, you can use it as the test range of `mem-test` .

From the test method, we adopt the most intuitive method: first write some data to the memory area, then read and check. We can make the written data related to the memory address, so as to facilitate the check, for example, `data = addr & len_mask` . The following diagram shows the relationship between the write address and the address through 8-bit, 16-bit, 32-bit, and 64-bit.

```txt
    SRAM_BASE                                    SRAM_BASE + 0x10
        |                                               |
        V                                               V
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
8-bit   |00|01|02|03|04|05|06|07|08|09|0a|0b|0c|0d|0e|0f|
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
16-bit  |00|00|02|00|03|00|04|00|08|00|0a|00|0c|00|0e|00|
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
32-bit  |00|00|00|0f|04|00|00|0f|08|00|00|0f|0c|00|00|0f|
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
64-bit  |00|00|00|0f|00|00|00|00|08|00|00|0f|00|00|00|00|
        +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
```

<!-- 测试分两步, 第一步是依次向各个内存区间写入相应数据,
第二步是依次从各个内存区间中读出数据, 并检查是否与之前写入的数据一致.
可分别通过8位, 16位, 32位, 64位的写入方式重复上述过程. -->
The test is divided into two steps. The first step is to write the corresponding data to each memory interval in sequence. The second step is to read data from each memory interval in sequence and check whether it is consistent with the previously written data. It can be done by writting in 8-bits, 16-bits, 32-bits and 64-bits modes repeatedly.

<!-- > #### todo::通过mem-test测试内存访问
> 在`am-kernels`中编写一个新的程序`mem-test`, 完成上述内存测试功能.
> 如果检查数据时发现不一致, 就通过`halt()`结束`mem-test`的运行.
>
> 一些提示:
> 1. 目前程序的全局变量分配在MROM中, 因此你的程序不能包含对全局变量的写入操作
> 1. `printf()`的代码较复杂, 调用`printf()`可能会使程序大小超过MROM空间,
>    而且其中还包含不少访存操作, 甚至有可能包含对全局变量的写入,
>    因此目前我们不推荐通过`printf()`打印信息,
>    不过DiffTest, trace和波形应该足够帮助你排除bug
> 1. 为了避免编译优化带来的影响, 你需要想办法确认程序在运行过程中确实执行了预期的访存操作
> 1. 由于AXI总线的数据位宽是64位, 你可能会遇到窄传输相关的问题, 具体细节请RTFM -->
> #### todo::Test memory access via mem-test
> Write a new program `mem-test` in `am-kernels` to complete the above memory test function. If inconsistencies are found when checking the data, end the operation of `mem-test` through `halt()` .
>
> Some tips:
> 1. Currently, the global variables of the program are allocated in MROM, so your program cannot contain writing operations to global variables.
> 1. The code of `printf()` is relatively complex. Calling `printf()` may cause the program size to exceed the MROM space. It also contains many memory access operations, and even include writing to global variables. Therefore, we currently do not recommend using `printf()` to print information, but DiffTest, trace and waveform should be enough to help you troubleshoot the bug.
> 1. In order to avoid the impact of compilation optimization, you need to find a way to confirm that the program actually performs the expected memory access operations during execution.
> 1. Since the data bit width of the AXI bus is 64 bits, you may encounter problems related to narrow transmission. Please RTFM for details.

<!-- -->
<!-- > #### question::智能的链接过程
> 你已经在klib中实现了`printf()`, 但如果没有在`mem-test`中调用`printf()`,
> 链接后的可执行文件确实不包含`printf()`的代码.
> 这种智能的链接方式能够在存储器空间有限的情况下避免生成不必要的代码,
>
> 你知道目前的链接流程中有哪些相关的步骤或选项来实现上述功能吗? -->
> #### question::Intelligent linking process
>
> You have implemented `printf()` in klib, but if `printf()` is not called in `mem-test` , the linked executable file does not contain `printf()` code. This smart linking method can be used when memory space is limited. avoid generating unnecessary code,
>
> Do you know what steps in current linking method can accomplish this task?

<!-- -->
<!-- > #### comment::真实的内存访问测试程序
> 事实上, 上述测试方法并不能较为全面地测试各种访存问题.
> 真实的内存测试程序通常会采用更复杂的模式来测试内存的读写, 可以覆盖多种故障,
> 例如[memtest86](https://en.wikipedia.org/wiki/Memtest68).
> 还有实现在硬件的内存测试单元, 它们能进行更深入的测试,
> 感兴趣的同学可以了解一下[MBIST(Memory Build-In Self Test)][mbist]. -->
> #### comment::Real memory access test program
> In fact, the above test methods cannot comprehensively test various memory access problems. Real memory test programs usually use more complex modes to test memory reading and writing, which can cover multiple faults, such as [memtest86](https://en.wikipedia.org/wiki/Memtest68) . There are also implementations in Hardware memory test units, they can perform more in-depth testing. Interested students can learn about [MBIST (Memory Build-In Self Test)][mbist].

[mbist]: https://www.design-reuse.com/articles/45915/memory-testing-self-repair-mechanism.html

<!-- ### 支持全局变量的写入操作 -->
### Support writing operations of global variables

<!-- 很多程序都会写入全局变量, 因此我们还需要寻找一个解决方案来支持全局变量的写入操作.
由于全局变量位于数据段中, 为了方便叙述, 下文用"数据段"来代替"全局变量".
一个直接的想法是, 既然MROM不支持写操作, 我们就把数据段分配在SRAM中.
但在系统启动时, SRAM中并不包含有效的数据, 因此只能把数据段放到MROM中, 才能在系统启动时访问.
为了解决这个问题, 我们可以在程序真正开始执行前, 将数据段从MROM加载到SRAM中,
并让接下来的代码访问加载到SRAM中的数据段, 通过SRAM的可写特性支持全局变量的写入操作. -->
Many programs will write to global variables, so we also need to find a solution to support the writing operation of global variables. Since global variables are located in the data segment, for the convenience of description, "data segment" is used instead of "global variable" below. A direct idea is that since MROM does not support write operations, we allocate the data segment in SRAM. However, when the system is booting, SRAM does not contain valid data, so we can only put the data segment in MROM in order to access while system booting. In order to solve this problem, we can load the data segment from MROM into SRAM before the program actually starts executing, and let the subsequent code access the data segment loaded into SRAM. Through the writable feature of SRAM, writing operations to global variables is supported.

<!-- 事实上, 真实的操作系统也需要把程序加载到存储器中运行, 其中还需要进行很多复杂的操作.
因此执行上述加载操作的代码也可以看成一个加载器, 只不过目前其功能还很简单,
它只负责将程序的数据段从MROM加载到SRAM.
但由于这个加载器的工作时刻是在系统启动时, 因此我们将其称为bootloader. -->
In fact, a real operating system also needs to load programs into memory for running, which also requires many complex operations. Therefore, the code that performs the above loading operation can also be regarded as a loader, but its function is still very simple at present. It is only responsible for loading the data segment of the program from MROM to SRAM. But since the working time of this loader is when the system boots, we call it bootloader.

<!-- 简单来说, 我们需要实现以下三点:
1. 得到数据段在MROM中的地址MA(mrom address)和在SRAM中的地址SA(sram address), 以及数据段的长度LEN
1. 将数据段从MA复制到SA
1. 让程序代码通过SA访问数据段 -->
Simply put, we need to achieve the following three points:
1. Get the address MA (mrom address) of the data segment in MROM and the address SA (sram address) in SRAM, as well as the length of the data segment LEN
1. Copy data segments from MA to SA
1. Let program code access the data segment through SA

<!-- 对于第2点, 我们只需要调用`memcpy()`即可实现.
对于MA, 我们可以在链接脚本的数据段开始前定义一个符号, 即可在运行时刻让bootloader获得该符号的地址;
而对于LEN, 在链接脚本的数据段结束后定义一个符号, 与上述符号相减即可.
一个需要考虑的问题是, 如何获得SA.
一方面, 由于SA是一个地址, 而程序中的地址需要在链接中的重定位阶段才能确定,
因此SA最早也要在链接阶段才能确定.
另一方面, 由于第3点要求后续代码需要通过SA访问数据段,
而运行时刻的bootloader很难修改相应指令中的访问地址, 因此SA必须在运行前确定.
综合考虑上述两点, 我们可以得出结论: SA只能在链接阶段确定, 我们需要在链接脚本中定义SA. -->
For the second point, we only need to call `memcpy()` to achieve it. For MA, we can define a symbol before the start of the data segment of the link script, so that the bootloader can obtain the address of the symbol at runtime. For LEN, define a symbol after the data segment of the link script ends, and subtract it from the above symbol. One issue that needs to be considered is how to obtain SA. On the one hand, since SA is an address, and program addresses can only be determined in the relocation stage of link. So SA can only be determined in the link stage at the earliest. On the other hand, since the third point requires that subsequent code needs to access the data segment through SA, it is difficult for the bootloader to modify the access address in the corresponding instruction at runtime. Therefore SA must be determined before running. Considering the above two points, we can conclude that SA can only be determined during the link phase, and we need to define SA in the link script.

<!-- 为此, 我们需要用到链接脚本中的两种符号地址.
一种是虚拟内存地址(virtual memory address, VMA), 它表示程序运行时对象所在的地址;
另一种是加载内存地址(load memory address, LMA), 它表示程序运行前对象所在的地址.
通常情况下, 这两种地址相同. 但在上述需求中, 这两种地址有所不同:
数据段存放在MROM中, 但需要让程序代码访问加载到SRAM中的数据段, 即MA是LMA, SA是VMA. -->
For this reason, we need to use two symbolic addresses in the link script. One is the virtual memory address (VMA), which represents the address where the object is located when the program is running; the other is the load memory address (LMA), which represents the address where the object is located before the program running. Normally, these two addresses are the same. But in the above requirements, these two addresses are different. The data segment is stored in MROM, but the program needs to access the data segment loaded in SRAM, i.e. MA is LMA and SA is VMA.

<!-- 为了区分两种地址, 我们需要对链接脚本稍作修改.
首先, 我们需要定义两种存储器区间:
```ldscript
MEMORY {
  mrom : ORIGIN = 0x20000000, LENGTH = 4K
  sram : ORIGIN = 0x0f000000, LENGTH = 8K
}
```
然后在描述节和段的映射关系时, 显式地说明段的VMA和LMA. 例如:
```ldscript
SECTIONS {
  . = ORIGIN(mrom);
  .text : {
      /* ... */
  } > mrom AT> mrom
  /* ... */
}
```
其中`>`后表示VMA在的存储器区间, `AT>`后表示LMA所在的存储器区间.
上述链接脚本表示, 代码段将链接到MROM空间, 同时也位于MROM空间. -->
In order to distinguish between the two types of addresses, we need to slightly modify the linker script. First, we need to define two types of memory ranges:

```ldscript
MEMORY {
  mrom : ORIGIN = 0x20000000, LENGTH = 4K
  sram : ORIGIN = 0x0f000000, LENGTH = 8K
}
```

Then when describing the mapping relationship between sections and segments, explicitly state the VMA and LMA of the segment. For example:

```ldscript
SECTIONS {
  . = ORIGIN(mrom);
  .text : {
      /* ... */
  } > mrom AT> mrom
  /* ... */
}
```

Among them, after `>` , it indicates the memory range where VMA is located, and after `AT>` , it indicates the memory range where LMA is located. The above link script indicates that the code segment will be linked to the MROM space and is also located in the MROM space.

<!-- > #### todo::通过bootloader将数据段加载到内存
> 根据上述内容, 在TRM调用`main()`函数前, 将数据段加载到SRAM, 从而支持后续代码写入全局变量.
> 如果你的实现正确, 你应该能成功运行`cpu-tests`中除`hello-str`外的所有测试.
>
> 一些提示:
> 1. bootloader的加载过程可以通过汇编代码编写一些简单循环来实现,
>    也可以在C代码中调用`memcpy()`等函数
> 1. 链接脚本的编写可以参考[官方文档][ldscript]
>    * 为了强迫大家仔细RTFM, 我们在上述介绍中忽略了一个你有可能已经想到的小细节,
>      这个细节已经在官方文档中提到, 即使你真的没想到, 也可以通过仔细阅读文档来得知
> 1. 可以通过`--print-map`选项查看`ld`如何进行链接 -->
> #### todo::Load data segments into memory through bootloader
> According to the above content, before TRM calls `main()` function, the data segment is loaded into SRAM, thereby supporting subsequent code to write global variables. If your implementation is correct, you should be able to successfully run `cpu-tests` except `hello-str` .
>
> Some tips:
> 1. The loading process of bootloader can be implemented by writing some simple loops in assembly code, or you can call functions such as `memcpy()` in C code
> 1. To write the link script, please refer to [the official documentation.][ldscript]
>     * In order to force everyone to RTFM carefully, we have ignored a small detail that you may have thought of in the above introduction. This detail has been mentioned in the official documentation. Even if you really didn't notice it, you can still know it by reading the documentation carefully.
> 1. You can use `--print-map` option to see how `ld` is linked.

[ldscript]: https://sourceware.org/binutils/docs/ld/index.html

<!-- ### 通过串口输出

支持全局变量的写入操作后, 只要MROM和SRAM能装下的可计算程序, 理论上都能运行.
最后我们来讨论`putch()`的实现.

> #### todo::实现putch()
> 仿照上文的`char-test`, 通过向UART16550写入字符, 实现`putch()`的功能.
> 实现后运行`hello`程序, 如果你的实现正确, 你将看到NPC输出若干字符.
>
> 不过你发现NPC并没有输出全部字符, 尽管这并不是我们所期望的,
> 但目前来说这是预期行为, 我们接下来将会修复这个问题. -->
### Output via serial port

After supporting the writing operation of global variables, any computable programs that can be loaded in MROM and SRAM can theoretically be executed. Finally, let's discuss the implementation of `putch()` .

> #### todo::implement putch()
>
> Imitate `char-test` above and implement `putch()` function by writing characters to UART16550. After implementation, run `hello` program. If your implementation is correct, you will see NPC output several characters.
>
> However, you found that NPC did not output all characters. Although this is not what we expected, this is the expected behavior for now, and we will fix this problem next.

<!-- -->
<!-- > #### todo::观察NPC输出的行为
> 尝试修改`hello.c`的代码, 增加或减少字符串的长度, 观察NPC输出字符串的行为.
> 根据你的观察, 你猜测原因可能是什么?
>
> 这个问题更本质的提问方式是: 你是否了解"程序在ysyxSoC中输出一个字符"的每一处细节?
> 尽管我们接下来就会公布答案, 愿意挑战的同学可以先暂停往下阅读,
> 尝试RTFSC梳理其中的每一处细节, 毕竟通过自己的探索获得答案能收获更大的成就感. -->
> #### todo::Observe the behavior of NPC output
> Try modifying the code of `hello.c` , increasing or decreasing the length of the string, and observing the behavior of the NPC outputting the string. Based on your observations, what do you guess the cause might be?
>
> A more essential way to ask this question is: Do you understand every detail of "the program outputs a character in ysyxSoC"? Although we will give the answer next, students who are willing to challenge can pause reading and try RTFSC to comb every detail in it, after all, you can gain a greater sense of accomplishment by getting the answer through your own exploration.

<!-- 你也许已经观察到这个奇怪的现象: NPC输出了一部分字符,
也通过`ebreak`指令成功结束仿真, 说明程序本身没有致命问题,
但有一些字符却消失了: 程序本应该将它们写入到串口, 但在终端上却看不到它们.
如果你仔细观察, 你会发现, 无论程序中的字符串有多长, 终端上最多只输出16个字符.
16作为2的幂, 看起来并不是巧合, 很可能预示着某种配置.

当然, 无论猜想多么精彩, 最终都要RTFSC去验证猜想, 这里我们还是把RTFSC的过程留给大家.
认真RTFSC之后, 你会发现导致上述问题的原因, 竟然是软件没有对串口初始化!
因为没有初始化, 串口的发送功能并没有工作,
因此写入串口的字符一直占用串口的发送队列, 队列满后就无法写入更多字符. -->
You may have observed this strange phenomenon: NPC outputs some characters and successfully ended the simulation through the `ebreak` command, indicating that there is no fatal problem with the program itself, but some characters have disappeared. The program should have written them to the serial port, but you can't see them on the terminal. If you look carefully, you will find that no matter how long the string in the program is, only 16 characters are output at most on the terminal. 16 is a power of 2, which does not seem to be a coincidence. May indicate a certain configuration.

Of course, no matter how exciting the guess is, we will always prove it by RTFSC. Here we still leave the RTFSC process to everyone. After carefully RTFSC, you will find that the cause of the above problems is that the software did not initialize the serial port! Because there is no initialization, the sending function of the serial port does not work, so the characters written to the serial port always occupy the sending queue of the serial port. Once the queue is full, no more characters can be written.

<!-- 事实上, 在往串口输出字符之前, 软件需要进行以下初始化:
1. 设置串口收发参数, 具体包括波特率, 字符长度, 是否带校验位, 停止位的位宽等
   * 波特率指每秒传送的字符数. 不过通常并非直接在寄存器中设置波特率,
     而是设置一个与波特率成反比的除数:
     除数越小, 波特率越大, 传输速率越快, 但受电气特性的影响, 误码率也越高, 字符传送成功的概率越低;
     相反, 除数越大, 波特率越小, 传输速率越慢, 软件等待的时间也越长.
     除数的值还与串口控制器的工作频率有关, 后者即串口每秒传送的比特数, 可RTFM了解两者的具体关系.
   * 串口收发端的参数配置要完全一致, 才能正确发送和接收字符.
     通常用形如`115200 8N1`等方式来描述一组参数配置,
     它表示波特率是115200, 字符长度是8位, 不带校验位, 1位停止位.
1. 按需设置中断, 不过NPC目前不支持中断, 因此可不设置 -->
In fact, before outputting characters to the serial port, the software needs to perform the following initialization:
1. Set serial port transceiver parameters, including baud rate, character length, whether to include parity bits, stop bit width, etc.
    * The baud rate refers to the number of characters transmitted per second. However, the baud rate is usually not set directly in the register, but a divisor that is inversely proportional to the baud rate is set. The smaller the divisor, the greater the baud rate, and the faster the transmission rate. , but affected by the electrical characteristics, the higher the bit error rate, the lower the probability of successful character transmission; on the contrary, the larger the divisor, the smaller the baud rate, the slower the transmission rate, and the longer the software waits. The divisor is also related to the operating frequency of the serial port controller, which is the number of bits transmitted by the serial port per second. RTFM can understand the specific relationship between the two.
    * The parameter configuration of the serial port transceiver must be completely consistent in order to send and receive characters correctly. A set of parameter configurations is usually described in the form of `115200 8N1` , which means that the baud rate is 115200, the character length is 8 bits, no check digit and 1 stop bit.
1. Set interrupts as needed, but NPC currently does not support interrupts, so you do not need to set them

<!-- > #### todo::正确实现串口的初始化
> 你需要在TRM中添加代码, 设置串口的除数寄存器.
> 由于ysyxSoC本质上还是一个仿真环境, 没有串口接收端, 也没有电气特性的概念,
> 因此目前可随意设置上述除数, 不必担心误码率的问题.
> 当然, 在真实的芯片中, 除数寄存器的设置是需要仔细考量的.
> 此外, 我们也会在后续实验内容中接入一个串口终端来进行更多的测试.
>
> 具体如何设置除数, 你可以RTFM了解UART IP的功能,
> 也可以RTFSC, 结合UART16550寄存器的RTL实现, 帮助你理解设置的除数如何工作.

如果除数寄存器设置得足够小, 你会观察到`hello`程序多输出了一些字符, 但仍然会出现字符丢失的情况.
为了解决这个问题, 我们需要在向串口写入字符之前, 保证其发送队列一定有空闲位置可以写入.
这可以通过查询串口的状态寄存器实现: 软件可以轮询相关寄存器, 直到确保写入的字符不会丢失为止. -->
> #### todo::Correctly implement serial port initialization
>
> You need to add code to the TRM to set the divisor register of the serial port. Since ysyxSoC is essentially a simulation environment, there is no serial port receiving end, and there is no concept of electrical characteristics, so you can currently set the above divisor at will without worrying about the bit error rate. Of course, in a real chip, the setting of the divisor register needs to be carefully considered. In addition, we will also connect a serial port terminal to conduct more tests in subsequent labs.
>
> Specifically how to set the divisor, you can RTFM to understand the function of the UART IP, or you can RTFSC, combined with the RTL implementation of the UART16550 register, to help you understand how the set divisor works.

If the divisor register is set small enough, you will observe that `hello` program outputs some extra characters, but some characters will still be lost. In order to solve this problem, we need to ensure that the sending queue must have enough free spaces which can be wrriten to before writing characters to the serial port. This can be achieved by querying the status register of the serial port. The software can poll the relevant register until it is sure that the written characters will not be lost.

<!-- > #### todo::输出前轮询串口的状态寄存器
> 你需要修改`putch()`的代码, 在输出前先查询串口发送队列的情况.
> 具体如何查询, 同样地, 你可以RTFM了解UART IP的功能,
> 也可以RTFSC, 结合UART16550寄存器的RTL实现, 帮助你理解相关的功能.

串口能正常工作后, TRM就可以运行更多程序了.
不过目前程序的规模还是受限于MROM和SRAM的大小.
受制造工艺的影响, 如果要在成本可接受的情况下使用更大的存储器,
我们就需要使用一些更慢的存储器. -->
> #### todo::polling the status register of the serial port before outputting
>
> You need to modify the code of `putch()` and query the status of the serial port sending queue before outputting. How to query specifically? Similarly, you can RTFM to understand the functions of the UART IP, or you can RTFSC, combined with the RTL implementation of the UART16550 register, to help you understand related functions.

Once the serial port can work correctly, TRM can run more programs. However, the size of the current program is still limited by the size of MROM and SRAM. Affected by the manufacturing process, if you want to use larger memory at an acceptable cost , we need to use some slower memory.

<!-- ## 可重复编程的非易失存储器

首先我们来解决程序存放的问题.
MROM除了成本高之外, 另一个缺点就是可编程性很弱.
事实上, MROM只支持制造时编程, 即MROM的内容是在RTL设计时决定的,
经过后端物理设计后, 晶圆厂将根据版图制作用于光刻的掩膜(mask),
然后用这个掩膜来制造芯片, 这也是mask ROM中mask的含义.
但在芯片制造完成后, MROM中存储的内容无法进行更改.
如果要通过重新流片的方式来更换芯片运行的程序, 代价是不可接受的.

随着存储技术的发展, 人们发明了可重复编程和擦除的ROM, 目前广泛使用的flash存储器就是其中一种.
用户能够在某些条件下擦除flash存储器中存放的内容, 并重新进行写入.
通常来说, 用户只需要购买一个数十元的烧录器, 即可通过烧录软件更新flash中的内容.
通过这种方式, 更换flash中存放的程序的代价变得可以接受.

U盘的流行甚至使得用户无需购买专门的烧录器.
U盘的本质就是一块USB接口的flash存储器, 外加一个MCU.
如今操作系统都内置USB协议的flash驱动程序,
因此用户只需要将U盘插入计算机, 即可往其中写入数据.
不过这对当前的NPC来说有点复杂了, 不仅需要配备一个USB控制器,
还需要运行相应的驱动程序才能完成烧录操作, 因此"一生一芯"还是采用烧录器的方案. -->
## Reprogrammable non-volatile memory

First, let’s solve the problem of program storage. In addition to high cost, another disadvantage of MROM is that its programmability is very weak. In fact, MROM only supports manufacturing-time programming, that is, the content of MROM is determined during RTL design. After the back-end physical design, the wafer factory will make a mask for photolithography based on the layout, and then use this mask to manufacture the chip. This is also the meaning of mask in mask ROM. But after the chip manufacturing is completed, the stored content in MROM cannot be changed. If the program running on the chip needs to be replaced by re-tape, the cost is unacceptable.

With the development of storage technology, people have invented ROMs that can be programmed and erased repeatedly, one of which is the widely used flash memory. Users can erase the contents stored in the flash memory and rewrite it under certain conditions. Generally speaking, users only need to purchase a burner worth tens of yuan (about $1.38) to update the content in the flash through the burning software. In this way, the cost of replacing the program stored in the flash becomes acceptable.

The popularity of U disks even eliminates the need for users to purchase a special programmer. The essence of a U disk is a flash memory with a USB interface, plus an MCU. Nowadays, operating systems have built-in flash drivers for the USB protocol, so users only need to plug it into the computer and you can write data to it. However, this is a bit complicated for the current NPC. It not only needs to be equipped with a USB controller, but also needs to run the corresponding driver to complete the programming operation, so OSOC still adpots the programmer solution

<!-- ### flash的存储单元

> #### hint::建设中
> 本小节无编程任务, 感兴趣的同学可以先阅读课件或观看B站录播. -->
### flash storage unit

> #### hint::under construction
>
> There are no programming tasks in this section. Interested students can read the courseware or watch the recording at bilibili.com first.

<!-- ### flash颗粒的内部结构 -->
### Internal structure of flash particles

<!-- 为了让大家进一步了解flash存储器, 我们介绍型号为W25Q128JV的flash颗粒的内部结构.
这种型号的flash颗粒有24根地址线, 可以存储16MB的数据, 这足够我们存放绝大部分的测试程序了.
整个flash颗粒的存储阵列划分成256个块(Block), 每个块的大小是64KB;
每个块的内部又划分成16个扇区(Sector), 每个扇区的大小是4KB;
每个扇区的内部又划分成16个页(Page), 每个页的大小是256B. -->
In order to let everyone further understand the flash memory, we introduce the internal structure of the flash particle model W25Q128JV. This type of flash particle has 24 address lines and can store 16MB of data, which is enough for us to store most of the test programs. The entire flash particle storage array is divided into 256 blocks, the size of each block is 64KB; each block is divided into 16 sectors, the size of each sector is 4KB. The interior of the sector is divided into 16 pages, and the size of each page is 256B.

<!-- ![image](https://ysyx.oscc.cc/slides/2306/resources/img/18-flash-diagram.jpg) -->
![image](https://ysyx.oscc.cc/slides/2306/resources/img/18-flash-diagram.jpg)

<!-- 在flash颗粒中, 字节是最小的读取单位, 支持随机读取.
对于写入操作, 就比较复杂了, 如果要写入`0`, 只需要对相应的存储单元进行编程操作即可;
但如果要写入`1`, 就要先进行擦除操作, 而由于flash存储单元的物理特性,
扇区是最小的擦除, 也即, 我们需要将所在扇区的存储内容全部读出,
然后擦除该扇区, 再按照新数据对该扇区进行编程.
可见, flash的写入开销比读取大得多. -->
In flash particles, byte is the smallest reading unit and supports random reading. For writing operations, it is more complicated. If you want to write `0` , you only need to program the corresponding storage unit. If we write `1` , we must first perform an erase operation. Due to the physical features of the flash memory unit, the sector is the smallest eraser. That is, we need to read out all the storage contents of the sector and then erase the sector. And then program the sector according to the new data. It can be seen that the writing overhead of flash is much greater than that of reading.

<!-- 除了存储阵列外, flash颗粒中还包含若干寄存器, 包括一些地址寄存器用于控制读写flash颗粒的地址,
控制寄存器用于控制颗粒的行为(如写保护, 访问权限等), 状态寄存器用于存放flash颗粒当前读写的状态.
可以看到, flash颗粒的内部就是一个设备控制器! -->
In addition to the storage array, flash particles also contain several registers, including some address registers used to control the address of reading and writing flash particles, control registers used to control the behavior of the particles (such as write protection, access permissions, etc.), and status registers used to store the current reading and writing status of the flash particle. As you can see, the inside of the flash particle is a device controller!

<!-- 为了访问flash颗粒, 外部需要向其发送命令.
flash颗粒接收到外部的命令后, 将会对命令进行解析, 然后执行命令的具体功能.
这与CPU执行指令的过程是很类似的, CPU的指令周期包括取指, 译码, 执行, 更新PC,
而对包括flash颗粒在内的大部分设备来说, 其处理过程包括接收命令, 解析, 执行, 等待新命令.
至于命令的格式和功能, 当然是由[相应的手册][flash manual]来定义了.
例如, 8位命令`03h`表示从flash颗粒中读出数据, 命令后紧跟24位的存储单元地址.
因此, 如果你学会了CPU设计, 你完全有能力根据flash颗粒的手册设计出flash颗粒的核心逻辑. -->
In order to access the flash particle, an external command needs to be sent to. After the flash particle receives the external command, it will parse the command and then execute the specific function of the command. This is very similar to the process of the CPU executing instructions. The CPU instruction cycle includes fetching, decoding, executing, and updating the PC. For most devices, including flash particles, the processing process includes receiving commands, parsing, executing, and waiting for new commands. As for the format and function of the command, it is defined by [the corresponding manual][flash manual] . For example, the 8-bit command `03h` means reading data from the flash particle, and the command is followed by the 24-bit storage unit address. Therefore, if you have learned CPU design, you are fully capable of designing the core logic of flash particles according to the design manual of it.

[flash manual]: https://evelta.com/content/datasheets/153-W25Q128JVSIQ.pdf

<!-- 借助总线, 我们很容易将CPU的访存请求翻译成flash颗粒的读写命令.
以目标地址为flash空间的load请求为例, CPU的LSU在执行load指令时,
将在总线上发起一个读事务, 该读事务请过Xbar最终传到flash控制器,
flash控制器检查该事务的属性, 发现是读事务, 则生成相应的读命令,
并根据总线事务中的地址生成读命令的地址, 将该命令发往flash颗粒.
一段时间后, flash控制器得到从flash颗粒中读出的数据,
便将这些数据作为总线事务的回复传送给CPU, CPU的LSU接收到读结果后, load指令继续执行. -->
With the help of the bus, we can easily translate the CPU's memory access request into the read and write commands of the flash particles. Taking the load request whose target address is the flash space as an example, when the CPU's LSU executes the load instruction, it will initiate a read transaction on the bus , the read transaction passes through The command is sent to the flash particle. After a period of time, the flash controller obtains the data read from the flash particle and transmits the data to the CPU as a reply to the bus transaction. After the CPU's LSU receives the read result, the load instruction continues to execute.

<!-- > #### todo::RTFSC理解从flash中读出数据的过程
> ysyxSoC包含了上述过程的代码实现, 并且将flash存储空间映射到CPU的地址空间`0x3000_0000~0x3fff_ffff`.
> 你需要先在`ysyxSoC/perip/spi/rtl/spi_top_apb.v`中定义宏`FAST_FLASH`, 然后尝试结合代码理解上述过程.
>
> 至于flash的写入, 由于flash的写入需要先擦除一整个扇区, 再重新写入整片的数据,
> 因此需要向flash颗粒发送多次命令.
> 不过当前我们只是期望用flash替代MROM, 使得NPC在复位时能从flash中取出有效的指令,
> 因此我们暂时不会对flash颗粒进行写操作, ysyxSoc的flash颗粒代码中也仅支持读操作. -->
> #### todo::RTFSC to understand the process of reading data from flash
> ysyxSoC contains the code implementation of the above process, and maps the flash storage space to the CPU's address space `0x3000_0000~0x3fff_ffff` . You need to first define the macro `FAST_FLASH` in `ysyxSoC/perip/spi/rtl/spi_top_apb.v` , and then try to understand the above in combination with the code process.
>
> Regarding the writing to flash, because writing to flash requires erasing an entire sector before rewriting the whole set of data, it is necessary to send multiple commands to the flash chip. However, at present, we are only looking to use flash to replace MROM, so that NPC can fetch valid instructions from the flash upon reset. Therefore, we will not be performing write operations on the flash chip for the time being. The flash chip code in ysyxSoc also only supports read operations.

<!-- -->
<!-- > #### todo::从flash中读出数据
> 理解从flash中读出数据的过程后, 接下来就可以通过代码测试这一过程了:
> 1. 在仿真环境中定义一个代表flash存储空间的数组
> 1. 在仿真环境初始化时, 往上述数组写入若干内容
>    * 此操作可以看作是模拟了往flash颗粒中烧录数据的过程
> 1. 正确实现`flash_read()`函数, 使其根据参数`addr`返回flash中相应位置的内容
> 1. 在`am-kernels`中编写一个简单的测试程序, 从flash存储空间中读出内容,
>    并检查是否与仿真环境初始化时设置的内容一致 -->
> #### todo::Read data from flash
> After understanding the process of reading data from flash, you can then test this process through code:
> 1. Define an array representing the flash storage space in the simulation environment
> 1. When the simulation environment is initialized, write certain contents to the above array.
>     * This operation can be seen as simulating the process of programming data into flash particles.
> 1. Correctly implement `flash_read()` function so that it returns the content of the corresponding location in flash according to the parameter `addr` .
> 1. Write a simple test program in `am-kernels` , read the content from the flash storage space, and check whether it is consistent with the content set when the simulation environment is initialized.

<!-- ### 通过SPI总线协议访问flash颗粒 -->
### Access flash particles through SPI bus protocol

<!-- 因为flash颗粒的制造工艺与处理器的制造工艺不同, 因此处理器芯片和flash颗粒芯片要单独制造生产,
然后再焊接到板卡上, 通过板卡上的走线来通信. 也因为这样, 引脚数量就成了一个需要考虑的问题.
一方面, 如果引脚数量太多, 就不利于将芯片做小, 这对板卡的布局和面积都会产生负面影响;
另一方面, 板卡上的走线距离通常比芯片内部的走线要长, 信号也更容易受到干扰,
故引脚数量太多也会导致板卡上走线密集, 这些走线之间也很容易相互干扰, 影响信号的稳定性. -->
Due to the manufacturing process of flash chips being different from that of processor chips, the processor and flash chips must be manufactured separately and then soldered onto a board, where they communicate through the wires on the board. For this reason, the number of pins becomes a consideration. On one hand, if there are too many pins, it is not conducive to minimizing the size of the chip, which can negatively affect the layout and area of the board. On the other hand, the wires on the board are usually longer than those inside the chip, making the signals more susceptible to interference. Consequently, a high number of pins can lead to a dense arrangement of traces on the board, where these traces can easily interfere with each other, affecting the stability of the signals.

<!-- 以上文提到的读命令为例, 一次读操作至少涉及8位的命令, 24位的地址,
以及8位的数据, 这就已经占用40比特的信号了.
因此把这些信号全部通过引脚通到flash颗粒外部, 并不是一个好的方案. -->
Taking the read command mentioned above as an example, a read operation involves at least an 8-bit command, a 24-bit address, and an 8-bit data, which already occupies a 40-bit signal. Therefore, all these signals are passed through the pins. Going outside the flash particle is not a good solution.

<!-- 为了降低flash颗粒的引脚数量, 一般会在flash颗粒中添加一个SPI总线接口.
SPI的全称是Serial Peripheral Interface, 是一种串行总线协议,
通过少数几根信号线在master和slave之间进行通信. -->
In order to reduce the number of pins of the flash particle, an SPI bus interface is generally added to the flash particle. The full name of SPI is Serial Peripheral Interface, which is a serial bus protocol that is carried out between the master and the slave through a few signal lines for communication.

![image](https://ysyx.oscc.cc/slides/2306/resources/img/18-spi-bus.jpg)

<!-- SPI总线总共只有4种信号:
1. `SCK` - master发出的时钟信号, 只有1位
1. `SS` - slave select, master发出的选择信号, 用于指定通信对象, 每个slave对应1位
1. `MOSI` - master output slave input, master向slave通信的数据线, 只有1位
1. `MISO` - master input slave output, slave向master通信的数据线, 只有1位 -->
There are only 4 signals in total on the SPI bus:
1. `SCK` - the clock signal sent by the master, only 1 bit
1. `SS` - slave select, the selection signal sent by the master, used to specify the communication object, each slave corresponds to 1 bit
1. `MOSI` - master output slave input, the data line used by master to communicate with slave, only 1 bit
1. `MISO` - master input slave output, the data line used by the slave to communicate with the master, only 1 bit
  
<!-- 为了基于SPI总线进行通信, master通常先通过`SS`信号选择目标slave,
然后通过`SCK`信号向slave发出SPI的时钟脉冲,
同时将需要发送的信息转化成串行信号, 逐个比特通过`MOSI`信号传输给slave;
然后监听`MISO`信号, 并将通过`MISO`接收到的串行信号转化成并行信息, 从而获得slave的回复. -->
To communicate over the SPI bus, the master usually first selects the target slave with the `SS` signal, then sends the SPI clock pulses to the slave with the `SCK` signal, while converting the information to be sent into a serial signal, transmitting it to the slave bit by bit through the `MOSI` signal; then it listens to the `MISO` signal, and converts the serial signal received through `MISO` back into parallel information, thereby obtaining the reply from the slave.

<!-- slave的工作方式是类似的, 如果slave在`SS`信号有效的情况下收到`SCK`时钟脉冲,
则监听`MOSI`信号, 并将通过`MOSI`接收到的串行信号转化成并行信息, 从而获得master的传来的命令;
处理完命令后, 将需要回复的信息转化成串行信号, 逐个比特通过`MISO`信号传输给master. -->
The working mode of the slave is similar, if the slave receives the `SCK` clock pulses while the `SS` signal is active, it listens to the `MOSI` signal, and converts the serial signal received through `MOSI` into parallel information, thereby obtaining the command sent by the master; after processing the command, it converts the information to be replied into a serial signal, transmitting it to the master bit by bit through the `MISO` signal.

<!-- 可以看到, 除了状态机之外, 实现SPI总线协议的核心就是串行/并行信号之间的转换,
具体来说就是发送方如何将信号发送出去, 以及接收方如何采样并接收信号.
一方面需要考虑发送的尾端(endianness): 是从高位到低位发送, 还是从低位到高位发送;
另一方面需要考虑发送和采样的时机(时钟相位, clock phase):
是在`SCK`上升沿时发送/采样, 还是在`SCK`下降沿时发送/采样.
有时还会约定时钟空闲时的电平(时钟极性, clock polarity): 是高电平空闲还是低电平空闲.
在发送和采样的过程中, `SCK`起到了同步的作用,
双方共同约定发送/采样的尾端和时机, 并在RTL层次正确地实现约定.
在真实场景中, 不同的slave可能有不同的约定, 这意味着在与不同slave通信的时候,
master需要配合slave的约定来进行发送和采样. -->
As we can see, aside from the state machine, the core of implementing the SPI bus protocol lies in the conversion between serial and parallel signals. Specifically, it involves how the sender transmits signals and how the receiver samples and receives them. On one hand, we need to consider the endianness of the transmission: whether it is from most significant bit to least significant bit, or vice versa. On the other hand, we need to consider the timing of transmission and sampling (clock phase): whether it occurs on the rising edge or the falling edge of `SCK`. Sometimes, the idle state level of the clock (clock polarity) is also defined: whether it is high or low when idle. During the transmission and sampling process, `SCK` plays a role in synchronization. Both parties agree on the endianness and timing of transmission/sampling and correctly implement the agreement at the RTL level. In real scenarios, different slaves may have different agreements, meaning that when communicating with different slaves, the master needs to adapt to the agreements of the slaves for transmission and sampling.

<!-- 不过, 上层软件并不希望关心这些信号层次的行为,
因此SPI master还需要将这些信号层次的行为抽象成设备寄存器,
上层软件只要访问这些设备寄存器, 就可以查询或控制SPI master.
事实上, 在总线架构中, SPI master有两重身份,
它一方面是AXI(或其他AMBA协议, 如APB)的slave, 负责接收来自CPU的命令,
另一方面又是SPI的master, 负责给SPI的slave发送命令.
因此我们也可以将SPI master看成是AXI和SPI之间的一个桥接模块,
用于将AXI请求转换成SPI请求, 从而与SPI的slave进行通信. -->
However, upper-level software does not wish to concern itself with these signal-level behaviors. Therefore, the SPI master also needs to abstract these signal-level behaviors into device registers. By accessing these device registers, the upper-level software can query or control the SPI master. In fact, in the bus architecture, the SPI master has a dual role. On one hand, it acts as a slave to AXI (or other AMBA protocols, such as APB), responsible for receiving commands from the CPU. On the other hand, it serves as the master to SPI, responsible for sending commands to the SPI slaves. Thus, we can also view the SPI master as a bridge module between AXI and SPI, converting AXI requests into SPI requests to communicate with SPI slaves.

<!-- ysyxSoC集成了SPI master的实现, 并将其设备寄存器映射到CPU的地址空间`0x1000_1000~0x1000_1fff`,
相关代码和手册在`ysyxSoC/perip/spi/`下的相应子目录中.
有了设备寄存器的抽象, 我们就可以梳理上层软件的行为了.
为了与不同的slave通信, master一般需要支持多种约定,
具体设置成哪一种约定, 是通过配置设备寄存器来实现的.
SPI驱动程序在与slave通信之前, 先设置`SS`寄存器来选择目标slave,
并按照slave的约定配置SPI master的控制寄存器,
然后再将需要传输的数据写入发送数据寄存器, 最后往某控制寄存器写入表示"开始传输"的命令.
SPI驱动程序可以轮询SPI master的状态寄存器, 当状态标志为"忙碌"时则等待,
直到状态标志为"空闲"为止, 此时可从接收数据寄存器中读出slave的回复. -->
The ysyxSoC integrates the implementation of an SPI master, and maps its device registers into the CPU's address space `0x1000_1000~0x1000_1fff`, with related code and documentation located in the corresponding subdirectories under `ysyxSoC/perip/spi/`. With the abstraction of device registers, we can then delineate the behavior of higher-level software. To communicate with different slaves, the master generally needs to support multiple protocols, and the specific setting of which protocol to use is accomplished by configuring the device registers. Before communicating with a slave, the SPI driver first sets the `SS` register to select the target slave, and configures the SPI master's control registers according to the slave's protocol, then writes the data to be transmitted into the transmission data register, and finally writes a command that signifies "start transmission" into a control register. The SPI driver can poll the SPI master's status register, waiting when the status flag is "busy" and continuing only when the status flag turns to "idle", at which point the slave's response can be read from the reception data register.

<!-- > #### todo::实现基于SPI协议的位翻转模块 -->
> #### todo::Implement the bit flip module based on SPI protocol
<!-- > 为了熟悉并测试SPI的基本流程, 我们来编写一个简单的位翻转模块bitrev.
> 该模块接收一个8位的数据, 然后输出该数据的位翻转结果,
> 也即, 将输入数据的第0位与第7位交换, 第1位与第6位交换... -->
> To become familiar with and test the basic process of SPI, let's write a simple bit reversal module, bitrev. This module receives an 8-bit data input and then outputs the result of reversing the bits of that data. Specifically, it swaps the 0th bit with the 7th bit, the 1st bit with the 6th bit, and so on.
>
<!-- > 具体地, 如果你选择Verilog, 你需要在`ysyxSoC/perip/bitrev/bitrev.v`中实现相应代码;
> 如果你选择Chisel, 你需要在`ysyxSoC/soc/BitRev.scala`的`bitrevChisel`模块中实现相应代码,
> 并将`ysyxSoC/soc/SoC.scala`中的`Module(new bitrev)`修改为实例化`bitrevChisel`模块. -->
> Specifically, if you choose Verilog, you need to implement the corresponding code within `ysyxSoC/perip/bitrev/bitrev.v`; if you choose Chisel, you need to implement the corresponding code within the `bitrevChisel` module in `ysyxSoC/soc/BitRev.scala`, and modify `Module(new bitrev)` in `ysyxSoC/soc/SoC.scala` to instantiate the `bitrevChisel` module.
>
<!-- > 如果这个bitrev模块的输入信号和输出信号是8位的, 那将是一个简单的数字电路作业;
> 不过bitrev模块是通过SPI总线来通信的, 因此你还需要实现串行/并行信号之间的转换
> (但这也不难, 我们的Chisel参考代码只需添加5行). 一些提示如下: -->
> If the input and output signals of the bitrev module are 8 bits, then it would be a simple digital circuit assignment. However, since the bitrev module communicates via the SPI bus, you also need to implement the conversion between serial and parallel signals. This task is not difficult; our Chisel reference code only requires adding about 5 lines. Here are some tips:
<!-- > 1. SPI master输出的`SS`信号是低电平有效的, 而且要求slave空闲时, 将`MISO`信号设置为高电平
> 1. 由于`SCK`只在SPI传输过程中产生脉冲, 你可能需要用到异步复位的功能,
>    不过这个bitrev模块并不参与流片, 在其中使用异步复位并不影响流片的流程
>    * 如果你使用Chisel, 你可以参考[Chisel文档中关于Reset的说明](https://www.chisel-lang.org/docs/explanations/reset)
> 1. 如果你使用Chisel, 并且希望使用时钟下降沿触发, 你可以参考[这个帖子](https://github.com/chipsalliance/chisel/issues/1131)
> 1. 你还需要取消`ysyxSoC/perip/spi/rtl/spi_top_apb.v`中定义的宏`FAST_FLASH`,
>    使得APB请求可以访问SPI master的设备寄存器
>
> 在硬件上实现bitrev模块后, 你还需要编写一个程序来测试它.
> 尝试编写一个AM程序, 通过驱动SPI master往bitrev模块中输入一个8位数据,
> 然后读出其处理后的结果, 检查结果是否符合预期. 具体地: -->
> 1. `SS` signal output by the SPI master is active at low level, and `MISO` signal is set to high level when the slave is idle.
> 1. Since `SCK` only generates pulses during SPI transmission, you may need to use the asynchronous reset function. However, this bitrev module does not participate in tape-out, and using asynchronous reset does not affect the tape-out process.
>     * If you use Chisel, you can refer to [the instructions on Reset in the Chisel documentation.](https://www.chisel-lang.org/docs/explanations/reset)
> 1. If you use Chisel and want to use clock falling edge triggering, you can refer to [this post](https://github.com/chipsalliance/chisel/issues/1131)
> 1. You also need to cancel the macro `FAST_FLASH` defined in `ysyxSoC/perip/spi/rtl/spi_top_apb.v` so that APB requests can access the device register of the SPI master.
>
> After implementing the bitrev module in hardware, you will also need to write a program to test it. Try writing an AM (Abstract Machine) program that drives the SPI master to input an 8-bit data into the bitrev module and then read out the processed result to check if it meets the expected outcome. Specifically:
> 
<!-- > 1. 将需要发送的数据设置到SPI master的TX寄存器中
> 1. 设置除数寄存器, 它用于指示SPI master传送时`SCK`频率与当前SPI master时钟频率的比例.
>    由于verilator中没有频率的概念, 因此可以设置一个使得`SCK`频率尽量高的除数.
>    * 在真实芯片中, `SCK`频率过高可能会导致slave无法正确工作,
>      因此除数寄存器的设置需要符合slave工作频率的要求
> 1. 设置`SS`寄存器, 选择revbit模块作为slave
>    * ysyxSoC已经将bitrev作为一个SPI slave与SPI master相连, 其slave编号为7
> 1. 设置控制寄存器, 具体地, 你需要设置好其中的每一个字段, 其中一些字段的说明如下:
>    * `CHAR_LEN` - 由于输入数据和输出数据的长度均为8位, 因此传输长度应为16位
>    * `Rx_NEG`, `Tx_NEG`和`LSB` - 由于bitrev只是一个测试模块, 并不参与最终的流片,
>      因此我们不规定bitrev模块的这些细节, 具体交给你来约定, 你需要在选择一种约定后,
>      按照这种约定来实现bitrev模块, 设置SPI的控制寄存器并编写软件,
>      使得三者可以按照相同的约定来进行通信
>    * `IE` - 目前我们不使用中断功能
>    * `ASS` - 是否设置均可, 但需要与软件协同考虑
> 1. 轮询控制寄存器中的完成标志, 直到SPI master完成数据传输
> 1. 从SPI master的RX寄存器中读出slave返回的数据 -->
> 1. Set the data to be sent to the TX register of the SPI master
> 1. Set the divisor register, which is used to indicate the ratio of `SCK` frequency to the current SPI master clock frequency when the SPI master transmits. Since there is no concept of frequency in verilator, you can set a divisor to make the `SCK` frequency as high as possible.
>     * In a real chip, if `SCK` frequency is too high, the slave may not work correctly, so the setting of the divisor register needs to meet the requirements of the slave operating frequency.
> 1. Set `SS` register and select the revbit module as slave
>     * ysyxSoC has connected bitrev as an SPI slave to the SPI master, and its slave number is 7
> 1. Set the control register. Specifically, you need to set each field in it. The description of some of the fields is as follows:
>     * `CHAR_LEN` - Since the input and output data are both 8 bits in length, the transfer length should be 16 bits
>     * `Rx_NEG` , `Tx_NEG` and `LSB` - Since bitrev is just a test module and does not participate in the final tape-out, we do not stipulate these details of the bitrev module and leave it to you to make an agreement. You need to choose a convention and follow this convention to implement the bitrev module, set the SPI control register and write software so that the three can communicate according to the same convention
>     * `IE` - Currently we don't use the interrupt function
>     * `ASS` - It can be set or not, but it needs to be considered in conjunction with the software
> 1. Poll the completion flag in the control register until the SPI master completes the data transfer
> 1. Read the data returned by slave from the RX register of SPI master
>
<!-- > 我们给出一次数据传输的示例, 注意这只是一个效果示意图, 你的实现不必与其完全相同: -->
> We give an example of a data transfer. Note that this is just a schematic diagram, and your implementation does not have to be exactly the same:
> ```
>                 +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+
>  SCK            |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
>         --------+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +------------
>         --------+                                                                                                                               +--------
>  SS             |                                                                                                                               |
>                 +-------------------------------------------------------------------------------------------------------------------------------+
>         +-------+-------+-------+-------+-------+-------+-------+-------+-------+------------------------------------------------------------------------
> MOSI            |   b7  |   b6  |   b5  |   b4  |   b3  |   b2  |   b1  |   b0  |
>                 +-------+-------+-------+-------+-------+-------+-------+-------+
>         +-----------------------------------------------------------------------+-------+-------+-------+-------+-------+-------+-------+-------+--------
> MISO                                                                            |   b0  |   b1  |   b2  |   b3  |   b4  |   b5  |   b6  |   b7  |
>                                                                                 +-------+-------+-------+-------+-------+-------+-------+-------+
> ```
>
<!-- > SPI传输过程的细节较多, 你很可能需要RTFM和RTFSC帮助你理解其中的细节. -->
> There are many details in the SPI transmission process, and you will most likely need RTFM and RTFSC to help you understand the details.

<!-- -->
<!-- > #### todo::通过SPI总线从flash中读出数据
> 尝试编写一个AM程序, 在其中实现一个原型为`uint32_t flash_read(uint32_t addr)`的函数,
> 注意这个`flash_read()`函数和上文中提到的同名的DPI-C接口函数不同.
> 此处的`flash_read()`函数通过驱动SPI master, 读出flash颗粒中起始地址为`addr`的32位内容.
> 这个过程和上文的bitrev例子类似:
> 1. 将需要发送给flash颗粒的命令设置到SPI master的TX寄存器中
> 1. 设置除数寄存器
> 1. 设置`SS`寄存器, 选择flash颗粒作为slave, 其slave编号为0
> 1. 设置控制寄存器:
>    * `CHAR_LEN` - 由于读命令的长度共32位, 且需要读出32位数据, 因此传输长度应为64位
>    * `Rx_NEG`和`Tx_NEG` - 需要根据slave的相关文档进行设置
>      * 在真实芯片中, `Rx_NEG`和`Tx_NEG`设置错误可能会导致电路工作时的保持时间(hold)违例,
>        从而无法采样到正确的数据. 不过在verilator中没有时序的概念,
>        因此某些不正确的设置可能也会得到正确的结果,
>        但我们还是建议你在RTFM后严格按照约定来设置
>    * `LSB` - 需要根据slave的相关文档进行设置, 在必要情况下, 读出的数据可通过软件调整其尾端
>    * `IE` - 目前我们不使用中断功能
>    * `ASS` - 是否设置均可, 但需要与软件协同考虑
> 1. 轮询控制寄存器中的完成标志, 直到SPI master完成数据传输
> 1. 从SPI master的RX寄存器中读出slave返回的数据
>
> 实现`flash_read()`后, 通过该函数从flash存储空间中读出内容,
> 并检查是否与仿真环境初始化时设置的内容一致. -->
> #### todo::Read data from flash through SPI bus
> To write an AM program that includes a function prototype `uint32_t flash_read(uint32_t addr)`, it's important to note that this `flash_read()` function differs from the DPI-C interface function of the same name mentioned earlier. The `flash_read()` function in this context reads the 32-bit content starting from the address `addr` in the flash chip by driving the SPI master. The process is similar to the bitrev example mentioned earlier, with the following steps:
> 1. Set the command that needs to be sent to the flash particle into the TX register of the SPI master
> 1. Set the divisor register
> 1. Set the `SS` register, select the flash particle as the slave, and its slave number is 0
> 1. Set control register:
>     * `CHAR_LEN` - Since the length of the read command is 32 bits and 32 bits of data need to be read, the transmission length should be 64 bits.
>     * `Rx_NEG` and `Tx_NEG` - need to be set according to the slave's relevant documents
>         * In real chip designs, incorrect settings of `Rx_NEG` and `Tx_NEG` can lead to violations of the hold time requirements during circuit operation, resulting in incorrect data sampling. However, Verilator does not simulate timing, so some incorrect settings might still produce correct results in simulation. Nevertheless, it is still recommended to strictly follow the conventions after RTFM to set these parameters correctly.
>     * `LSB` - needs to be set according to the relevant documentation of the slave. If necessary, the tail end of the read data can be adjusted through software
>     * `IE` - Currently we don't use the interrupt function
>     * `ASS` - It can be set or not, but it needs to be considered in conjunction with the software
> 1. Poll the completion flag in the control register until the SPI master completes the data transfer
> 1. Read the data returned by slave from the RX register of SPI master
> After implementing `flash_read()` , use this function to read the content from the flash storage space and check whether it is consistent with the content set when the simulation environment is initialized.

<!-- -->
<!-- > #### todo::从flash中加载程序并执行
> 尝试将上文提到的`char-test`程序存放到flash颗粒中,
> 编写测试程序, 通过`flash_read()`将`char-test`从flash读入到SRAM的某个地址中,
> 然后跳转到该地址执行`char-test`. -->
> #### todo::Load the program from flash and execute it
> Try to store `char-test` program mentioned above into the flash particle, write a test program, read `char-test` from flash to an address in SRAM through `flash_read()` , and then jump to the address to execute `char-test` .

<!-- ### 从flash中取指 -->
### Fetch instructions from flash

<!-- 可以从flash中正确读出数据后, 我们就可以考虑将需要执行的程序放到flash中,
让NPC从flash中取出第一条指令了. -->
After the data can be read correctly from the flash, we can consider putting the program that needs to be executed into the flash and let the NPC retrieve the first instruction from the flash.

<!-- 等等, 好像哪里不太对...
我们刚才是通过`flash_read()`这个函数从flash中读出内容,
这个函数也是程序的一部分, 它被编译成指令序列放在MROM中, NPC从MROM中取出指令并执行.
但如果将`flash_read()`的指令序列也一同烧录到flash中, 谁来取出`flash_read()`的指令并执行呢?
这变成了一个"鸡和蛋"的循环依赖问题. -->
Wait a minute, something seems off... We just used the function `flash_read()` to read content from flash, and this function is also part of the program. It is compiled into an instruction sequence and stored in MROM, with the NPC fetching and executing instructions from MROM. But if the instruction sequence for `flash_read()` is also programmed into the flash, who will fetch and execute the instructions for `flash_read()`? This turns into a "chicken and egg" circular dependency problem.

<!-- 再深入分析, 产生这个问题的根源是, 我们尝试通过软件函数来实现硬件上的取指操作,
这并不合理, 因为取指操作是一个硬件层次的行为.
因此, 我们应该尝试在硬件层次实现"从flash中取指"的功能, -->
Upon further analysis, the root of the problem is that we are attempting to implement instruction fetching, which is inherently a hardware-level behavior, through a software function. This approach is fundamentally flawed because instruction fetching is a hardware-level operation. Therefore, we should aim to implement the functionality of "fetching instructions from flash" at the hardware level.

<!-- 要在硬件层次实现`flash_read()`的功能, 也就是要按照一定的顺序在硬件上访问SPI master的寄存器.
你也许想到了, 那就是用状态机实现`flash_read()`的功能!
与上文从flash中加载程序并执行的方式不同,
这种从flash颗粒中取指的方式并不需要在执行程序之前将程序读入到内存(对应上文的SRAM)中,
因此也称"就地执行"(XIP, eXecute In Place)方式. -->
To implement the functionality of `flash_read()` at the hardware level means accessing the registers of the SPI master in a certain sequence on the hardware. As you may have thought, this can be achieved using a state machine to implement the `flash_read()` functionality! Unlike the method described earlier, where the program is loaded from flash and executed, this approach of fetching instructions directly from the flash chip does not require the program to be read into memory (corresponding to the SRAM mentioned earlier) before execution. Therefore, this method is also known as "execute in place" (XIP).

<!-- 为了区分正常访问SPI master的情况, 我们需要将通过XIP方式访问flash
的功能映射到与SPI master设备寄存器不同的地址空间.
事实上, 我们可以对之前访问的flash存储空间`0x3000_0000~0x3fff_ffff`稍作调整,
将其定义为通过XIP方式访问的flash存储空间.
ysyxSoC中的Xbar已经将SPI master的地址空间`0x1000_1000~0x1000_1fff`和
flash存储空间`0x3000_0000~0x3fff_ffff`都映射到
`ysyxSoC/perip/spi/rtl/spi_top_apb.v`模块中的APB端口,
也即, `spi_top_apb.v`模块中的APB端口能接收上述两段地址空间的请求,
你可以通过检查APB的目标地址区分它们. -->
To differentiate from the normal access to the SPI master, we need to map the functionality of accessing flash through XIP to a different address space from that of the SPI master device registers. In fact, we can slightly adjust the previously accessed flash storage space `0x3000_0000~0x3fff_ffff` and define it as the flash storage space accessed through XIP. In the ysyxSoC, the Xbar has already mapped both the address space of the SPI master `0x1000_1000~0x1000_1fff` and the flash storage space `0x3000_0000~0x3fff_ffff` to the APB port in the `ysyxSoC/perip/spi/rtl/spi_top_apb.v` module. That is, the APB port in the `spi_top_apb.v` module can receive requests from the aforementioned two address spaces, and you can distinguish them by checking the target address of the APB.

<!-- > #### todo::通过XIP方式访问flash
> 综上所述, 实现XIP方式的大致过程如下:
> 1. 检查APB请求的目标地址, 若目标地址落在SPI master的地址空间, 则正常访问并回复
> 1. 若目标地址落在flash存储空间, 则进入XIP模式.
>    在XIP模式中, SPI master的输入信号由相应状态机决定
>    * 状态机依次往SPI master的设备寄存器中写入相应的值, 写入的值与`flash_read()`基本一致
>    * 状态机轮询SPI master的完成标志, 等待SPI master完成数据传输
>    * 状态机从SPI master的RX寄存器中读出flash返回的数据, 处理后通过APB返回, 并退出XIP模式
>
> 具体地, 如果你选择Verilog, 你需要在`ysyxSoC/perip/spi/rtl/spi_top_apb.v`中实现相应代码;
> 如果你选择Chisel, 你需要在`ysyxSoC/soc/SPI.scala`的`Impl`类中实现相应代码.
>
> 在通过XIP方式取指之前, 我们先测试是否能通过XIP方式完成CPU发出的读请求.
> 编写测试程序, 直接通过指针从flash存储空间中读出内容
> 并检查是否与仿真环境初始化时设置的内容一致.
>
> 同样地, 目前我们不考虑通过XIP方式支持flash的写入操作,
> 因此你最好想个办法在检测到写操作时报告错误, 来帮助你及时诊断问题的原因. -->
> #### todo::Access flash through XIP
> To sum up, the general process of implementing the XIP method is as follows:
> 1. Check the target address of the APB request. If the target address falls in the address space of the SPI master, access and reply normally.
> 1. If the target address falls in the flash storage space, it enters XIP mode. In XIP mode, the input signal of the SPI master is determined by the corresponding state machine
>     * The state machine writes corresponding values ​​to the device register of the SPI master in turn. The written values ​​are basically the same as `flash_read()`
>     * The state machine polls the completion flag of the SPI master and waits for the SPI master to complete the data transmission.
>     * The state machine reads the data returned by flash from the RX register of the SPI master, returns it through APB after processing, and exits XIP mode
>
> Specifically, if you choose Verilog, you need to implement the corresponding code in `ysyxSoC/perip/spi/rtl/spi_top_apb.v` ; if you choose Chisel, you need to implement the corresponding code in `Impl` class of `ysyxSoC/soc/SPI.scala` .
>
> Before fetching instructions via XIP, it's crucial to test if the CPU can successfully complete read requests through XIP. You can write a test program that directly reads content from the flash storage space via a pointer and checks if it matches the content set during the initialization of the simulation environment. Here's a basic outline of steps to follow for writing such a test program:
>
> Similarly, we currently do not consider supporting flash write operations through XIP, so you'd better find a way to report an error when a write operation is detected to help you diagnose the cause of the problem in time.

<!-- -->
<!-- > #### todo::通过XIP方式执行flash中的程序
> 将上文提到的`char-test`程序存放到flash颗粒中,
> 编写测试程序, 跳转到flash中执行`char-test`. -->
> #### todo::Execute the program in flash through XIP
> Store `char-test` program mentioned above in the flash particle, write the test program, and jump to the flash to execute `char-test` .

<!-- -->
<!-- > #### todo::用flash替代MROM
> 确认可以从flash中取指执行后, 我们就可以用flash完全替代MROM来存放第一个程序了.
> 修改PC的复位值, 使NPC复位后从flash中取出第一条指令.
> 你还需要进行一系列修改来适配这一改动, 包括...
> 还是交给你来判断吧, 这也是测试你是否了解这个过程中的每一个细节.
>
> 因为flash的大小比之前使用的MROM大得多, 因此我们可以存放并执行更大的程序了,
> 尝试运行coremark等包含`printf()`的程序.
> 如果你运行microbench, 你会发现有不少子项会因为堆区大小不足而无法运行. -->
> #### todo::Use flash instead of MROM
> After confirming that instructions can be successfully fetched and executed directly from flash, it's feasible to entirely replace the MROM with flash for storing the first program. This involves modifying the reset value of the PC so that upon reset, the NPC fetches the first instruction from flash. Adapting to this change requires a series of modifications. Making these changes requires a thorough understanding of the system's architecture, including how the CPU interacts with memory and peripheral devices. It also tests your knowledge
>
> Because the size of flash is much larger than the MROM used previously, we are now able to store and execute larger programs, such as attempting to run programs that include `printf()` like coremark. If you run microbench, you will find that numerous sub-items fail to execute due to insufficient heap size.

<!-- -->
<!-- > #### question::coremark要跑好久啊
> 如果允许你动手, 你会如何减少coremark的运行时间呢?
>
> Hint: RTFSC -->
> #### question::coremark takes a long time to run
> If you were allowed to do it, how would you reduce coremark's running time?
>
> Hint: RTFSC

<!-- -->
<!-- > #### question::尝试在flash上执行flash_read()函数
> 你可能会发现错误, 请尝试分析为什么会出现这个错误. -->
> #### question::Try to execute flash_read() function on flash
> You may find an error, please try to analyze why this error occurs.

<!-- -->
<!-- > #### todo::添加学号CSR并输出学号
> 为了标识不同同学的NPC, 我们可以在CSR的标识寄存器中设置自己的学号.
> 具体地, 你可以在NPC中添加如下两个CSR:
> * `mvendorid` - 从中读出`ysyx`的ASCII码, 即`0x79737978`
> * `marchid` - 从中读出学号数字部分的十进制表示, 假设你的学号为`ysyx_22068888`,
>   则读出`22068888`, 即`0x150be98`
>
> 实现后, 可在`riscv32e-ysyxsoc`的TRM进入`main()`函数前读出上述两个CSR的值并输出. -->
> #### todo::Add student ID CSR and output student ID
> To identify different students' NPCs, we can set our own student ID in the CSR identification registers. Specifically, you can add the following two CSRs in the NPC:
> - `mvendorid` - Read the ASCII code of `ysyx` from it, which is `0x79737978`
> - `marchid` - Read out the decimal representation of the numeric part of the student number. Suppose your student number is `ysyx_22068888` , then read `22068888` , which is `0x150be98`
>
> After implementation, the values ​​of the above two CSRs can be read and output before the TRM of `riscv32e-ysyxsoc` enters `main()` function.

<!-- -->
<!-- > #### option::通过中断等待SPI master传输完成
> 我们刚才的XIP实现是通过轮询的方式不断查询SPI master的传输是否完成,
> 事实上, SPI master还支持中断通知模式, 设置控制寄存器的`IE`位后,
> SPI master在传输结束后将会发出中断信号,
> XIP模式的状态机可以通过等待这个中断信号来等待SPI master传输完成.
> 感兴趣的同学可以实现上述的中断查询方式.
>
> 尽管这不会带来显著的性能提升, 但在实际的系统中, 等待中断的实现可以节省能耗,
> 因为轮询方式发起的请求和回复并没有对系统的运行带来实际的贡献. -->
> #### option::wait for SPI master transfer to complete via interrupt
> Our recent implementation of XIP continuously polls to check if the SPI master's transmission is complete. In fact, the SPI master also supports an interrupt notification mode. After setting the `IE` bit in the control register, the SPI master will issue an interrupt signal once the transmission is finished. The state machine in XIP mode can wait for this interrupt signal to wait for the SPI master transmission to complete. Students interested in this can implement the above-mentioned interrupt querying method.
>
> Although this does not bring a significant performance improvement, in actual systems, waiting for interrupts can save energy because the requests and responses initiated by polling do not make a real contribution to the system's operation.

<!-- ## 存储密度更大的随机存储器

通过flash解决了MROM只能存放小程序的问题后, 我们还需要考虑数据的存放.
如果程序需要写入的数据过多, 超过SRAM能提供的8KB, 那这个程序还无法在ysyxSoC上运行.
为此, 我们需要一个更大的, 而且可以支持CPU执行store指令的存储器. -->
## Random access memory with higher storage density

After resolving the issue of MROM only being able to store small programs with flash, we also need to consider data storage. If a program needs to write an amount of data exceeding the 8KB provided by SRAM, then the program still cannot run on the ysyxSoC. Therefore, we need a larger storage that can also support the CPU executing store instructions.

### DRAM的存储单元

<!-- DRAM(Dynamic Random Access Memory)是一种目前广泛使用的存储器,
和SRAM相比, DRAM具有容量大, 成本低的特点.
DRAM的存储单元通过一根晶体管和一个电容来存储1 bit,
其中晶体管充当开关的作用, 功能上相当于读写使能;
电容用于存储1 bit的信息, 当电容的电量大于一定的阈值, 就认为是`1`, 否则就认为是`0`.
可见, DRAM通过电的特性来存储信息, 因此属于易失存储器,
断电后DRAM中存储的信息将全部丢失.
反过来说, 系统上电时, DRAM中也不存在任何有效的数据. -->
DRAM (Dynamic Random Access Memory) is a widely used type of memory, which, compared to SRAM, features larger capacity and lower cost. The storage cell of DRAM stores 1 bit of information using a transistor and a capacitor. The transistor acts as a switch, serving the function of read/write enable, while the capacitor is used to store the 1 bit of information. When the charge of the capacitor is above a certain threshold, it is considered a `1`; otherwise, it is considered a `0`. Thus, DRAM stores information based on the properties of electricity, making it a volatile memory; all information stored in DRAM is lost when power is removed. Conversely, when the system is powered on, there is no valid data in DRAM.

<!-- 不过, 电容具有漏电的特性, 如果不进行任何操作, 电容中的电量将不断下降,
`1`最终会变成`0`, 从而无法识别原来存储的数据是`1`还是`0`, 导致数据丢失.
为了避免这种情况, 必须对DRAM的存储单元定时进行刷新:
DRAM控制器读出每一个存储单元中存放的信息, 若为`1`, 则重新写入该存储单元.
写入操作将使存储单元的电容重新恢复到高电量的状态,
使得在接下来的一段时间内, 都可以从该存储单元中读出`1`, 从而保持信息的存储. -->
However, capacitors exhibit the characteristic of leakage. If left unattended, the charge within the capacitor will progressively diminish, ultimately reaching zero. This renders it impossible to discern whether the original stored data was a `1` or a `0`, leading to data loss. To circumvent this issue, it is essential to periodically refresh the storage cells in DRAM:
- The DRAM controller reads the information contained in each storage cell. If it is a `1`, then it rewrites this information into the same storage cell.
- The rewrite operation replenishes the capacitor in the storage cell to a high charge state, ensuring that a `1` can be read from the cell over the following period, thereby preserving the stored information.

<!-- 可以看到, 写入DRAM存储单元的本质是对电容的充电和放电,
因此, 虽然DRAM的写入操作不如SRAM的写入那么快, 但综合考虑成本和容量等因素,
DRAM的写入操作仍然适合用于支持CPU执行store指令. -->
As can be seen, writing to a DRAM storage cell fundamentally involves charging and discharging a capacitor. Therefore, although the write operations to DRAM are not as fast as those to SRAM, when considering factors such as cost and capacity, DRAM's write operations are still suitable for supporting CPU execution of store instructions.

<!-- 如果不考虑存储阵列的组织结构, 读写的物理过程, 从功能上来说,
DRAM颗粒和上文介绍的flash颗粒非常类似:
除了各种寄存器之外, 还能接收外部输入的命令进行操作. -->
If we disregard the organizational structure of the storage array and the physical process of reading and writing, functionally, DRAM chips are very similar to the flash chips described earlier: besides various registers, they can also receive external input commands to operate.

<!-- 与flash控制器类似, 向DRAM颗粒发送命令以驱动其工作的模块称为DRAM控制器.
DRAM控制器需要将来自总线的事务请求翻译成DRAM颗粒的操作命令,
通过存储器总线将这些信息传递给DRAM颗粒.
此外, DRAM控制器还需要定期向DRAM颗粒发送刷新命令.
不过这也增加了DRAM控制器的设计复杂度: DRAM控制器必须精确地计算需要刷新的时机,
过多的刷新操作会降低读写命令的执行效率, 而过少的刷新操作将会导致数据丢失. -->
Similar to a flash controller, the module that sends commands to DRAM chips to drive their operation is called a DRAM controller. The DRAM controller needs to translate transaction requests from the bus into operational commands for the DRAM chips, passing this information to the DRAM chips via the memory bus. Additionally, the DRAM controller must also periodically send refresh commands to the DRAM chips. However, this also increases the design complexity of the DRAM controller: it must precisely calculate the timing for refreshes. Too many refresh operations can reduce the efficiency of read and write command execution, while too few refresh operations can lead to data loss.

<!-- ### PSRAM颗粒 -->
### PSRAM particles

<!-- 有一类DRAM颗粒在内部集成了刷新的逻辑, 称为PSRAM(Pseudo Static Random Access Memory)颗粒.
PSRAM控制器无需实现刷新的功能, 也无需关心PSRAM颗粒的内部结构,
因此这种颗粒使用起来与SRAM很类似:
只需给出地址, 数据和读写命令, 就可以访问颗粒中的数据.
一个例子是型号为IS66WVS4M8ALL的PSRAM颗粒, 它能提供4MB的存储空间,
更多信息可参考[相关的手册][psram manual]. -->
There's a type of DRAM chip that integrates the logic for refresh internally, known as PSRAM (Pseudo Static Random Access Memory) chips. A PSRAM controller does not need to implement the refresh function, nor does it need to be concerned with the internal structure of PSRAM chips. Therefore, using these chips is very similar to using SRAM: one simply needs to provide the address, data, and read/write commands to access data within the chip. An example is the IS66WVS4M8ALL PSRAM chip, which provides 4MB of storage space. For more information, you can refer to [the relevant manuals][psram manual].

[psram manual]: https://www.issi.com/WW/pdf/66-67WVS4M8ALL-BLL.pdf

<!-- 有了PSRAM, 我们就可以尝试让ysyxSoC向程序提供更大的可写内存区间.
与通过SPI协议访问flash颗粒类似, PSRAM颗粒也提供了SPI接口.
不过, 和flash不同, PSRAM一般作为系统的内存, 因此有必要提供更高效的访问方式. -->
With PSRAM, we can attempt to provide a larger writable memory area for programs in the ysyxSoC. Similar to accessing flash chips via the SPI protocol, PSRAM chips also offer an SPI interface. However, unlike flash, PSRAM generally serves as the system's memory, necessitating a more efficient access method.

<!-- ### 通过SPI总线协议的升级版访问PSRAM颗粒 -->
### Access PSRAM particles through an upgraded version of the SPI bus protocol

<!-- 事实上, SPI协议存在一些升级版本, 可以提升master和slave间的通信效率.
基础的SPI协议是全双工的, 即master和slave可以同时分别通过`MOSI`和`MISO`发送消息.
但通常来说, master先向slave发送命令, slave在收到命令后才能处理,
然后才能把处理结果回复给master, 这个过程只需要半双工的信道即可满足. -->
In fact, there are some upgraded versions of the SPI protocol that can enhance the communication efficiency between the master and the slave. The basic SPI protocol is full-duplex, meaning that the master and the slave can simultaneously send messages through `MOSI` and `MISO` respectively. However, usually, the master sends a command to the slave first, and the slave can only process this after receiving the command, and then it can reply to the master with the result. This process only requires a half-duplex channel.

<!-- Dual SPI协议利用了这一点, 可以将基础SPI协议中的`MOSI`和`MISO`同时用于其中一个方向的传输,
也即, Dual SPI协议可以在一个`SCK`时钟内单向传输2 bit.
因为`MOSI`和`MISO`的含义发生了变化, 因此在Dual SPI协议中,
它们的名称分别改为`SIO0`(Serial I/O 0)和`SIO1`. -->
The Dual SPI protocol takes advantage of this, allowing the basic SPI protocol's `MOSI` and `MISO` to be used for transmission in one direction simultaneously, i.e., the Dual SPI protocol can transmit 2 bits in one direction within a single `SCK` clock cycle. Because the meanings of `MOSI` and `MISO` have changed, in the Dual SPI protocol, their names are changed to `SIO0` (Serial I/O 0) and `SIO1` respectively.

<!-- 为了与基础SPI协议的传输方式区别开来,
slave通常会提供不同的命令来让master选择通过何种协议进行传输.
例如, 上文提到的型号为W25Q128JV的flash颗粒提供多种读命令: -->
To distinguish from the transmission method of the basic SPI protocol, the slave usually offers different commands to allow the master to choose which protocol to use for transmission. For example, the flash chip model W25Q128JV mentioned above provides multiple read commands:
<!-- * 提供`03h`命令, 使用基础SPI协议进行读操作,
  其命令, 地址, 数据都按1 bit传输.
  通常把这三者的传输位宽用一个三元组`(命令传输位宽-地址传输位宽-数据传输位宽)`来表示,
  例如, 基础SPI协议也记为`(1-1-1)`.
  以读出32位数据为例, `03h`命令需要执行`8 + 24 + 32 = 64`个`SCK`时钟.
* 还提供`3Bh`命令, 使用Dual SPI协议进行读操作,
  其命令和地址按1 bit传输, 但数据按2 bit传输, 记为`(1-1-2)`.
  以读出32位数据为例, `3Bh`命令需要执行`8 + 24 + 32/2 = 48`个`SCK`时钟,
  不过无论数据按多少位进行传输, 从flash存储阵列上读出数据总是需要一定的延迟,
  因此`3Bh`命令在传输数据之前还需要额外等待8个`SCK`时钟,
  即`3Bh`命令需要执行`8 + 24 + 8(读延迟) + 32/2 = 56`个`SCK`时钟.
* 还提供`BBh`命令, 使用Dual SPI协议进行读操作,
  其命令按1 bit传输, 但地址和数据按2 bit传输, 记为`(1-2-2)`.
  以读出32位数据为例, `BBh`命令需要执行`8 + 24/2 + 4(读延迟) + 32/2 = 40`个`SCK`时钟. -->
* The `03h` command is provided for read operations using the basic SPI protocol, with the command, address, and data all transmitted at 1 bit per transfer. The transmission bit width of these three components is usually represented by a triplet `(command transmission bit width - address transmission bit width - data transmission bit width)`, for instance, the basic SPI protocol is also denoted as `(1-1-1)`. Taking the reading of 32 bits of data as an example, the `03h` command requires `8 + 24 + 32 = 64` `SCK` clock cycles to execute.
* The `3Bh` command is also provided, utilizing the Dual SPI protocol for read operations. Its command and address are transmitted in 1 bit, while the data is transmitted in 2 bits, denoted as `(1-1-2)`. Taking the example of reading 32 bits of data, the `3Bh` command requires `8 + 24 + 32/2 = 48` `SCK` clocks to execute. However, irrespective of the number of bits used for data transmission, there is always a certain delay in reading data from the flash memory array. Hence, before transmitting data, the `3Bh` command also needs to wait for an additional 8 `SCK` clocks, meaning that the `3Bh` command requires `8 + 24 + 8 (read delay) + 32/2 = 56` `SCK` clocks to execute.
* The `BBh` command is also provided, utilizing the Dual SPI protocol for read operations. Its command is transmitted in 1 bit, while the address and data are transmitted in 2 bits, denoted as `(1-2-2)`. Taking the example of reading 32 bits of data, the `BBh` command requires `8 + 24/2 + 4 (read delay) + 32/2 = 40` `SCK` clocks to execute.

<!-- 进一步地, 还有Quad SPI协议(简称QSPI), 通过添加`SIO2`和`SIO3`两位新信号,
可以在一个`SCK`时钟内单向传输4 bit.
例如, 上文提到的型号为W25Q128JV的flash颗粒还提供另外两种基于QSPI协议的读命令: -->
Furthermore, there is the Quad SPI protocol (abbreviated as QSPI), which introduces two additional signals, `SIO2` and `SIO3`, enabling the unidirectional transmission of 4 bits within a single `SCK` clock cycle. For example, the flash chip model W25Q128JV mentioned earlier also provides two additional read commands based on the QSPI protocol:

<!-- * 提供`6Bh`命令, 其命令和地址按1 bit传输, 但数据按4 bit传输, 记为`(1-1-4)`.
  以读出32位数据为例, `6Bh`命令需要执行`8 + 24 + 8(读延迟) + 32/4 = 48`个`SCK`时钟.
* 还提供`EBh`命令, 其命令按1 bit传输, 但地址和数据按4 bit传输, 记为`(1-4-4)`.
  以读出32位数据为例, `EBh`命令需要执行`8 + 24/4 + 6(读延迟) + 32/4 = 28`个`SCK`时钟. -->
* `6Bh` command is provided. The command and address are transmitted in 1 bit, but the data is transmitted in 4 bits, recorded as `(1-1-4)` . Taking reading 32-bit data as an example, the `6Bh` command needs to execute `8 + 24 + 8(read delay) + 32/4 = 48` `SCK` clocks.
* Also provided is the `EBh` command, where the command is transmitted in 1 bit, but the address and data are transmitted in 4 bits, denoted as `(1-4-4)`. Taking the example of reading 32 bits of data, the `EBh` command needs to execute `8 + 24/4 + 6 (read delay) + 32/4 = 28` `SCK` clocks.

<!-- 不过, 上面的读命令中, 无论地址和数据部分按多少位进行传输, 命令部分都是按1 bit传输.
这是因为slave在解析出命令之后, 才知道后续的地址和数据应该时候何种协议进行传输,
因此命令部分仍然按照基础SPI协议来逐位进行传输.
此外, 虽然上述型号的flash颗粒支持多种传输方式,
但与flash颗粒相连的SPI master只能以基础SPI协议进行传输, 因此无法发出其他读命令. -->
However, in the above read command, regardless of how many bits the address and data parts are transmitted in, the command part is always transmitted in 1 bit. This is because the slave, after decoding the command, determines the subsequent address and data transmission protocols. Therefore, the command part still follows the basic SPI protocol for bit-by-bit transmission. Additionally, although the flash chips of the mentioned model support multiple transmission modes, the SPI master connected to the flash chips can only transmit using the basic SPI protocol, thus unable to issue other read commands.

<!-- ysyxSoC集成了PSRAM控制器的实现, 并将PSRAM存储空间映射到CPU的地址空间`0x8000_0000~0x9fff_ffff`.
PSRAM控制器的代码位于`ysyxSoC/perip/psram/efabless/`目录下,
采用wishbone总线协议, 我们已经将其封装成APB总线协议
(见`ysyxSoC/perip/psram/psram_top_apb.v`), 并将其接入到ysyxSoC的APB Xbar中.
PSRAM控制器会将接收到的总线事务翻译成发往PSRAM颗粒的命令.
我们选择模拟型号为IS66WVS4M8ALL的PSRAM颗粒, 它支持QSPI协议,
因此ysyxSoC集成的PSRAM控制器可以通过QSPI协议与PSRAM颗粒进行通信,
从而可以使用更高效的命令访问PSRAM.
ysyxSoC已经将PSRAM颗粒与PSRAM控制器相连, 但未提供PSRAM颗粒相关的代码,
为了在ysyxSoC中使用PSRAM, 你还需要实现PSRAM颗粒的仿真行为模型. -->
The ysyxSoC integrates an implementation of a PSRAM controller and maps the PSRAM storage space to the CPU's address space `0x8000_0000~0x9fff_ffff`. The code for the PSRAM controller is located in the directory `ysyxSoC/perip/psram/efabless/`, which uses the Wishbone bus protocol. We have encapsulated it into the APB bus protocol (see `ysyxSoC/perip/psram/psram_top_apb.v`) and connected it to the APB Xbar of ysyxSoC. The PSRAM controller translates received bus transactions into commands sent to the PSRAM chip. We have chosen the IS66WVS4M8ALL PSRAM chip for simulation, which supports the QSPI protocol. Therefore, the PSRAM controller integrated into ysyxSoC can communicate with the PSRAM chip using the QSPI protocol, allowing more efficient access to the PSRAM through commands. The ysyxSoC has already connected the PSRAM chip to the PSRAM controller but has not provided code related to the PSRAM chip. To use the PSRAM in ysyxSoC, you will need to implement a behavioral model for the PSRAM chip.

<!-- > #### todo::实现PSRAM颗粒的仿真行为模型 -->
> #### todo::Implement the simulation behavior model of PSRAM particles
<!-- > 你需要实现IS66WVS4M8ALL颗粒的仿真行为模型.
> 你只需要实现SPI Mode的`Qual IO Read`和`Quad IO Write`两种命令即可,
> 它们的命令编码分别为`EBh`和`38h`, PSRAM控制器也只会向PSRAM颗粒发送这两种命令. -->
> You need to implement a behavioral model for the IS66WVS4M8ALL chip. You only need to implement two commands in SPI mode: `Quad IO Read` and `Quad IO Write`. Their command encodings are `EBh` and `38h` respectively. The PSRAM controller will only send these two commands to the PSRAM chip.
>
<!-- > 具体地, 如果你选择Verilog, 你需要在`ysyxSoC/perip/psram/psram.v`中实现相应代码;
> 如果你选择Chisel, 你需要在`ysyxSoC/soc/PSRAM.scala`的`psramChisel`模块中实现相应代码,
> 并将`ysyxSoC/soc/SoC.scala`中的`Module(new psram)`修改为实例化`psramChisel`模块. -->
> Specifically, if you choose Verilog, you need to implement the corresponding code in `ysyxSoC/perip/psram/psram.v`. If you choose Chisel, you need to implement the corresponding code in the `psramChisel` module in `ysyxSoC/soc/PSRAM.scala`, and modify `Module(new psram)` in `ysyxSoC/soc/SoC.scala` to instantiate the `psramChisel` module.
>
<!-- > 一些说明如下: -->
> Some instructions are as follows:
<!-- > 1. 端口`ce_n`的含义与SPI总线协议中的`SS`相同, 低电平有效
> 1. 端口`dio`声明为`inout`类型, 再配合一个用于输出使能信号, 可实现三态逻辑,
>    在同一时刻可用于输入或输出, 用于实现信号的半双工传输
>    * 在ASIC流程中, 需要显式实例化标准单元库中的三态逻辑单元,
>      不过此处我们仅在仿真环境中测试, 因此无需调用标准单元库
>    * 如果你使用Verilog, 可参考`ysyxSoC/perip/psram/psram_top_apb.v`中`qspi_dio`的相关代码
>    * 如果你使用Chisel, 由于目前Chisel还不支持`Analog`类型除连接外的其他操作,
>      因此我们已经在框架代码中实例化了一个`TriStateBuf`子模块,
>      它可以将`dio`分解成`din`和`dout`两个方向的`UInt`信号供后续使用
> 1. 存储阵列只需要实现成一个字长为8 bit的二维数组,
>    无需关心其物理组织结构, 重点关注QSPI协议的实现即可.
>    此外, 因为PSRAM不是非易失存储器, 无需在仿真环境初始化时设置其内容,
>    因此可直接在Verilog代码中定义存储阵列,
>    亦可通过DPI-C访问在C++代码中定义的数组, 从而方便被mtrace追踪
> 1. 手册中还有一个QPI Mode, 其含义与上文提到的QSPI不同, 目前可忽略
> 1. 关于尾端和时钟相位等细节, 可RTFM参考相关手册, 或RTFSC参考PSRAM控制器的代码
>    * 为了正确实现PSRAM控制器和PSRAM颗粒的通信, 你无需修改PSRAM控制器的代码 -->
> 1. The meaning of port `ce_n` is the same as `SS` in the SPI bus protocol, low level is active
> 1. The port `dio` is declared as an `inout` type, and coupled with an output enable signal, it can realize three-state logic. It can be used for input or output at the same time to achieve half-duplex transmission of signals.
>     * In the ASIC process, it is necessary to explicitly instantiate the three-state logic unit in the standard unit library, but here we are only testing in the simulation environment, so there is no need to call the standard unit library
>     * If you use Verilog, you can refer to the relevant code of `qspi_dio` in `ysyxSoC/perip/psram/psram_top_apb.v`
>     * If you use Chisel, since Chisel currently does not support other operations of `Analog` type except connection, we have instantiated a `TriStateBuf` submodule in the framework code, which can decompose `dio` into `UInt` signals in both directions of `din` and `dout` for subsequent use
> 1. The storage array only needs to be implemented as a two-dimensional array with a word length of 8 bits. There's no need to concern yourself with its physical organization; the focus should be on implementing the QSPI protocol. Additionally, since PSRAM is not non-volatile memory, there's no need to initialize its contents in the simulation environment. Therefore, you can directly define the storage array in Verilog code or access an array defined in C++ code through DPI-C, making it easier to trace with mtrace.
> 1. There is also a QPI Mode in the manual, which has a different meaning from the QSPI mentioned above and can be ignored for now.
> 1. For details such as tail end and clock phase, please refer to the relevant manual for RTFM, or refer to the PSRAM controller code for RTFSC.
>     * In order to correctly implement communication between the PSRAM controller and PSRAM particles, you do not need to modify the code of the PSRAM controller
> 
<!-- > 实现后, 通过`mem-test`测试一小段PSRAM的访问(如4KB), 检查你的实现是否正确.
> 注意到目前flash已经提供了更大的存储空间来存放程序,
> 因此你可以在`mem-test`中调用`printf()`来帮助你输出调试信息,
> 尤其是可以输出一些和测试进度相关的信息, 从而得知测试是否正常进行中. -->
> After implementation, test a small segment of PSRAM access (such as 4KB) using `mem-test` to check if your implementation is correct. Note that the flash already provides a larger storage space for storing programs. Therefore, you can use `printf()` in `mem-test` to help you output debugging information, especially information related to the progress of the test, to ensure that the test is proceeding normally.

<!-- 事实上, 在QSPI之上还有一种称为QPI的协议, 它还能进一步提升命令部分的传输效率,
即命令, 地址和数据都按4 bit传输, 记为`(4-4-4)`.
不过为了兼容旧的SPI master, slave上电时一般处于基础SPI模式, 此时通过基础SPI协议通信.
如果slave支持QPI协议, 它将提供一个切换到QPI模式的命令,
master可以发送该命令将slave切换到QPI模式, 然后使用QPI协议与其通信. -->
In fact, there is a protocol called QPI on top of QSPI, which can further enhance the efficiency of the command transfer. In QPI protocol, commands, addresses, and data are all transmitted in 4-bit chunks, denoted as `(4-4-4)`. However, to maintain compatibility with old SPI masters, slaves typically start in basic SPI mode when powered on, communicating via the basic SPI protocol at that time. If the slave supports the QPI protocol, it will provide a command to switch to QPI mode. The master can send this command to switch the slave to QPI mode and then communicate with it using the QPI protocol.

<!-- > #### todo::使用QPI协议访问PSRAM颗粒
> 尝试为PSRAM颗粒添加QPI模式以及进入QPI模式的命令, 然后修改PSRAM控制器的代码,
> 使其复位后先通过电路逻辑向PSRAM颗粒发送进入QPI模式的命令,
> 后续则使用QPI模式与PSRAM颗粒进行通信.
>
> 注意这个功能的添加对上层软件是透明的,
> 上层软件无需进行任何改动, 就能提升访问PSRAM的效率. -->
> #### todo::Use QPI protocol to access PSRAM particles
> Try adding QPI mode support to the PSRAM chips and defining the command to enter QPI mode. Then, modify the code of the PSRAM controller so that after resetting, it first sends the command to enter QPI mode to the PSRAM chips via circuit logic. Subsequently, communication with the PSRAM chips should be done in QPI mode.
>
> Note that the addition of this function is transparent to the upper-layer software. The upper-layer software does not need to make any changes to improve the efficiency of accessing PSRAM.

<!-- ### 运行更大的程序

有了PSRAM的支持, 我们就可以尝试把数据段分配在PSRAM, 从而支持运行更大的程序. -->
### 运行更大的程序

With the support of PSRAM, we can try to allocate data segments in PSRAM to support running larger programs.

<!-- > #### todo::在ysyxSoC上运行microbench
> 之前我们把数据段和堆区分配在8KB的SRAM中, 而运行microbench所需要的内存大于8KB,
> 因此有不少子项无法运行. 将数据段和堆区分配在4MB的PSRAM后,
> 你应该可以看到microbench可以成功运行test规模的所有测试. -->
> #### todo::Run microbench on ysyxSoC
> Previously, we allocated the data segment and heap in an 8KB SRAM, but the memory required to run the microbenchmark exceeds 8KB, causing many subtests to be unable to run. By allocating the data segment and heap in a 4MB PSRAM instead, you should be able to see the successful execution of all test cases in the microbenchmark at test scale.

<!-- 我们刚才运行microbench只是从流程上说明把数据段分配在PSRAM并无大碍,
但在运行更多程序之前, 我们最好先通过`mem-test`对4MB的PSRAM进行完整的测试.
不过, 如果要在仿真环境中通过`mem-test`完整测试这4MB存储空间的读写, 则需要花费很长的时间. -->
We just ran microbench to demonstrate the allocation of data segments in PSRAM has no major issues in the process. However, before running more programs, it is better to perform a comprehensive test on the 4MB PSRAM using `mem-test`. Nevertheless, testing the read and write of this 4MB memory space completely through `mem-test` in a simulated environment would take a long time.

<!-- 这是因为目前我们在flash上执行`mem-test`:
从flash中取出一条指令, 至少需要花费64个`SCK`时钟周期;
而SPI master又是通过分频的方式生成`SCK`时钟信号, 即使采用效率最高的二分频,
光是SPI传输过程, 就要花费至少128个CPU时钟周期;
再加上XIP状态机的控制开销, 从flash中取出一条指令, 前后需要花费大约150个CPU时钟周期. -->
This is because currently we are running `mem-test` in flash: fetching an instruction from flash requires at least 64 `SCK` clock cycles; and the SPI master generates `SCK` clock signal through division, even with the most efficient halving, just the SPI transfer process takes at least 128 CPU clock cycles; adding the overhead of the XIP state machine control, fetching an instruction from flash would require approximately 150 CPU clock cycles in total.

<!-- 由于循环和函数调用的存在, 程序中的大部分代码都要重复执行.
相比于让程序一直在flash中执行,
提前花一些时间将代码加载到一个访问效率比flash更高的存储器中,
然后让程序在后者中重复执行, 反而能有效提升程序的执行效率.
不过这个加载过程需要读出程序的指令, 然后将其写入到目标存储器中,
因此需要一个支持写操作的存储器.
目前PSRAM仍在测试中, 考虑到`mem-test`并不是很大,
我们可以尝试将`mem-test`加载到上文提到的8KB的SRAM中. -->
Due to the existence of loops and function calls, most of the code in the program needs to be repeatedly executed. Instead of running the program continuously in flash, spending some time upfront to load the code into a storage with higher access efficiency than flash, and then executing the program repetitively in the latter, can effectively improve the program's execution efficiency. However, this loading process requires reading the program instructions and then writing them into the target storage, hence necessitating a storage that supports write operations. Currently, PSRAM is still under testing, considering `mem-test` is not very large, we can attempt to load `mem-test` into the 8KB SRAM mentioned above.

<!-- 谁来进行这个加载操作呢? 我们肯定要在`mem-test`执行之前完成加载,
但又希望保持"NPC复位后从flash中取指"的特性, 不让仿真环境干涉太多,
从而使得这个加载操作也可以在真实的芯片中进行.
因此, 我们只好在NPC复位之后, 且`mem-test`真正执行之前, 利用这段间隙来进行加载,
不难想到, 那就是bootloader! 也即, 我们需要扩展bootloader的功能,
将程序的代码和数据全部加载到SRAM中, 然后跳转到SRAM执行. -->
Who will perform this loading operation? We certainly need to complete the loading before executing `mem-test`, but we also want to maintain the feature of "fetching instructions from flash after NPC reset", minimizing interference in the simulation environment and enabling this loading operation to be carried out on the actual chip. Therefore, we have no choice but to utilize the gap after NPC reset and before the actual execution of `mem-test` for loading, and it is not difficult to realize that this can be achieved through the bootloader! In other words, we need to extend the functionality of the bootloader to load all of the program's code and data into SRAM, and then jump to execute from SRAM.

<!-- > #### todo::完整测试PSRAM的访问
> 扩展bootloader的功能, 把`mem-test`完全加载到SRAM, 然后再执行`mem-test`.
> 一些提示如下:
> 1. 你还需要将只读数据段一同加载到SRAM,
>    它可能会包含一些代码执行中所需要的数据, 例如跳转表等
> 1. 如果你发现`mem-test`的代码过多, 无法在SRAM中放下,
>    可以尝试使用编译选项`-Os`来指示gcc以代码大小为目标进行优化
> 1. 代码加载的实现还需要处理若干你目前能理解的细节,
>    如果你忽略了它们, 那就在调试中学习吧, 毕竟将来的真实项目也是这样
>
> 之后, 让`mem-test`测试PSRAM的所有4MB存储空间,
> 你会发现`mem-test`的运行效率提高了不少, 可花费约10分钟完成测试.

SRAM的访问速度虽然快, 但其容量并不大, 无法存放大部分程序.
完整测试PSRAM的访问后, 我们也可以考虑让bootload将程序完全加载到PSRAM中,
从而提升程序执行的效率. -->
> #### todo::Completely test PSRAM access
> Expand the function of bootloader, completely load `mem-test` into SRAM, and then execute `mem-test` . Some tips are as follows:
>
> 1. You also need to load the read-only data segment into SRAM, which may contain some data required for code execution, such as jump tables, etc.
> 1. If you find that `mem-test` has too much code to fit in SRAM, you can try using the compile option `-Os` to instruct gcc to optimize based on code size.
> 1. The implementation of code loading also needs to deal with some details that you can understand now. If you ignore them, then learn it during debugging. After all, the same will be true for real projects in the future.
>
> After that, let `mem-test` test all 4MB storage space of PSRAM. You will find that the running efficiency of `mem-test` has improved a lot, and it can take about 10 minutes to complete the test.

Although SRAM has fast access speed, its capacity is limited and cannot store most programs. After completing the full test of PSRAM access, we can also consider having the bootloader load the program entirely into PSRAM to enhance the program execution efficiency.

<!-- > #### todo::通过bootloader将程序加载到PSRAM中执行
> 你已经通过bootloader将`mem-test`加载到SRAM中了, 因此要将程序加载到PSRAM中并不难.
> 不过为了充分利用SRAM, 我们可以把栈分配在SRAM中, 来提升函数调用和访问局部变量的效率.
>
> 尝试执行microbench的test规模, 你会发现和在flash中执行相比,
> 将其加载到PSRAM后执行, 可以得到可观的性能提升. -->
> #### todo::Load the program into PSRAM through bootloader for execution
>
> Since you have already loaded `mem-test` into SRAM through the bootloader, loading the program into PSRAM should not be difficult. However, to fully utilize SRAM, allocating the stack in SRAM can enhance the efficiency of function calls and accessing local variables.
>
> When attempting to run the microbench test, you will notice a significant performance improvement by loading it into PSRAM and executing it compared to running it in flash.

<!-- -->
<!-- > #### todo::在PSRAM上执行RT-Thread
> 目前PSRAM的容量已经足够运行RT-Thread了.
> 尝试通过bootloader将RT-Thread加载到PSRAM中执行.

如果程序较大, 那么bootloader加载程序的过程也会较长, 因为bootloader本身是在flash中执行的.
同样地, 我们能否将"bootloader加载程序"的代码先加载到访问效率更高的存储器中,
然后再执行"bootloader加载程序"的功能呢? 这其实是bootloader的多级加载过程.
为了方便区分, 我们可以将整个bootloader的工作拆分成
FSBL(first stage bootloader)和SSBL(second stage bootloader)两部分.
系统上电时, FSBL, SSBL和需要运行的程序都位于flash中;
首先执行的是FSBL, 它负责将SSBL从flash加载到其他存储器, 然后跳转到SSBL执行;
然后SSBL负责将接下来需要运行的程序从flash加载到PSRAM中, 然后跳转到程序并执行.
事实上, SSBL的代码并不大, 因此我们可以让FSBL将SSBL加载到SRAM中执行, 从而让SSBL执行得更快. -->
> #### todo::Execute RT-Thread on PSRAM
> The current capacity of PSRAM is enough to run RT-Thread. Try to load RT-Thread into PSRAM through bootloader for execution.

If the program is large, the process of the bootloader loading the program will also take longer because the bootloader itself runs in flash. Similarly, can we load the code for "bootloader loading program" into a storage with higher access efficiency first, and then execute the functionality of "bootloader loading program"? This is essentially a multi-stage loading process of the bootloader. For ease of distinction, we can divide the entire bootloader's work into two parts: FSBL (First Stage Bootloader) and SSBL (Second Stage Bootloader). Upon system power-up, FSBL, SSBL, and the program to be run are all located in flash; FSBL is the first to execute, responsible for loading SSBL from flash to other storage, and then jumping to execute SSBL; SSBL is responsible for loading the subsequent program to run from flash into PSRAM, and then jumping to the program and executing it. In fact, the code for SSBL is not large, so we can have FSBL load SSBL into SRAM for faster execution.

<!-- > #### todo::实现bootloader的二级加载过程
> 按照上述功能实现FSBL和SSBL.
> 为了得知SSBL在flash中的范围, 你可能需要将SSBL单独放在一个节中,
> 具体可以参考`start.S`中的相关代码.
>
> 此外, 因为bootloader把加载工作分成多个阶段,
> 你还需要额外考虑目标对象在当前阶段中是否可访问. -->
> #### todo:: implements the secondary loading process of bootloader
> Implement FSBL and SSBL according to the above functions. In order to know the scope of SSBL in flash, you may need to put SSBL in a separate section. For details, please refer to the relevant code in `start.S` .
>
> In addition, because the bootloader divides the loading work into multiple stages, you need to additionally consider whether the target object is accessible in the current stage.

<!-- ### SDRAM颗粒的内部结构

如果想要进一步提升访问DRAM颗粒的效率,
就要考虑将控制器和颗粒之间的串行总线改成并行总线了.
例如, 型号为[MT48LC16M16A2][MT48LC16M16A2 manual]的DRAM颗粒内部结构如下图所示.
该颗粒的引脚有39位, 分别包括: -->
### Internal structure of SDRAM particles

If you want to further enhance the efficiency of accessing DRAM chips, you should consider changing the serial bus between the controller and the chips to a parallel bus. For example, the internal structure of a DRAM chip with the model [MT48LC16M16A2][MT48LC16M16A2 manual] is illustrated in the diagram below. This chip has 39 pins, which include:

[MT48LC16M16A2 manual]: https://www.micron.com/-/media/client/global/documents/products/data-sheet/dram/256mb_sdr.pdf

<!-- * `CLK`, `CKE` - 时钟信号和时钟使能信号
* `CS#`, `WE#`, `CAS#`, `#RAS` - 命令信号
* `BA[1:0]` - 存储体地址
* `A[12:0]` - 地址
* `DQ[15:0]` - 数据
* `DQM[1:0]` - 数据掩码, 下图中的命名采用`DQML`和`DQMH` -->
* `CLK` , `CKE` - clock signal and clock enable signal
* `CS#` , `WE#` , `CAS#` , `#RAS` - Command signals
* `BA[1:0]` - memory bank address
* `A[12:0]` - address
* `DQ[15:0]` - data
* `DQM[1:0]` - data mask, the naming in the figure below uses `DQML` and `DQMH`
 
![image](https://ysyx.oscc.cc/slides/2205/resources/img/18-sdram.jpg)

<!-- 与SPI协议中采用分频输出的`SCK`不同, 这里的时钟信号`CLK`通常由DRAM控制器的时钟直接驱动,
这类DRAM称为同步DRAM, 即SDRAM(Synchronous Dynamic Random Access Memory).
SDRAM颗粒已经成为当前主流的内存颗粒, 最早商用的SDRAM颗粒于1992年发售,
属于SDR SDRAM(Single Date Rate SDRAM), 表示一个时钟传输一次数据,
上图展示的型号为MT48LC16M16A2的颗粒, 就属于SDR SDRAM颗粒;
1997年开始出现了DDR SDRAM(Double Data Rate SDRAM),
它可以分别在时钟的上升沿和下降沿传输数据, 因此提升了数据传输带宽;
此后依次出现了DDR2, DDR3, DDR4, DDR5, 它们均通过不同技术进一步提升数据传输带宽.
与同步DRAM相对, 还有异步DRAM(Asynchronous DRAM), 它的总线信号中没有时钟.
目前异步DRAM基本上被SDRAM替代, 因此今天讨论DRAM时, 几乎都指代SDRAM. -->
Different from the frequency-divided `SCK` used in the SPI protocol, the clock signal `CLK` here is usually directly driven by the clock of the DRAM controller. Such type of DRAM is called Synchronous DRAM, known as SDRAM (Synchronous Dynamic Random Access Memory). SDRAM chips have become the mainstream memory chips currently. The earliest commercially available SDRAM chips were introduced in 1992, belonging to SDR SDRAM (Single Data Rate SDRAM), where one data transfer occurs per clock cycle. The chip model shown in the diagram, MT48LC16M16A2, is an example of an SDR SDRAM chip. DDR SDRAM (Double Data Rate SDRAM) emerged in 1997, which can transfer data on both the rising and falling edges of the clock signal, thereby improving data transfer bandwidth. Subsequently, DDR2, DDR3, DDR4, and DDR5 were introduced, each enhancing data transfer bandwidth through different technologies. In contrast to Synchronous DRAM, there is also Asynchronous DRAM (Asynchronous DRAM), which does not have a clock signal in its bus. Currently, Asynchronous DRAM is mostly replaced by SDRAM, so when discussing DRAM today, it almost exclusively refers to SDRAM.

<!-- 和PSRAM颗粒的SPI总线接口不同, 传统DRAM颗粒的引脚中包含了存储体地址等信息,
这要求DRAM控制器了解DRAM颗粒中存储阵列的内部组织结构,
才能知道应该给地址相关的引脚传递什么信息. -->
Unlike the SPI bus interface of PSRAM chips, the pins of traditional DRAM chips contain information such as memory cell addresses. This requirement necessitates that the DRAM controller understands the internal organization structure of the memory array in the DRAM chip to know what information to pass to the pins related to addresses.

<!-- DRAM颗粒的存储阵列是一个多维结构, 从逻辑上看由若干个矩阵组成,
一个矩阵又称一个存储体(memory bank).
存储体中的一个矩阵元素是若干个存储单元,
每个存储单元包含一根晶体管和一个电容, 用于存储1 bit信息.
需要通过行地址(row address)和列地址(column address)共同指定存储体中的一个矩阵元素.
例如, 上述DRAM颗粒中有4个存储体, 每个存储体中有8192行, 每行有512列,
存储体中的一个矩阵元素有16个存储单元,
因此该DRAM颗粒的容量为`4 * 8192 * 512 * 16 = 256Mb = 32MB`. -->
The memory array of a DRAM chip is a multi-dimensional structure, logically composed of several matrices, where each matrix is also known as a memory bank. Each matrix in a memory bank consists of several memory cells, with each cell containing a transistor and a capacitor used to store 1 bit of information. To specify a matrix element in a memory bank, both a row address and a column address are required. For example, in the aforementioned DRAM chip, there are 4 memory banks, each with 8192 rows and 512 columns. Each matrix element in a memory bank contains 16 memory cells. Therefore, the capacity of this DRAM chip is calculated as `4 * 8192 * 512 * 16 = 256Mb = 32MB`.``

<!-- 读出时, 先根据存储体编号选择一个目标存储体.
然后通过行地址激活(active)目标存储体中的一行:
目标存储体中的读出放大器(sence amplifier)会检测这一行所有存储单元中的电量,
从而得知每个存储单元存放的是`1`还是`0`.
一个读出放大器主要由一对交叉配对反相器构成, 因此可以存储信息,
故存储体中的读出放大器也称行缓冲(row buffer), 可以存储一行信息.
之后, 再根据列地址从目标存储体的行缓冲中各选出数据,
作为读出的结果输出到DRAM颗粒芯片的外部.
写入时, 先将需要写入的数据写到行缓冲中的相应位置,
然后对相应存储单元中的电容进行充电或放电操作,
从而将行缓冲中的内容转移到存储单元中.
如果要访问另一行的数据, 在激活另一行之前,
还需要先将已激活的当前行的信息写回存储单元,
这个过程称为预充电(precharge). -->
During a read operation, a target memory bank is first selected based on the bank number. Subsequently, a row address is used to activate a row in the target memory bank: the sense amplifier in the target memory bank detects the charge levels in all memory cells of that row, determining whether each cell stores a `1` or `0`. A sense amplifier is typically composed of a pair of cross-coupled inverters, allowing it to store information; thus, the sense amplifier in the memory bank is also known as a row buffer, capable of storing a row of information. Following this, data is selected from the row buffer of the target memory bank based on the column address and is output as the read result from the DRAM chip to the external interface.<br><br>During a write operation, the data to be written is first stored in the appropriate location in the row buffer. Subsequently, the capacitors in the corresponding memory cells are charged or discharged to transfer the contents of the row buffer to the memory cells. If access to data from another row is required, before activating the new row, the information from the currently activated row needs to be written back to the memory cells, a process known as precharging.

<!-- > #### comment::DRAM颗粒的物理实现
> 考虑到物理实现的限制, 走线过长会引入较大延迟.
> 因此从物理实现的角度来看, DRAM颗粒的一个存储体还会进一步划分成多个子阵列(subarray).
> 不过这些子阵列的结构和访问方式对颗粒外部是透明的,
> DRAM控制器向DRAM颗粒发送命令时无需关心.
> 感兴趣的同学可以阅读[这篇文章][mutlu paper]进一步了解DRAM颗粒内部的物理结构. -->
> #### comment::Physical implementation of DRAM particles
> Considering the limitations of physical implementation, long interconnections can introduce significant delays. Therefore, from a physical implementation perspective, a memory bank in a DRAM chip is further divided into multiple subarrays. However, the structure and access methods of these subarrays are transparent to the external interface of the chip; the DRAM controller does not need to be concerned with them when sending commands to the DRAM chip. Students interested in this topic can read [this article][mutlu paper] to further understand the physical structure inside a DRAM chip.

[mutlu paper]: https://arxiv.org/pdf/1905.09822.pdf

<!-- 理解了DRAM颗粒的内部组织结构后, 我们就可以来梳理DRAM颗粒的命令了.
不同版本的SDRAM命令稍有不同, 下表列出了SDR SDRAM的命令: -->
After understanding the internal organization of DRAM chips, we can then proceed to outline the commands for DRAM chips. The commands for different versions of SDRAM vary slightly. The table below lists the commands for SDR SDRAM:

<!-- | CS# | RAS# | CAS# | WE# | 命令名称        | 命令含义                       |
|:---:|:----:|:----:|:---:| --------------- | ------------------------------ |
|  1  |   X  |   X  |  X  | COMMAND INHIBIT | 无命令                         |
|  0  |   1  |   1  |  1  | NO OPERATION    | NOP                            |
|  0  |   0  |   1  |  1  | ACTIVE          | 激活目标存储体的一行           |
|  0  |   1  |   0  |  1  | READ            | 读出目标存储体的一列           |
|  0  |   1  |   0  |  0  | WRITE           | 写入目标存储体的一列           |
|  0  |   1  |   1  |  0  | BURST TERMINATE | 停止当前的突发传输             |
|  0  |   0  |   1  |  0  | PRECHARGE       | 关闭存储体中已激活的行(预充电) |
|  0  |   0  |   0  |  1  | AUTO REFRESH    | 刷新                           |
|  0  |   0  |   0  |  0  | LOAD MODE REGISTER | 设置Mode寄存器              | -->
CS# | RAS# | CAS# | WE# | Command | Meaning
:-: | :-: | :-: | :-: | --- | ---
1 | X | X | X | COMMAND INHIBIT | Nothing
0 | 1 | 1 | 1 | NO OPERATION | NOP
0 | 0 | 1 | 1 | ACTIVE | Activate a row in the target memory bank
0 | 1 | 0 | 1 | READ | Read a column from the target memory bank
0 | 1 | 0 | 0 | WRITE | Write a column in the target memory bank
0 | 1 | 1 | 0 | BURST TERMINATE | Stop the current burst transfer
0 | 0 | 1 | 0 | PRECHARGE | Close the activated row in the memory bank (precharge)
0 | 0 | 0 | 1 | AUTO REFRESH | refresh
0 | 0 | 0 | 0 | LOAD MODE REGISTER | Set Mode register

<!-- 上述命令涉及"突发传输"(burst transfer)的概念,
它指在一次事务(transaction)中包含多次连续的数据传输, 一次数据传输称为一个"节拍"(beat).
以读取为例, 从DRAM颗粒接收到READ命令, 到读出存储阵列中的数据并传送到`DQ`总线上,
一般需要花费若干周期, 这个延迟称为CAS latency(有的教材翻译成CAS潜伏期).
以上文的MT48LC16M16A2型号为例, 根据工作频率的不同, CAS latency可为1~3周期,
即从收到READ命令, 到读出16 bit数据到`DQ`总线上, 有1~3周期的延迟.
假设CAS latency为2周期, 如果不采用突发传输, 读出8字节需要12周期;
如果采用突发传输, 则只需要6周期. -->
The above commands involve the concept of "burst transfer," which refers to including multiple consecutive data transfers in a single transaction, with each data transfer being called a "beat." Taking reading as an example, when a READ command is received from the DRAM chip, it usually takes several cycles to read the data from the storage array and transmit it to `DQ` bus. This delay is known as CAS latency (some textbooks translate it as CAS latent period).<br><br>Using the example of the MT48LC16M16A2 model mentioned earlier, depending on the operating frequency, the CAS latency can range from 1 to 3 cycles. This means that from receiving the READ command to reading out 16 bit data to `DQ` bus, there is a delay of 1 to 3 cycles.<br><br>Assuming a CAS latency of 2 cycles, if burst transfer is not used, reading out 8 bytes would require 12 cycles; whereas with burst transfer, it would only need 6 cycles.

```txt
// normal
  1   1   1   1   1   1   1   1   1   1   1   1
|---|---|---|---|---|---|---|---|---|---|---|---|
  ^       |   ^       |   ^       |   ^       |
  |       v   |       v   |       v   |       v
 READ   data READ   data READ   data READ   data

// burst
  1   1   1   1   1   1
|---|---|---|---|---|---|
  ^       |   |   |   |
  |       v   v   v   v
 READ    1st 2nd 3rd 4th
```

<!-- WRITE命令也支持突发传输, 也即, 若要写入8字节,
可以在发出WRITE命令后紧接着的3个周期内连续传输需要写入的数据.
至于一次突发传输的事务包含多少个节拍, 可以通过Mode寄存器来设置.
Mode寄存器还可以设置CAS latency等参数. -->
The WRITE command also supports burst transfer, meaning that to write 8 bytes, the data to be written can be continuously transmitted within the following 3 cycles after issuing the WRITE command. As for how many beats are included in a burst transfer transaction, this can be set through the Mode register. The Mode register can also set parameters such as CAS latency.

<!-- ysyxSoC集成了SDR SDRAM控制器(下文简称SDRAM控制器)的实现,
并将SDRAM存储空间映射到CPU的地址空间`0xa000_0000~0xbfff_ffff`.
SDRAM控制器的代码位于`ysyxSoC/perip/sdram/core_sdram_axi4/`目录下, 它采用AXI4总线协议.
为了方便初期的测试, 我们将其核心部分`ysyxSoC/perip/sdram/core_sdram_axi4/sdram_axi4_core.v`
封装成APB总线协议(见`ysyxSoC/perip/sdram/sdram_top_apb.v`), 并将其接入到ysyxSoC的APB Xbar中.
SDRAM控制器会将接收到的总线事务翻译成发往SDRAM颗粒的命令,
我们选择模拟型号为MT48LC16M16A2的SDRAM颗粒.
ysyxSoC已经将SDRAM颗粒与SDRAM控制器相连, 但未提供SDRAM颗粒相关的代码,
为了在ysyxSoC中使用SDRAM, 你还需要实现SDRAM颗粒的仿真行为模型. -->
ysyxSoC integrates the implementation of an SDR SDRAM controller (referred to as the SDRAM controller below) and maps the SDRAM storage space to the CPU's address space `0xa000_0000~0xbfff_ffff`. The code for the SDRAM controller is located in the directory `ysyxSoC/perip/sdram/core_sdram_axi4/`, and it uses the AXI4 bus protocol. For ease of initial testing, we encapsulate its core part `ysyxSoC/perip/sdram/core_sdram_axi4/sdram_axi4_core.v` into the APB bus protocol (see `ysyxSoC/perip/sdram/sdram_top_apb.v`), and connect it to the APB Xbar of ysyxSoC. <br><br>The SDRAM controller translates received bus transactions into commands sent to the SDRAM chip. We have chosen to simulate the model for the SDRAM chip as the MT48LC16M16A2. While the ysyxSoC has connected the SDRAM chip to the SDRAM controller, it does not provide the code related to the SDRAM chip. Therefore, to use SDRAM in ysyxSoC, you will also need to implement a simulation behavior model for the SDRAM chip.

<!-- > #### danger::bug修复
> 我们修复了在特定情况下SDRAM控制器读请求回复错误的问题.
> 如果你在2024/02/04 18:00:00之前获取`ysyxSoC`的代码, 请获取新版代码:
> ```bash
> cd ysyxSoC
> git pull origin ysyx6
> ``` -->
> #### danger::bug fix
>
> We fixed an issue where the SDRAM controller read request reply was incorrect under certain circumstances. If you obtained the code for `ysyxSoC` before 2024/02/04 18:00:00, please obtain the new version of the code:
>
> ```bash
> cd ysyxSoC
> git pull origin ysyx6
> ```

<!-- -->
<!-- > #### todo::实现SDRAM颗粒的仿真行为模型
> 你需要实现MT48LC16M16A2颗粒的仿真行为模型.
> 具体地, 你需要实现SDRAM控制器会发送的命令,
> 其中PRECHARGE和AUTO REFRESH命令与存储单元的电气特性相关,
> 在仿真环境中不必考虑, 因此可以将其实现成NOP.
> 此外, Mode寄存器只需奥实现CAS Latency和Burst Length, 其他字段可忽略.
>
> 具体地, 如果你选择Verilog, 你需要在`ysyxSoC/perip/sdram/sdram.v`中实现相应代码;
> 如果你选择Chisel, 你需要在`ysyxSoC/soc/SDRAM.scala`的`sdramChisel`模块中实现相应代码,
> 并将`ysyxSoC/soc/SoC.scala`中的`Module(new sdram)`修改为实例化`sdramChisel`模块.
>
> 其他细节请RTFM参考相关手册, 或RTFSC参考SDRAM控制器的代码.
> 为了正确实现SDRAM控制器和SDRAM颗粒的通信, 你无需修改SDRAM控制器的代码
>
> 实现后, 通过`mem-test`测试一小段SDRAM的访问(如4KB), 检查你的实现是否正确. -->
> #### todo::Implement the simulation behavior model of SDRAM particles
> You need to implement a simulation behavior model for the MT48LC16M16A2 chip. Specifically, you need to implement the commands that the SDRAM controller will send. The PRECHARGE and AUTO REFRESH commands are related to the electrical characteristics of the memory cells and do not need to be considered in the simulation environment, so they can be implemented as NOP (no operation). Additionally, the Mode register only needs to implement CAS Latency and Burst Length; other fields can be ignored.
>
> Specifically, if you choose Verilog, you need to implement the corresponding code in `ysyxSoC/perip/sdram/sdram.v` ; if you choose Chisel, you need to implement the corresponding code in the `sdramChisel` module of `ysyxSoC/soc/SDRAM.scala` , and `Module(new sdram)` in `ysyxSoC/soc/SoC.scala` is modified to instantiate the `sdramChisel` module.
>
> For other details, please refer to the relevant manual for RTFM, or refer to the code of the SDRAM controller for RTFSC. In order to correctly implement the communication between the SDRAM controller and the SDRAM particles, you do not need to modify the code of the SDRAM controller.
>
> After implementation, test access to a small section of SDRAM (such as 4KB) through `mem-test` to check whether your implementation is correct.

<!-- -->
<!-- > #### todo::完整测试SDRAM的访问
> 在进一步将程序加载到SDRAM中执行之前,
> 我们还是先通过`mem-test`测试对上述SDRAM颗粒所有存储空间的访问.
> 完成这个测试需要花费约1小时. -->
> #### todo::Completely test SDRAM access
> Before further loading the program into SDRAM for execution, we first test access to all storage spaces of the above SDRAM particles through `mem-test` . It takes about 1 hour to complete this test.

<!-- -->
<!-- > #### todo::将程序加载到SDRAM中执行
> 让bootloader将程序加载到SDRAM中并执行.
> 在这之后, 尝试在SDRAM上执行microbench和RT-Thread. -->
> #### todo::Load the program into SDRAM for execution
> Let the bootloader load the program into SDRAM and execute it. After this, try to execute microbench and RT-Thread on SDRAM.

<!-- ### SDRAM颗粒的扩展 -->
### Extension of SDRAM particles

<!-- 上文提到, MT48LC16M16A2型号的SDR SDRAM颗粒的容量为32MB.
但如今的内存条动辄就4GB, 这是如何做到的呢?
即使如今主流的内存条采用更先进的工艺, 单个内存颗粒的容量有所提升,
但也并非仅靠一个内存颗粒就能达到4GB.
事实上, 这是通过多个内存颗粒在一定维度上进行组合扩展来实现的.
如果你观察过内存条的结构, 你会发现一根内存条上有多个内存颗粒,
而内存条就是一块特殊的PCB板: 它以标准的尺寸规格集成多个内存颗粒,
并且采用DIMM接口, 使其可以插入主板的内存槽中. -->
As mentioned earlier, the capacity of the SDR SDRAM chip model MT48LC16M16A2 is 32MB. However, modern memory modules often have capacities of 4GB or more. How is this achieved? Even though contemporary memory modules use more advanced technologies and individual memory chips have higher capacities, it is not solely based on a single memory chip to reach 4GB. In reality, this is accomplished through combining and expanding multiple memory chips in certain dimensions.<br><br>If you have observed the structure of a memory module, you will notice that there are multiple memory chips on one module. The memory module itself is a specialized PCB: it integrates multiple memory chips within standard size specifications and uses a DIMM interface, allowing it to be inserted into the memory slots on a motherboard.

<!-- 我们知道, 如果不考物理组织结构, 存储器就是一个二维矩阵, 每行存储一个字, 行号即地址.
从这个角度看, 多个颗粒的扩展无非就是两个维度的扩展:
一个维度是让一个地址存储更多位的信息, 称位扩展;
另一个维度是增加地址的范围, 称字扩展. -->
We know that, if we disregard the physical organization, memory can be viewed as a two-dimensional matrix where each row stores a word, and the row number represents the address. From this perspective, the extension of multiple chips essentially involves extending in two dimensions: one dimension is to store more bits of information at a single address, known as bit extension; the other dimension is to increase the range of addresses, known as word extension.

<!-- 位扩展的思想是, 不同颗粒同时从相同的地址中读出数据,
这不仅提升了存储器的容量, 而且还提升了访存带宽.
如果颗粒的字长(即`DQ`信号的位宽)小于总线的数据位宽, 位扩展能够明显提升数据传输的效率.
例如, 对于64位的CPU, 总线的数据位宽通常不低于64位,
用4个字长是16位的MT48LC16M16A2颗粒, 可以在一个CAS latency之后就读出64位, 效率比突发传输还高: -->
The concept of bit extension involves multiple chips simultaneously reading data from the same address. This not only increases the capacity of the memory but also enhances the memory bandwidth. If the word length of the chip (the width of the `DQ` signal) is smaller than the data width of the bus, bit extension can significantly improve the efficiency of data transfer. For example, for a 64-bit CPU with a bus data width typically not less than 64 bits, using four chips with a word length of 16 bits like the MT48LC16M16A2 chip, it can read out 64 bits after one CAS latency, achieving higher efficiency than burst transfer:

```txt
  1   1   1
|---|---|---|
  ^       |
  |       v
 READ   data[15:0]  (chip0)

  1   1   1
|---|---|---|
  ^       |
  |       v
 READ   data[31:16] (chip1)

  1   1   1
|---|---|---|
  ^       |
  |       v
 READ   data[47:32] (chip2)

  1   1   1
|---|---|---|
  ^       |
  |       v
 READ   data[63:48] (chip3)
```

<!-- 另一个例子是型号为[MTA9ASF51272PZ][MTA9ASF51272PZ manual]的DDR4 SDRAM内存条,
内存条上的颗粒字长是8位, 但通过8个颗粒进行位扩展, 一次可以读写64位. -->
Another example is the DDR4 SDRAM memory model [MTA9ASF51272PZ][MTA9ASF51272PZ manual]. The particle word length on the memory stick is 8 bits, but it is bit extended through 8 particles, and 64 bits can be read and written at a time.

[MTA9ASF51272PZ manual]: https://www.micron.com/-/media/client/global/documents/products/data-sheet/modules/parity_rdimm/asf9c512x72pz.pdf

<!-- > #### todo::将SDRAM控制器的数据位宽扩展到32位
> 实例化2个SDRAM颗粒的子模块, 模拟对2个SDRAM颗粒进行位扩展的场景.
> 为此, 你需要修改以下内容:
> * SDRAM总线接口中部分信号的位宽
>   * 如果你使用Chisel, 你可以直接修改`SDRAMIO`的定义
>   * 如果你使用Verilog, 你需要修改`ysyxSoC/generated/ysyxSoCFull.v`中的相应信号位宽
> * SDRAM控制器的内部实现
>
> 实现位扩展后, 就不需要通过突发传输模式来访问SDRAM颗粒的,
> 经过一个CAS latency后, 就可以从扩展后的颗粒中读出32位数据.
> 尝试运行一些benchmark, 对比位扩展前后的性能变化. -->
> #### todo::Extend the data bit width of the SDRAM controller to 32 bits
> Instantiate the submodule of 2 SDRAM particles to simulate the scenario of bit expansion of 2 SDRAM particles. To do this, you need to modify the following:
>
> * Bit width of some signals in SDRAM bus interface
>     * If you use Chisel, you can directly modify the definition of `SDRAMIO`
>     * If you use Verilog, you need to modify the corresponding signal bit width in `ysyxSoC/generated/ysyxSoCFull.v`
> * Internal implementation of SDRAM controller
>
> After implementing bit extension, there is no need to access the SDRAM chips through burst transfer mode. After one CAS latency, it is possible to read out 32 bits of data from the extended chips. You can try running some benchmarks to compare the performance changes before and after bit extension.

<!-- 不过, 这些性能提升的得来并不是免费的, 位扩展要求`DQ`的引脚数量线性增长,
对于一些关注成本的芯片来说, 就需要精打细算了. 另外, 即使不关注成本,
位扩展带来的性能提升也会受限于系统中的其他因素, 例如总线的数据位宽:
如果总线的一次传输最多只有64位, 那么即使将内存颗粒的字长扩展到512位,
整体上也不会带来可观的收益, 就像水管的流量受限于最窄的片段一样. -->
However, these performance improvements from bit extension are not free. Bit extension requires a linear increase in the number of `DQ` pins, which may require careful consideration for cost-conscious chip designs. Additionally, even if cost is not a concern, the performance gains from bit extension can be limited by other factors in the system, such as the data width of the bus. If the maximum data transfer on the bus is limited to 64 bits, then even extending the word length of the memory chips to 512 bits will not yield significant benefits overall, similar to how the flow of water through a pipe is restricted by its narrowest segment.

<!-- 另一个维度是字扩展, 其思想是将不同的地址分布到不同的颗粒上, 从而提升访存容量.
例如, 我们可以使用2个32MB的MT48LC16M16A2颗粒, 通过字扩展形成容量为64MB的内存.
上述字扩展只需要在存储器总线上添加1位地址,
引脚数量的增长与存储容量呈log关系, 和位扩展相比开销并不大.
但从直觉上看, 字扩展不能直接提升访存带宽, 我们会在后面章节中继续讨论这个问题. -->
Another dimension is word extension, where the idea is to distribute different addresses across different chips to increase memory capacity. For example, we can use two 32MB MT48LC16M16A2 chips to form a 64MB memory capacity through word extension. This type of word extension only requires adding 1 address bit on the memory bus, and the increase in pin count is logarithmically related to the storage capacity, resulting in relatively small overhead compared to bit extension. However, intuitively, word extension does not directly increase memory bandwidth, and we will continue discussing this issue in later chapters.

<!-- > #### todo::对SDRAM控制器进行字扩展
> 实例化总计4个SDRAM颗粒的子模块, 其中两对SDRAM颗粒之间进行位扩展,
> 再对位扩展之后的结果进行字扩展. 你还需要修改SDRAM总线接口和控制器的内部实现.
>
> 实现后, 通过`mem-test`测试扩展后的所有存储空间.
> 完成这个测试需要花费数小时. -->
> #### todo::Word expansion for SDRAM controller
> Instantiate a submodule consisting of a total of 4 SDRAM chips, where bit extension is applied between two pairs of SDRAM chips, followed by word extension on the results of the bit extension. You will also need to modify the SDRAM bus interface and the internal implementation of the controller accordingly.
>
> After implementation, test all expanded storage spaces through `mem-test` . It takes several hours to complete this test.

<!-- ## 接入更多外设

上面的工作全部都是围绕TRM开展的, 最后我们来看看如何支持IOE. -->
## Access more peripherals

All the above work is carried out around TRM. Finally, let's take a look at how to support IOE.

<!-- ### GPIO -->
### GPIO

<!-- 首先我们来添加GPIO的支持.
GPIO算是最简单的外设了, 其本质就是一根连接芯片内外的导线, 显然它需要占用芯片的引脚.
通过GPIO, 芯片可以将内部的信号直接输出到芯片外部,
用来驱动一些简单的设备, 例如板卡上的LED灯;
芯片也可以通过GPIO获取外部的一些简单状态, 如板卡上的拨码开关, 按钮等状态. -->
First, let's add support for GPIO. GPIO is one of the simplest peripherals, essentially being a wire that connects the inside and outside of the chip, requiring pins on the chip. Through GPIO, the chip can directly output internal signals to the outside world, used to drive simple devices like LEDs on a board; the chip can also use GPIO to read simple external states such as DIP switches or button statuses on the board.

<!-- 显然, CPU上运行的软件无法直接访问一个芯片引脚,
同样需要GPIO控制器来为GPIO的功能提供设备寄存器的抽象.
不过对GPIO控制器来说, 这些设备寄存器的功能非常简单,
只需要用电路上的寄存器来存放相应引脚的状态即可.
具体地, 对于输出引脚, 其状态由寄存器中存放的某一位直接驱动;
而对于输入引脚, 它决定了寄存器中某一位的状态. -->
Clearly, software running on the CPU cannot directly access a chip's pin; therefore, a GPIO controller is needed to provide an abstraction of device registers for GPIO functionality. However, for a GPIO controller, the functions of these device registers are simple, requiring circuit registers to store the status of the respective pins. Specifically, for output pins, their status is directly driven by a specific bit stored in the register; while for input pins, they determine the status of a specific bit in the register.

<!-- ysyxSoC集成了一个APB总线接口的GPIO控制器, 并将其映射到CPU的地址空间`0x1000_2000~0x1000_200f`.
我们只给GPIO控制器分配了16字节的地址空间, 最多支持128个引脚, 通常来说已经足够使用了.
为了看到GPIO的效果, 我们将重新接入预学习阶段中你曾经接触过的NVBoard项目.
考虑到NVBoard中提供的外设, 适合GPIO使用的包括16个LED灯, 16个拨码开关, 以及8个7段数码管.
因此, 我们对GPIO控制器的寄存器空间作如下分配: -->
ysyxSoC integrates a GPIO controller with an APB bus interface, and maps it to the CPU's address space `0x1000_2000~0x1000_200f`. We have allocated a 16-byte address space for the GPIO controller, supporting up to 128 pins, which is typically sufficient for most use cases. To observe the effects of GPIO, we will reconnect it with the NVBoard project you previously encountered in the pre-learning phase. Considering the peripherals provided by NVBoard, suitable for GPIO usage include 16 LEDs, 16 DIP switches, and 8 7-segment displays. Therefore, we allocate the register space of the GPIO controller as follows:

<!-- | 地址  | 作用                                 |
| ---   | ---                                  |
| `0x0` | 16位数据, 分别驱动16个LED灯          |
| `0x4` | 16位数据, 分别获得16个拨码开关的状态 |
| `0x8` | 32位数据, 其中每4位驱动1个7段数码管  |
| `0xc` | 保留                                 | -->
Address | Usage
--- | ---
`0x0` | 16-bit data, driving 16 LED lights respectively
`0x4` | 16-bit data, respectively obtain the status of 16 DIP switches
`0x8` | 32-bit data, of which every 4 bits drive a 7-segment digital tube
`0xc` | reserved

<!-- 不过ysyxSoC没有提供GPIO控制器内部的具体实现, 我们将它作为作业留给大家. -->
However, ysyxSoC does not provide the specific implementation inside the GPIO controller, we leave it as homework for everyone.

<!-- > #### danger::更新NVBoard
> 我们在2024/01/11 01:00:00将NVBoard更新到1.0版本,
> 不仅增加了UART功能, 还大幅提升了处理性能.
> 后续的部分实验内容将要求大家使用NVBoard功能,
> 如果你在上述时间之前获得NVBoard的代码, 你可以通过以下命令获取新版本:
> ```bash
> cd nvboard
> git pull origin master
> ```
> 为了运行新版本的NVBoard, 你可能需要先清除一些旧的编译结果. -->
> #### danger::Update NVBoard
>
> We updated NVBoard to version 1.0 on 2024/01/11 01:00:00, which not only added UART functionality but also significantly improved processing performance. Some upcoming experiments will require the use of NVBoard features. If you obtained the NVBoard code before the mentioned time, you can get the new version using the following command:
>
> ```bash
> cd nvboard
> git pull origin master
> ```
>
> In order to run the new version of NVBoard, you may need to clear some old compilation results first.

<!-- -->
<!-- > #### todo::通过程序实现NVBoard上的流水灯效果
> 你需要进行以下工作:
> 1. 在GPIO控制器中实现用于驱动LED灯的寄存器.
>    具体地, 如果你选择Verilog, 你需要在`ysyxSoC/perip/gpio/gpio_top_apb.v`中实现相应代码;
>    如果你选择Chisel, 你需要在`ysyxSoC/soc/GPIO.scala`的`gpioChisel`模块中实现相应代码,
>    并将`ysyxSoC/soc/GPIO.scala`中的`Module(new gpio_top_apb)`修改为实例化`gpioChisel`模块.
> 1. 接入NVBoard, 将顶层模块`ysyxSoCFull`中的GPIO输出引脚绑定到LED灯
> 1. 编写测试程序, 隔一段时间往上述寄存器写入数据, 从而实现流水灯的效果
>
> 和预学习阶段不同, 这时的流水灯不再是由硬件电路直接控制,
> 而是由软件控制, 而且你已经了解其中的所有细节了. -->
> #### todo::Achieve the flow LED effect on NVBoard through program
> You need to do the following:
>
> 1. Implement the register used to drive LED lights in the GPIO controller. Specifically, if you choose Verilog, you need to implement the corresponding code in `ysyxSoC/perip/gpio/gpio_top_apb.v` ; if you choose Chisel, you need to implement the corresponding code in `ysyxSoC/soc/GPIO.scala` Implement the corresponding code in the `gpioChisel` module of `ysyxSoC/soc/GPIO.scala` , and modify `Module(new gpio_top_apb)` in `ysyxSoC/soc/GPIO.scala` to instantiate <code>gpioChisel</code> module.
> 1. Connect to NVBoard and bind the GPIO output pin in the top-level module `ysyxSoCFull` to the LED light
> 1. Write a test program and write data to the above registers at intervals to achieve the effect of running lights.
>
> Different from the pre-learning stage, the running lights at this time are no longer directly controlled by hardware circuits, but by software, and you already understand all the details.

<!-- -->
<!-- > #### todo::通过程序读入拨码开关的状态
> 与LED灯类似, 让程序读出读出拨码开关的状态.
> 你可以在程序中设置一个16位二进制的密码,
> 程序一开始启动时将不断查询拨码开关的状态,
> 只有当拨码开关的状态与上述密码一致, 程序才继续执行. -->
<!-- > #### todo::Read the status of the DIP switch through the program
> Similar to LED lights, have the program read the status of DIP switches. You can set a 16-bit binary password in the program. At the start of the program, continuously query the status of the DIP switches. Only when the status of the DIP switches matches the above password should the program continue execution. -->
> #### todo::Display the student number on the 7-segment digital tube through the program
> Read the student number in the student number CSR and convert it into 8 hexadecimal numbers, which are used to drive 8 7-segment digital tubes respectively.

<!-- -->
> #### todo::通过程序在7段数码管上展示学号
> 在学号CSR中读出学号, 并将其转化成8个十六进制数, 分别用于驱动8个7段数码管.

<!-- ### UART

我们之前已经通过UART16550控制器的帮助下测试了串口的输出功能,
但之前串口的发送端仅仅是通过UART16550控制器代码中的`$write`系统任务来输出,
并没有涉及将字符进行编码并通过线缆串行传输到接收端的过程.
NVBoard集成了一个串口终端, 有了NVBoard, 我们就可以来体会这个过程了!

NVBoard中的串口终端很简单, 它只支持`8N1`的串口传输配置.
至于波特率, 因为NVBoard中没有时钟频率的概念, 因此采用除数的方式来描述,
也即, 传输数据时一个比特需要维持多少个周期.
NVBoard中的这个除数不支持运行时配置, 但可以通过修改代码来调整.
你可以在`nvboard/src/uart.cpp`的UART构造函数中进行修改, 具体有两种方式:
1. 修改`divisor`成员的初值
1. 调用`set_divisor()`函数来设置 -->
### UART

We have previously tested the serial output function with the help of the UART16550 controller. However, the previous serial transmitter only outputted through the system task `$write` in the UART16550 controller code, without involving the process of encoding characters and transmitting them serially through cables to the receiver. The NVBoard integrates a serial terminal, with NVBoard, we can experience this process now!

The serial terminal in NVBoard is very simple, it only supports the `8N1` serial transmission configuration. As for the baud rate, because there is no concept of clock frequency in NVBoard, it is described using a divisor, meaning the number of cycles needed to maintain one bit during data transmission. The divisor in NVBoard does not support runtime configuration, but it can be adjusted by modifying the code. You can make modifications in the UART constructor function in `nvboard/src/uart.cpp` in two specific ways:

1. Modify the initial value of `divisor` member
2. Call `set_divisor()` function to set

<!-- > #### todo::将串口的TX引脚接入NVBoard
> 你只需要修改NVBoard约束文件, 即可将串口的TX引脚绑定到NVBoard的串口终端上.
> 关于如何绑定, 你可以参考NVBoard提供的示例.
> 由于串口控制器已经接入ysyxSoC了, 你无需再修改RTL代码.
>
> 成功绑定引脚后, 根据实际情况配置NVBoard中UART的除数.
> 注意NVBoard中UART的除数和UART16550中除数寄存器中的除数不完全相同,
> 它们之间存在一定的关系, 你需要通过RTFSC或者RTFM梳理清楚.
>
> 然后, 重新运行任意带串口输出的测试程序,
> 你将看到串口输出的内容不仅出现在命令行终端中,
> 还会出现在NVBoard右上角的串口终端中. -->
> #### todo::Connect the TX pin of the serial port to the NVBoard
> You only need to modify the NVBoard constraint file to bind the TX pin of the serial port to the serial terminal on NVBoard. As for how to bind it, you can refer to the examples provided by NVBoard. Since the serial controller has already been integrated into the ysyxSoC, you do not need to modify the RTL code anymore.
>
> Once you have successfully bound the pins, you will need to configure the divisor for the UART in NVBoard according to the actual situation. It is important to note that the divisor used in NVBoard's UART may not be directly equivalent to the divisor register in a UART16550. There is a specific relationship between them that you will need to understand through reading the fine source code (RTFSC) or the fine manual (RTFM). Take the time to carefully analyze and understand this relationship to configure the UART divisor correctly on NVBoard.
>
> Then, re-run any test program with serial output. You will see that the content of the serial output not only appears in the command line terminal but also in the serial terminal located in the top right corner of NVBoard.

<!-- NVBoard还支持串口的输入功能, 接入NVBoard之后, 就可以来测试之前不方便测试的串口输入功能了.
绑定引脚的工作并不难, 但我们还需要考虑上层的软件如何使用.
具体地, 你还需要在`riscv32e-ysyxsoc`的IOE中添加抽象寄存器`UART_RX`的功能:
从串口设备中读出一个字符, 若无字符, 则返回`0xff`. -->
NVBoard also supports serial input functionality. After connecting to NVBoard, you can test the serial input functionality that was previously difficult to test. Binding the pins is not difficult, but we also need to consider how the upper-layer software will use it. Specifically, you need to add the functionality of the abstract register `UART_RX` in the `riscv32e-ysyxsoc`'s IOE: read a character from the serial device, and if there is no character, return `0xff`.

<!-- > #### danger::bug修复
> 我们修复了`am-tests`的按键测试中和实现定义相关的问题.
> 如果你在2024/01/11 00:00:00之前获取`am-kernels`的代码, 请获取新版代码:
> ```bash
> cd am-kernels
> git pull origin master
> ``` -->
> #### danger::bug fix
>
> We have fixed issues related to implementation definitions in the keystroke test of `am-tests` . If you obtained the code of `am-kernels` before 2024/01/11 00:00:00, please obtain the new version of the code:
>
> ```bash
> cd am-kernels
> git pull origin master
> ```

<!-- -->
<!-- > #### todo::通过NVBoard测试串口的输入功能
> 绑定串口的RX引脚并在IOE中添加上述抽象寄存器后, 运行`am-tests`中的按键测试,
> 测试其能否通过UART的RX端口获得按键信息.
>
> 关于如何在NVBoard中通过UART的RX端口进行输入, 你可以参考NVBoard提供的示例.
> 此外, 你可能还需要在IOE中实现一些功能, 具体可以RTFSC.

在IOE中添加UART RX的相关功能之后, 我们就可以来尝试通过串口在RT-Thread中键入命令了. -->
> #### todo::Test the input function of the serial port through NVBoard
> After binding the RX pin of the serial port and adding the above abstract register in the IOE, run the key test in `am-tests` to test whether it can obtain the key information through the RX port of the UART.
>
> Regarding how to input through the UART RX port in NVBoard, you can refer to the examples provided by NVBoard. Additionally, you may need to implement some functions in the IOE, you can refer to the source code for more details.

After adding UART RX related functions to IOE, we can try to type commands in RT-Thread through the serial port.

<!-- > #### danger::bug修复
> 我们修复了`rt-thread-am`中输入无效命令时卡死的bug, 同时让`msh`通过轮询方式获取按键.
> 如果你在2024/01/11 01:50:00之前获取`rt-thread-am`的代码, 请获取新版代码:
> ```bash
> cd rt-thread-am
> git pull origin master
> ```
> 获取新版代码后, 你还需要重新生成一些配置文件:
> ```bash
> cd rt-thread-am/bsp/abstract-machine
> rm rtconfig.h
> make init
> ```
> 之后重新编译运行即可. -->
> #### danger::bug fix
> We fixed the bug in `rt-thread-am` that caused it to get stuck when entering invalid commands, and also let `msh` obtain the keystrokes through polling. If you obtain the code of `rt-thread-am` before 2024/01/11 01:50:00 , please get the new version of the code:
>
> ```bash
> cd rt-thread-am
> git pull origin master
> ```
>
> After getting the new version of the code, you still need to regenerate some configuration files:
>
> ```bash
> cd rt-thread-am/bsp/abstract-machine
> rm rtconfig.h
> make init
> ```
>
> Then recompile and run.

<!-- -->
<!-- > #### todo::通过串口在RT-Thread中键入命令
> 为此, 我们需要让RT-Thread调用刚才实现的IOE功能.
> 修改BSP中的串口输入功能, 使其在读完内置字符串后, 通过IOE从UART RX中获取字符. -->
> #### todo::Type commands in RT-Thread through the serial port
> To do this, we need to let RT-Thread call the IOE function just implemented. Modify the serial port input function in BSP so that after reading the built-in string, it obtains characters from UART RX through IOE.

<!-- ### PS/2键盘

你已经在预学习阶段中做过键盘相关的数字电路实验了, 现在我们来将之前的实验内容接入到ysyxSoC中.
ysyxSoC集成了一个APB总线接口的PS2键盘控制器, 并将其映射到CPU的地址空间`0x1001_1000~0x1001_1007`.
不过ysyxSoC没有提供PS2键盘控制器内部的具体实现, 你需要实现它.
我们对PS2控制器的寄存器空间作如下分配: -->
### PS/2 keyboard

You have already done digital circuit experiments related to keyboards in the pre-learning stage. Now let's integrate the previous experimental content into ysyxSoC. ysyxSoC integrates a PS2 keyboard controller with an APB bus interface, and maps it to the CPU's address space `0x1001_1000~0x1001_1007`. However, ysyxSoC does not provide the specific implementation of the PS2 keyboard controller internally, so you need to implement it. We allocate the register space of the PS2 controller as follows:

<!-- | 地址  | 作用                                 |
| ---   | ---                                  |
| `0x0` | 8位数据, 读出键盘扫描码, 如无按键信息, 则读出`0` |
| 其他  | 保留                                 | -->
Address | Usage
--- | ---
`0x0` | 8-bit data, read the keyboard scan code, if there is no key information, read `0`
Others | Reserved

<!-- > #### todo::让riscv32e-ysyxSoC从NVBoard读取键盘按键
> 你需要进行以下工作:
> 1. 实现PS2键盘控制器.
>    如果你选择Verilog, 你需要在`ysyxSoC/perip/ps2/ps2_top_apb.v`中实现相应代码;
>    如果你选择Chisel, 你需要在`ysyxSoC/soc/Keyboard.scala`的`ps2Chisel`模块中实现相应代码,
>    并将`ysyxSoC/soc/Keyboard.scala`中的`Module(new ps2_top_apb)`修改为实例化`ps2Chisel`模块.
>    * 相比于让键盘控制器进行按键扫描码到其他编码的翻译,
>      我们更推荐让软件获取按键扫描码并进行翻译: 这不仅降低了硬件设计的复杂度, 还提升了灵活性
> 1. 接入NVBoard, 绑定相关引脚
> 1. 在AM IOE中添加代码, 从PS2键盘控制器中读出按键信息, 并将其翻译成AM定义的键盘码
>    * 键盘扫描码可以参考[数字电路实验的相关信息](https://nju-projectn.github.io/dlco-lecture-note/exp/07.html#id8)
>    * 注意部分按键的扫描码包含扩展码, 如`PAGEUP`, 你还需要正确识别它们
>
> 实现后, 运行`am-tests`中的按键测试, 检查你的实现是否正确. -->
> #### todo::Have riscv32e-ysyxSoC read keyboard keys from NVBoard
> You need to do the following:
>
> 1. Implement the PS2 keyboard controller. If you choose Verilog, you need to implement the corresponding code in `ysyxSoC/perip/ps2/ps2_top_apb.v` ; if you choose Chisel, you need to implement the corresponding code in the `ps2Chisel` module of `ysyxSoC/soc/Keyboard.scala` , and modify `Module(new ps2_top_apb)` in `ysyxSoC/soc/Keyboard.scala` to instantiate the `ps2Chisel` module.
>     * Compared to having the keyboard controller translate scan codes into other codes, we recommend letting the software obtain the scan codes and perform the translation: This not only reduces the complexity of hardware design but also increases flexibility.
> 1. Connect to NVBoard and bind relevant pins
> 1. Add code in AM IOE to read key information from the PS2 keyboard controller and translate it into AM-defined keyboard codes
>     * For keyboard scan codes, please refer to [the relevant information of digital circuit experiments](https://nju-projectn.github.io/dlco-lecture-note/exp/07.html#id8).
>     * Note that the scan codes of some buttons include extension codes, such as `PAGEUP` , and you need to correctly identify them.
>
> After implementation, run the keystroke test in `am-tests` to check whether your implementation is correct.

<!-- ### VGA

你应该在预学习阶段中看到过NVBoard中的VGA展示效果,
现在我们让程序借助ysyxSoC将像素信息输出到NVBoard中.
ysyxSoC集成了一个APB总线接口的VGA控制器, 并将其映射到CPU的地址空间`0x2100_0000~0x211f_ffff`.
这段地址空间其实是帧缓冲, 程序往其中写入像素信息, 即可在输出到NVBoard的VGA区域.
NVBoard提供的VGA屏幕分辨率是`640x480`.
不过ysyxSoC没有提供VGA控制器内部的具体实现, 你需要实现它. -->
### VGA

You should have seen the VGA display effect in NVBoard during the pre-learning phase. Now we will use the ysyxSoC to output pixel information to NVBoard through a program. The ysyxSoC integrates a VGA controller with an APB bus interface, which is mapped to the CPU's address space `0x2100_0000~0x211f_ffff`. This address space actually represents the frame buffer. By writing pixel information into it, the output will be displayed on the VGA area of NVBoard. The VGA screen resolution provided by NVBoard is `640x480`. However, ysyxSoC does not provide the specific implementation of the VGA controller internally, so you need to implement it.

<!-- > #### todo::复习VGA的工作原理
> 如果你在预学习阶段的数字电路实验中没有接触过VGA的相关内容,
> 我们建议你先完成[相关的实验内容](https://nju-projectn.github.io/dlco-lecture-note/exp/08.html),
> 从而理解VGA的工作原理, 否则你可能会在设计VGA控制器的时候遇到困难. -->
> #### todo::Review how VGA works
> If you have not encountered the related content of VGA in the digital circuit experiments during the pre-learning phase, we recommend that you complete [the relevant experimental content](https://nju-projectn.github.io/dlco-lecture-note/exp/08.html) first to understand the working principle of VGA. Otherwise, you may encounter difficulties when designing the VGA controller.

<!-- -->
<!-- > #### todo::让riscv32e-ysyxSoC将像素信息输出到NVBoard
> 你需要进行以下工作:
> 1. 实现VGA控制器, 它将不断地将帧缓冲的内容通过VGA的物理接口输出到屏幕上.
>    如果你选择Verilog, 你需要在`ysyxSoC/perip/vga/vga_top_apb.v`中实现相应代码;
>    如果你选择Chisel, 你需要在`ysyxSoC/soc/VGA.scala`的`vgaChisel`模块中实现相应代码,
>    并将`ysyxSoC/soc/VGA.scala`中的`Module(new vga_top_apb)`修改为实例化`vgaChisel`模块.
>    * 关于帧缓冲, 目前你可以暂时使用SRAM等简单存储器的方式来实现.
>      但需要注意, 在真实情况中, 这种实现方案的成本较高:
>      以上文提到的`640x480`分辨率为例, 如果每个像素占4字节,
>      将需要1.17MB的SRAM, 这将占用不少的流片面积
> 1. 接入NVBoard, 绑定相关引脚
> 1. 在AM IOE中添加代码, 将像素信息写入VGA控制器的帧缓冲中
>    * 由于NVBoard提供的VGA机制是自动刷新的, 因此无需实现AM中的画面同步功能
>
> 实现后, 运行`am-tests`中的画面测试, 检查你的实现是否正确. -->
> #### todo::Have riscv32e-ysyxSoC output pixel information to NVBoard
> You need to do the following:
>
> 1. Implement the VGA controller, which will continuously output the contents of the frame buffer to the screen through the VGA physical interface. If you choose Verilog, you need to implement the corresponding code in `ysyxSoC/perip/vga/vga_top_apb.v` ; if you choose Chisel , you need to implement the corresponding code in the `vgaChisel` module of `ysyxSoC/soc/VGA.scala` , and modify `Module(new vga_top_apb)` in `ysyxSoC/soc/VGA.scala` to instantiate `vgaChisel` module.
>     * Regarding frame buffering, currently you can temporarily implement it using simple storage methods like SRAM. However, it is important to note that in real-world scenarios, this implementation approach comes with a higher cost: taking the example of the `640x480` resolution mentioned earlier, if each pixel occupies 4 bytes, it would require 1.17MB of SRAM, which would occupy a significant amount of silicon area.
> 1. Connect to NVBoard and bind relevant pins
> 1. Add code in AM IOE to write pixel information into the frame buffer of the VGA controller
>     * Since the VGA mechanism provided by NVBoard is automatically refreshed, there is no need to implement the picture synchronization function in AM.
>
> After implementation, run the screen test in `am-tests` to check whether your implementation is correct.

<!-- -->
<!-- > #### question::更实际的帧缓冲实现方案
> 通常, 帧缓冲一般是在内存中分配, 通过配置VGA控制器中的部分寄存器,
> 可以让VGA控制器从内存中读取像素信息.
>
> 思考一下, 如果在当前的ysyxSoC配置中将帧缓冲分配到内存中, 可能会造成什么问题? -->
> #### question::A more practical framebuffer implementation
> Usually, the frame buffer is generally allocated in memory. By configuring some registers in the VGA controller, the VGA controller can read pixel information from the memory.
>
> Think about it, what problems might it cause if the framebuffer is allocated into memory in the current ysyxSoC configuration?

<!-- -->
<!-- > #### todo::通过NVBoard展示游戏
> 尝试在NVBoard上运行打字游戏和超级玛丽等游戏.
> 当然, 这应该会非常卡, 我们后续的工作就是在微结构层次优化系统的性能. -->
> #### todo::Display the game via NVBoard
> Try running typing games and Super Mario games on the NVBoard. Of course, this should be very slow. Our subsequent work is to optimize the performance of the system at the micro architecture level.

<!-- ### 在RT-Thread上运行AM程序

接入上述设备后, 我们可以在RT-Thread上运行其他AM程序, 从而形成一个完整的SoC计算机系统! -->
### Run AM program on RT-Thread

After connecting to the above devices, we can run other AM programs on RT-Thread to form a complete SoC computer system!

![image](https://ysyx.oscc.cc/slides/2306/resources/img/2306/20-nvboard.png)

<!-- * 最上层是应用程序, 如超级玛丽, 它们以线程的方式在RT-Thread中运行
* RT-Thread提供若干资源的管理, 包括物理内存, 线程等
  * RT-Thread还能管理很多资源, 如文件等, 目前我们的计算机系统暂不使用
* AM运行时环境提供TRM, IOE和CTE的功能抽象, 以支持RT-Thread在裸机上的运行
* RISC-V指令集提供具体的指令, MMIO机制和异常处理机制, 用于实现AM的TRM, IOE和CTE等具体功能
* NPC实现了RISC-V指令集的功能
* ysyxSoC集成了NPC, 使得NPC通过SoC中的总线与各种设备控制器通信
* NVBoard模拟了开发板的功能, 提供设备的物理实现, 并通过引脚与设备控制器交互 -->
- The top layer is applications, such as Super Mario, which run in RT-Thread in a threaded manner.
- RT-Thread provides management of several resources, including physical memory, threads, etc.
    - RT-Thread can also manage many resources, such as files, etc., which are currently not used in our computer system.
- AM runtime environment provides functional abstraction of TRM, IOE and CTE to support RT-Thread running on bare metal
- The RISC-V instruction set provides specific instructions, MMIO mechanisms and exception handling mechanisms to implement specific functions such as AM's TRM, IOE and CTE.
- NPC implements the functions of the RISC-V instruction set
- ysyxSoC integrates NPC, allowing NPC to communicate with various device controllers through the bus in the SoC
- NVBoard simulates the functionality of the development board, provides the physical implementation of the device, and interacts with the device controller through pins

<!-- > #### danger::更新RT-Thread
> 我们在2024/01/18 20:00:00为RT-Thread添加了集成其他AM程序的功能.
> 如果你在上述时间前之前获取`rt-thread-am`的代码, 请获取新版代码:
> ```bash
> cd rt-thread-am
> git pull origin master
> ``` -->
> #### danger::Update RT-Thread
> We added the function of integrating other AM programs to RT-Thread at 2024/01/18 20:00:00. If you obtained the code of `rt-thread-am` before the above time, please obtain the new version of the code:
>
> ```bash
> cd rt-thread-am
> git pull origin master
> ```

<!-- -->
<!-- > #### todo::通过RT-Thread运行其他AM程序
> 参考PA4阶段1中的选做任务"在RT-Thread上运行AM程序",
> 尝试在`riscv32e-ysyxsoc`中通过RT-Thread启动超级玛丽等其他AM程序. -->
> #### todo::Run other AM programs through RT-Thread
> Refer to the optional task "Running AM programs on RT-Thread" in PA4 Phase 1 and try to start other AM programs such as Super Mario through RT-Thread in `riscv32e-ysyxsoc` .

<!-- ## ChipLink - 芯片间的总线协议 -->
## ChipLink - Inter-chip bus protocol

<!-- 上面的设备控制器都位于同一个SoC中, 因此会占用一定的流片面积.
如果设备控制器比较复杂(如现代DDR控制器), 将会花费不少流片成本.
事实上, 我们可以将总线延伸到芯片外部:
两个芯片可以在遵循同一套通信协议的情况下互相通信.
这样, 我们设计的芯片就可以访问其他芯片成品上的设备,
而后者一方面不占用我们的流片面积, 从而节省流片成本,
另一方面也可以降低验证的复杂度和流片风险,
毕竟芯片成品上的功能已经经过较充分的验证. -->
All the device controllers are located within the same SoC, thus occupying a certain area of the silicon die. If the device controllers are complex (such as modern DDR controllers), it will incur considerable die cost. In fact, we can extend the bus outside of the chip: two chips can communicate with each other following the same communication protocol. In this way, our designed chip can access devices on other chip products, which, on one hand, does not occupy our die area, thereby saving die cost, and on the other hand, can also reduce the complexity of verification and die risk, since the functions on the chip products have been thoroughly verified.

<!-- 如果对端芯片是个FPGA, 我们还能获得灵活的扩展能力:
只需要将设备控制器烧录到FPGA中, 芯片就可以通过片间总线协议访问这些设备.
即使设备控制器有bug也不会带来灾难性的后果, 只需要在修复bug后重新烧录到FPGA中即可. -->
If the peer chip is an FPGA, we can also gain flexible expansion capabilities: by programming the device controllers into the FPGA, the chip can access these devices through the inter-chip bus protocol. Even if there are bugs in the device controllers, it won't lead to catastrophic consequences; it only requires reprogramming the FPGA after fixing the bugs.

<!-- 不过, 这些接口是要占用芯片引脚的. 考虑地址位宽和数据位宽均为32位的AXI总线,
`araddr`, `awaddr`, `rdata`和`wdata`这几个信号就占用了128个引脚,
加上各种控制信号, 总计约150个引脚;
若数据位宽是64位, 则总计需要占用200个以上的引脚.
因此, 如果我们直接将AXI总线连到片外,
很可能需要采用较昂贵的封装方案, 这就违背了节省成本的初衷. -->
However, these interfaces will occupy the chip's pins. Considering an AXI bus with both address and data widths of 32 bits, the signals `araddr`, `awaddr`, `rdata`, and `wdata` alone would occupy 128 pins. Along with various control signals, the total comes to about 150 pins; if the data width is 64 bits, then it would require over 200 pins in total. Therefore, if we directly connect the AXI bus to external components, it is likely that we would need to adopt a more expensive packaging solution, which contradicts the original intention of saving costs.

<!-- 如果想通过更少的引脚将AXI请求发送到片外, 就只能对引脚进行分时复用了:
通过对AXI请求的信号进行分解, 每次传输其中的一部分, 通过多个周期来传输一个完整的AXI请求.
例如, 如果只用32个引脚, 那么我们可以约定, 在T0时刻先传输32位的写地址,
在T1时刻传输32位的写数据, 在T2时刻传输其他控制信号.
如果对端的芯片也遵循相同的约定, 它就可以按照约定,
将这3个周期从32个引脚上收到的信息重新组合成一个AXI的写请求,
从而实现了通过3个周期将一个AXI写请求传送到另一个芯片上的效果. -->
To send AXI requests externally using fewer pins, time-division multiplexing of the pins is necessary: by decomposing the AXI request signals and transmitting a portion of them at a time, a complete AXI request can be transmitted over multiple cycles. For example, if only 32 pins are used, we could agree to transmit a 32-bit write address at time T0, a 32-bit write data at time T1, and other control signals at time T2. If the peer chip also follows the same agreement, it can reassemble the information received from the 32 pins over these three cycles into an AXI write request, thereby achieving the effect of transmitting an AXI write request to another chip over three cycles.

<!-- 这样的约定, 其实就是一套芯片间的总线协议,
它约定了通过分时复用将AXI请求传输到片外的各种细节.
为了方便描述, 我们将片间的总线协议称为外层协议, 将被分解传输的总线协议称为内层协议.
例如, 上述场景中AXI就是片间传输过程中的内层协议.
当然, 内层协议不一定是AXI, 也可以对其他协议的请求进行分解并传输. -->
This agreement essentially constitutes a set of inter-chip bus protocols, which stipulates the details of transmitting AXI requests externally through time-division multiplexing. For ease of description, we refer to the inter-chip bus protocol as the outer layer protocol and the bus protocol that is decomposed and transmitted as the inner layer protocol. For example, in the scenario described above, AXI serves as the inner layer protocol during inter-chip transmission. Of course, the inner layer protocol does not have to be AXI; requests from other protocols can also be decomposed and transmitted.

<!-- 例如, 片间总线协议ChipLink可以将TileLink总线协议作为内层协议进行片间传输.
和AXI类似, TileLink也是全双工的, 也即发送方和接收方可以同时在信道上传输信息.
因此, ChipLink也被设计成全双工, 单个方向除了32个数据信号之外, 还有时钟, 复位和有效信号,
标准的ChipLink协议需要占用70个引脚, 比单独将内层协议TileLink传输到片外所占用的引脚数少得多. -->
For instance, the inter-chip bus protocol ChipLink can use TileLink as its inner layer protocol for inter-chip transmission. Similar to AXI, TileLink is also full-duplex, meaning that the sender and receiver can transmit information on the channel simultaneously. Therefore, ChipLink is designed to be full-duplex as well. In a single direction, in addition to 32 data signals, there are also signals for clock, reset, and valid. The standard ChipLink protocol requires 70 pins, which is significantly fewer than what would be needed if TileLink, as the inner layer protocol, were to be transmitted externally by itself.

<!-- 事实上, 还可以通过减少数据信号的位宽来进一步减少ChipLink占用引脚的数量.
例如, 当数据位宽减少到8位时, ChipLink协议只需要占用22个引脚.
不过这需要付出传输带宽的代价: 一个内层协议请求的传输需要花费更多周期了,
因此单位时间内传输的有效数据量也会随之降低.
如果使用场景对带宽的需求不大, 可以通过这种方式节约芯片封装的成本. -->
Indeed, the number of pins required by ChipLink can be further reduced by decreasing the width of the data signals. For example, when the data width is reduced to 8 bits, the ChipLink protocol only needs to occupy 22 pins. However, this reduction comes at the cost of transmission bandwidth: transmitting a request from the inner layer protocol would take more cycles, thus decreasing the amount of effective data transmitted per unit of time. If the application scenario does not demand high bandwidth, this approach can be a way to save on chip packaging costs.

<!-- ChipLink提供了开源的实现, 不过它的内层协议只支持TileLink,
但我们可以借助rocket-chip项目中的转接桥, 先将AXI请求转成TileLink请求,
然后通过ChipLink协议将TileLink请求传输到对端芯片,
对端芯片根据ChipLink协议组合出TileLink请求后,
再通过转接桥将TileLink请求转换回AXI请求, 从而实现了AXI请求的片间传输. -->
ChipLink offers an open-source implementation, but it only supports TileLink as its inner layer protocol. However, we can utilize the adapter bridges in the rocket-chip project to first convert AXI requests into TileLink requests. Then, through the ChipLink protocol, TileLink requests can be transmitted to the peer chip. After the peer chip reassembles the TileLink requests according to the ChipLink protocol, it can convert the TileLink requests back into AXI requests via an adapter bridge, thereby achieving inter-chip transmission of AXI requests.

<!-- ysyxSoC集成了上述ChipLink的开源实现, 并模拟了通过ChipLink连接对端FPGA芯片的场景,
模拟的对端FPGA芯片中包含一个大小为1GB的存储器,
ysyxSoC将这段空间映射到CPU的地址空间`0xc000_0000~0xffff_ffff`.
在实际的使用中, 这段地址空间中包含什么设备, 是可编程的,
也即, 我们可以充分利用FPGA的可编程性,
通过更新FPGA的比特流文件, 将不同的设备接入到这段地址空间中. -->
The ysyxSoC integrates the open-source implementation of ChipLink mentioned above and simulates a scenario where it is connected to a peer FPGA chip via ChipLink. The simulated peer FPGA chip contains a memory of 1GB, and ysyxSoC maps this space into the CPU's address space `0xc000_0000~0xffff_ffff`. In actual use, what devices are contained within this address space is programmable, meaning that we can fully leverage the programmability of the FPGA. By updating the FPGA's bitstream file, different devices can be connected to this address space.

<!-- > #### danger::获取新代码
> 我们添加了打开ChipLink后的`ysyxSoCFull.v`.
> 如果你在2024/01/11 14:15:00之前获取`ysyxSoC`的代码, 请获取新版代码:
> ```bash
> cd ysyxSoC
> git pull origin ysyx6
> ``` -->
> #### danger::get new code
>
> We have added `ysyxSoCFull.v` after opening ChipLink. If you obtain the code of `ysyxSoC` before 2024/01/11 14:15:00, please obtain the new version of the code:
>
> ```bash
> cd ysyxSoC
> git pull origin ysyx6
> ```

<!-- -->
<!-- > #### todo::通过ChipLink访问对端芯片的资源
> ysyxSoC默认未打开ChipLink, 因此你需要通过如下方式打开ChipLink进行测试:
> * 如果你选择Verilog, ysyxSoC提供了预先生成的`.v`文件,
>   将`ysyxSoC/genreated/ysyxSoCFull-ChipLink.v`作为顶层进行仿真即可
> * 如果你选择Chisel, 你需要在`ysyxSoC/soc/SoC.scala`的`ysySoCFull`类中将`hasChipLink`变量修改为`true`,
>   重新生成`ysySoCFull.v`并仿真即可
>
> 不过ChipLink的代码要求仿真顶层的复位信号需要维持至少10个周期,
> 你需要检查你的仿真代码是否符合这个条件.
>
> 打开ChipLink后, 通过`mem-test`对上述地址空间进行测试.
> 由于测试的侧重点是检查NPC是否能通过ChipLink访问对端资源, 因此我们不必测试整个地址空间,
> 只需要测试一小段存储空间的访问(如4KB)即可.
>
> 由于ChipLink的实现较复杂, 添加ChipLink后将生成较多Verilog代码, 从而使仿真效率明显降低.
> 因此后续实验内容不要求你在打开ChipLink的情况下进行.
> 通过当前测试后, 你可以关闭ChipLink. -->
> #### todo::Access the resources of the peer chip through ChipLink
> ysyxSoC does not open ChipLink by default, so you need to open ChipLink as follows for testing:
>
> - If you choose Verilog, ysyxSoC provides pre-generated `.v` files, just use `ysyxSoC/genreated/ysyxSoCFull-ChipLink.v` as the top level for simulation
> - If you choose Chisel, you need to modify `hasChipLink` variable to `true` in the `ysySoCFull` class of `ysyxSoC/soc/SoC.scala` , regenerate `ysySoCFull.v` and simulate it.
>
> However, ChipLink's code requires that the reset signal at the top level of the simulation must be maintained for at least 10 cycles. You need to check whether your simulation code meets this condition.
>
> After opening ChipLink, test the above address space through `mem-test` . Since the focus of the test is to check whether the NPC can access the peer resources through ChipLink, we do not have to test the entire address space, but only need to test the access to a small section of storage space ( Such as 4KB) is sufficient.
>
> Since the implementation of ChipLink is more complex, adding ChipLink will generate more Verilog code, which will significantly reduce the simulation efficiency. Therefore, subsequent experiments do not require you to open ChipLink. After passing the current test, you can turn off ChipLink.
