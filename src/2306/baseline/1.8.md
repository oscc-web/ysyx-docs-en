## SoC

之前已经学习了总线协议，也了解了CPU如何和设备交互通信，本节将以一生一芯的SoC为例，讲解大家编写的处理器如何与设备交互。其中具体设备包含ROM、UART、flash、SDRAM。

## 最简单的SoC
我们可以定义一个最简单的运行时环境，它约定程序从地址0开始执行，在a0=1时结束程序运行。它只支持addi和ebreak这两条指令，其中ebreak指令用于输出。
但在真实的SoC中，对板卡上电后并没有仿真环境或运行时环境提供上述功能，因此需要通过硬件来实现这些基本功能。

首先需要考虑程序放在哪里。仿真环境或运行时环境可以直接将程序加载到内存中，再交给处理器执行。而SoC中的RAM实际上是易失存储器（volatile memory），它在上电时其中并没有有效数据，如果CPU直接从内存中读取指令执行，整个系统的行为是为定义的，无法让CPU执行预期的程序。因此，需要使用一种非易失存储器（non-volatile memory），如ROM，其内容能在断电时保持。如果将程序保存在非易失存储器中，CPU从该存储器中取指并执行程序，就能够指定CPU的行为。程序可以是一个bin文件，其中包含了用户希望执行的指令，例如它可以是一个读文件操作。此外，还需要为程序提供一个最基本的输出设备，真实的SoC中通常使用UART16550，它包含一些设备寄存器，用于设置字符长度、波特率等信息。在写字符时，首先需要等待发送队列，在其不满时即可通过写对应设备寄存器来进行写入。

在引入两个设备后，会产生一些新问题。首先，SoC中现在包含ROM和UART这两个slave，如何确定CPU希望访问哪一个设备呢？之前讲解设备时介绍过内存映射IO，通过不同的内存地址来指示CPU访问的设备。在硬件上，这实际是通过一个crossbar（有时也写作Xbar）实现，该模块可以根据请求的地址，将请求转发给不同的下游模块。假设UART位于地址[0x1000_0000, 0x1000_0fff)，ROM位于[0x3000_0000, 0x3fff_ffff)，下图中的Arbiter用于从输入请求中选择一个请求转发给下游，下游的Xbar收到请求后，根据地址选择其连接的下游slave。如果请求的地址位于UART的地址空间范围，那么crossbar会将请求转发给UART，如果请求位于ROM地址空间范围，则转发给ROM。如果请求为其他地址，例如0x2000_0000，crossbar发现该地址不位于任何设备中，即可返回一个错误信号decerr，表示译码错。而内存映射IO在硬件上的体现实际上就是一个地址译码器。


```
+-----+       +---------+       +------+       +-----+
| IFU | ----> |         |       |      | ----> | UART|   [0x1000_0000, 0x1000_0fff)
+-----+       |         |       |      |       +-----+
              | Arbiter | ----> | Xbar |
+-----+       |         |       |      |       +-----+
| LSU | ----> |         |       |      | ----> | ROM |   [0x3000_0000, 0x3fff_ffff)
+-----+       +---------+       +------+       +-----+
```

Arbiter和Xbar也可以合并成一个多进多出的Xbar（也称Interconnect、总线桥等），例如图中示例即为一个2输入、2输出的Xbar。该模块可以将多个master和多个slave连接起来，首先通过Arbiter记录当前请求来自哪个master，再由Xbar依据该请求的地址决定将发送给哪个slave。

这种连接方式也可能有隐藏的问题。依据上图的拓扑关系，IFU实际上也和UART相连，这说明CPU居然可以从UART中取指。如果程序跳转到了一个非预期的地址，如0x1000_0000，那么CPU将向UART发送读请求，UART依据设备的行为返回一个数据，如寄存器的值或接收到的数据，CPU将读取的结果用作指令执行时，很容易抛出非法指令异常。更糟糕的是，IFU对UART设备的访问可能会改变设备的状态，导致UART进入一个未知状态。

第二个问题是如何识别设备寄存器的访问范围。在UART中以下4个设备寄存器，它们的地址分别为0、1、2、3，假设UART通过AXI-Lite总线连接Xbar，如何读取地址0的设备寄存器呢？显然，araddr信号应该设置为0x1000_0000，但读取的长度需要仔细考虑。在读内存时，无需重点关注读取的长度，总线可以一次读取4字节或8字节交给CPU处理。但由于访问设备寄存器会改变设备状态，读取4字节可能同时影响4个寄存器，因此需要仔细处理请求的长度。

```
`define UART_REG_RB `UART_ADDR_WIDTH'd0  // receiver buffer
`define UART_REG_IE `UART_ADDR_WIDTH'd1  // Interrupt enable
`define UART_REG_II `UART_ADDR_WIDTH'd2  // Interrupt identification
`define UART_REG_LC `UART_ADDR_WIDTH'd3  // Line Control
```

AXI-Lite总线并不能解决上述问题，其AR通道中没有足够的信号编码读取长度信息，因此设备只能认为实际访问的数据位宽等于总线的数据位宽，若单次AXI-Lite访问覆盖多个寄存器，则可能导致设备状态出错，因此，并非所有设备都适合通过AXI-Lite总线接入。完整的AXI总线引入了窄传输的概念，它通过arsize/awsize来表示实际访问的数据位宽，在实际数据位宽小于总线位宽时，就称为窄传输。总线数据位宽是在硬件设计时静态决定的，实际访问的数据位宽可依据软件访存指令中的位宽动态决定。例如，lb指令只访问一个字节，而lw将访问4字节。


## 更实用的SoC

ROM通常硬连线写死在芯片内，厂商根据提供的版图制造芯片，而版图则是我们通过RTL进行后端物理设计得到的。在芯片制造完成后，ROM中存储的内容无法再进行更改，因此它通常被称为只读，用户更换程序执行也比较困难。而随着材料技术的进步，目前人们已经发明了这种现场可编程的新型存储器，称为flash存储器。现场可编程指的是能够擦除其中的内容，并重新进行写入，这样，改动flash中存放的程序的代价就可以接受了。

接下来将简单介绍一个flash颗粒（型号W25Q128JV）的例子，其整个存储单元分成256个64KB的块，每个块有16个4KB的扇区，每个扇区又有16个256B的页。页是flash颗粒中的最小擦除和写入单位，字节是最小的读取单位，它也能支持随机读取。外部通过向flash发送指令指示flash的行为，例如8位指令03h表示读数据，后面加24位的存储单元地址。

flash颗粒不能直接进行写入，为了支持store指令的执行，需要一个支持随机写操作的存储器，如SDRAM（Synchronous Dynamic Random Access Memory）。对于SDRAM颗粒，同样可以通过输入信号向SDRAM发送不同的命令，从而实现读写操作。SDRAM控制器通过状态机来向SDRAM颗粒发送命令序列，在初始化完成后，SDRAM处于idle状态，首先判断是否需要刷新，在不需要时则可通过激活命令进入active状态，并查看当前的访存请求，若当前为读操作，则进入read状态，并在发送完地址后进入read wait状态，等待读操作执行完成后回到idle状态。

现在来看看如何从flash颗粒中加载程序。上文已经介绍了，flash颗粒可读可执行，能够一次获取32位数据或指令，但不能直接写入，而SDRAM颗粒可读可写可执行，因此希望程序运行在SDRAM上。为了实现这一点，首先需要将待运行程序链接到SDRAM所在的地址空间中，同时将栈指针分配到该空间。第二步需要编写一个加载器，用于将程序从flash中搬运到SDRAM内，并跳转到SDRAM执行。这个加载器可以是二进制加载器，直接拷贝程序内容，也可以是elf加载器，它无需拷贝.bss节，而是直接通过memset()初始化其内容，能够节省拷贝时间。需要注意，加载器的栈同样需要位于SDRAM地址空间中，该栈空间不能覆盖加载程序，只是临时使用，在加载完成后即可释放该栈空间。第三步则需要将待加载程序以数据的形式存放在加载器的数据段中，从而使加载器能够找到并加载程序，同时需要将加载器链接到flash的地址空间中，并将加载器烧写到flash中。最后，调整CPU的复位地址位flash的起始地址，在CPU复位后，将从flash中开始取指，从而启动加载器执行。


## 中断系统

在RISC-V中有三种中断，如下表所示。在M模式下，三种中断都由真实硬件触发，例如，当CLINT计时器满足比较条件时，就会触发时钟中断；向CLINT中一个寄存器写入1，则触发软件中断；外部中断来自PLIC的中断线。相应地，S模式的中断主要通过向MIP寄存器写入该中断对应的位实现。下文将介绍不同的中断对系统功能的影响。

|      | M模式  | S模式   |
| :----: | ---- | ---- |
|   时钟中断   | CLINT的计时器比较   | mip.STIP   |
|   软件中断   | CLINT的寄存器      | mip.SSIP   |
|   外部中断   | PLIC的中断线       | PLIC中断线或mip.SEIP   |



在大多操作系统（如Linux、RT-thread）中的多线程调度需要时钟中断的支持。尽管不实现时钟中断，也可以启动系统，但此时系统启动后只能运行一个程序，无法同时让多个程序分时运行。处理器间的通信通常利用软件中断实现，在多核系统中更为常用，因此对于单核的操作系统，可以不实现软件中断。外部中断通常用于一些复杂外设，如网卡等，上文介绍的外设都比较简单，无需实现外部中断也可运行。

### CLINT

CLINT是一个非常简单的设备，它只包含以下3个寄存器：
- mtime：可读可写，以恒定速率增加
- mtimecmp：可读可写，在mtime > mtimecmp时产生M模式时钟中断
- msip：可读可写，向其写入1将产生M模式软件中断

CLINT中每个寄存器都十分简单，也很容易基于总线实现，只需解析总线的读写请求，并实现上述几个寄存器即可。

### PLIC

若CPU需要支持外部中断，通常需要实现PLIC中断控制器，这实际上是一个外部中断的选择器。当多个设备同时发起外部中断时，PLIC负责从中选择一个，并通过M模式外部中断通知处理器进行处理。


### CPU中断响应过程

以M模式时钟中断为例介绍CPU响应中断的过程。响应中断需要满足以下3个条件：
- mstatus.MIE位为1，即CPU全局中断使能位为1
- mie.MTIP为1，即M模式时钟中断使能位为1
- mip.MTIP为1，即M模式时钟中断等待位为1。该位为1时表示当前有M模式时钟中断到来，在硬件上与 $mtime\geq mtimecmp$ 的比较结果直接相连，因此设置一个较大的mtimecmp即可清除M模式时钟中断。

在上述条件都满足后，CPU需要响应到来的时钟中断，具体的中断响应过程和异常处理类似。其他中断的条件和响应过程也是类似的，响应软件中断只需将对应的位换成软件中断指示位即可。

此外，RISC-V中还存在一种委托机制，可以将响应的异常或中断委托给S模式进行处理，在运行操作系统时会使用该机制，它通过medeleg和mideleg这两个CSR实现。


## 其他

### DMA

对于部分需要频繁进行数据拷贝的外设， 例如网卡和SD卡，其可能会使用DMA来帮助数据移动。DMA可以理解为一个memcpy()加速器，专门用于帮助这些外设进行数据移动。执行memcpy()函数本身需要由CPU参与，而DMA直接通过硬件实现该功能，从而绕过CPU。

在硬件上，DMA的本质是一个AXI master，它可以向总线发起访存请求，并通过状态机控制总线信号进行读写操作。

### AXI跨片通信

如果我们希望芯片可以通过AXI访问芯片外的资源，需要怎么做呢？观察64位数据、32位地址的AXI总线，其包含200多个信号，如果直接将AXI总线进行传输，将每个信号连接到引脚上将消耗大量的引脚资源。而通常的封装方案并不能支持这么多引脚，支持如此多数目的引脚的成本颇高。

因此，我们选择了一个折中方案，我们选择了一个称为ChipLink的协议，它的思想是：先使用数量较少的引脚将请求打包后发送给对面，在由对面进行解包，之后就可以进行跨片的传输。若采用数据位宽为32的ChipLink协议，信号数目减少到70个，而采用数据位宽为8的协议时，信号数目则可减少至22个。将芯片所在的板卡通过ChipLink和FPGA相连时，即可实现灵活的设备扩展，由芯片发送的AXI请求经过ChipLink传递到FPGA，再还原为AXI请求，这样就实现了从芯片到FPGA的AXI请求。而在FPGA中可以连接各种设备供芯片进行访问，但这种方式的带宽通常较低。当设备发出中断时，该中断请求需要回到CPU中，此时可以通过一个额外的引脚来传递中断信号。具体而言，设备产生的中断会首先进入FPGA的二级中断控制器中，它会从中选择一个中断，通过引脚传递给芯片，并进入PLIC模块（一级中断控制器），最终向CPU发送外部中断请求。

