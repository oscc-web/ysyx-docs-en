<!-- # C2 支持RV32E的单周期NPC

你已经实现了minirv指令集的NPC, 但由于minirv的核心指令只有8条,
这意味着, 将程序编译到minirv上, 会得到更多的指令, 从而使得程序的运行时间变慢.
要提升程序运行的性能, 一个方向是在NPC中实现更多的常用指令,
让程序编译到完整的RV32E, 从而降低程序的指令数.
因此, 我们需要将NPC采用的ISA从minirv"升级"为RV32E.
在A阶段, 我们会再次将NPC继续"升级"为RV32IMAC.

需要说明的是, 虽然NEMU采用RV32IM, 与NPC采用的RV32E有所不同,
但RV32E所要求的功能, RV32IM也具备, 故RV32E的程序可以直接运行在RV32IM的处理器上.
因此, 只要我们确保已经将程序编译到RV32E,
即使我们把RV32IM的NEMU作为DiffTest的REF, 也可以正常工作. -->

# C2 RV32E Single Cycle NPC 

You have implemented the NPC with the minirv instruction set. However, since minirv only has 8 core instructions,
this means that when programs are compiled for minirv, more instructions will be generated, resulting in slower program execution.
To improve program performance, one approach is to implement more common instructions in NPC,
allowing programs to be compiled for the full RV32E, thereby reducing the number of instructions in the program.
Therefore, we need to "upgrade" the ISA used by NPC from minirv to RV32E.
In phase A, we will further "upgrade" NPC to RV32IMAC.

It should be noted that although NEMU uses RV32IM, which is different from the RV32E used by NPC,
RV32IM has all the functions required by RV32E, so RV32E programs can run directly on RV32IM processors.
Therefore, as long as we ensure that the program has been compiled for RV32E,
even if we use the RV32IM NEMU as the REF for DiffTest, it can work normally.


<!-- ## 为NPC搭建基础设施

通过完成PA, 你应该意识到基础设施的重要性了.
在PA中有四大基础设施: sdb, trace, native, DiffTest.
除了native属于AM之外, 其余三大基础设施都可以在NPC中搭建. -->
## Building Infrastructure for NPC

By completing the PA, you should have realized the importance of infrastructure.
There are four major infrastructure components in PA: sdb, trace, native, and DiffTest.
Except for native, which belongs to AM, the other three infrastructure components can all be built in NPC.




<!-- > #### caution::我都能看波形了, 为什么还需要这些基础设施?
> 这是希望大家不要沦为工具人, 从而浪费生命.
>
> 波形确实包含了电路中所有信号每个周期的信息, 但这些信息太底层了,
> 它们无法携带任何高层的语义, 导致需要用户自己从这些海量信息之中寻找错误.
>
> 事实上, bug引发的错误, 在不同的抽象层次中都是有表现的,
> 例如RTL的实现中连错了一个信号, 反映到程序运行中,
> 可能是取到了错误的指令, 访问了非法内存, 或者是从函数返回到一个不正确的位置...
> 虽然你最终也能从0和1变化的波形中分析出这些错误,
> 但如果你可以直接从itrace/mtrace/ftrace的输出中发现问题, 不是更香吗?
> 为什么你要浪费这么多时间来做这些工具本来就做得很好的事情呢?
> 况且, 如果这个bug是软件层次的问题, 看波形来调试不是自找麻烦吗?
>
> 科学的调试过程首先需要理解程序如何在计算机上运行,
> 此外还需要理解各种工具的优缺点, 根据不同的场景选择正确的工具来分析问题.
> 根据计算机系统的抽象层视角, 我们可以从不同的层次观察程序运行的行为:
> > 程序 -> 模块 -> 函数 -> 指令 -> 访存 -> 总线 -> 信号
>
> 层次越高, 行为越容易理解, 但细节也越来越模糊;
> 而层次越低, 细节会越精确, 但行为也越来越难理解.
> 因此, 科学的调试方法应该是:
> * 先使用正确的软件工具帮助你迅速定位bug产生的大概位置
> * 然后再结合波形在很小的范围内进行更细粒度的诊断, 找到bug的精确位置

> #### todo::为NPC搭建sdb
> 你需要为NPC实现单步执行, 打印寄存器和扫描内存的功能,
> 而表达式求值和监视点都是基于打印寄存器和扫描内存实现的.
> 单步执行和扫描内存都很容易实现.
>
> 为了打印寄存器, 你需要访问RTL中的通用寄存器.
> 有如下两种方式进行访问, 你可以自行选择:
> 1. 通过DPI-C进行访问.
> 1. 通过Verilator编译出的C++文件来访问通用寄存器,
>    例如`top->rootp->NPC__DOT__isu__DOT__R_ext__DOT__Memory`,
>    具体的C++变量名与Verilog中的模块名和变量名有关, 可阅读编译出的C++头文件得知.
>    不过C++变量名可能会在修改RTL代码或更改Verilator版本时发生变化, 需要手动同步修改.

> #### todo::为NPC添加trace支持
> 你已经在NEMU中实现itrace, mtrace和ftrace了, 尝试在NPC中实现它们.
> 其中, 实现itrace需要注意两点:
> * 需要通过DPI-C获取当前执行的指令
> * 需要链接capstone库, 具体可以参考`nemu/src/utils/filelist.mk`
>
> 在仿真环境获取到当前执行的指令和访存信息之后, mtrace和ftrace也就不难实现了. -->

> #### caution::I can already view waveforms, so why do I still need these infrastructure components?
> This is to prevent everyone from becoming mere tool operators and thus wasting their lives.
>
> Waveforms do contain information about all signals in the circuit at every cycle, but this information is too low-level.
> They cannot carry any high-level semantics, meaning users have to sift through massive amounts of information to find errors themselves.
>
> In fact, errors caused by bugs manifest at different levels of abstraction.
> For example, a misplaced signal in the RTL implementation might, when reflected in program execution,
> result in fetching the wrong instruction, accessing illegal memory, or returning to an incorrect position from a function...
> While you could eventually analyze these errors from waveforms of 0s and 1s changing,
> wouldn't it be better if you could directly spot the problem from the output of itrace/mtrace/ftrace?
> Why waste so much time doing things that tools are already good at?
> Moreover, if the bug is at the software level, debugging by looking at waveforms is just asking for trouble.
>
> A scientific debugging process first requires understanding how programs run on a computer.
> Additionally, it involves understanding the advantages and disadvantages of various tools, and selecting the right tool for analyzing problems based on different scenarios.
> From the perspective of abstraction layers in a computer system, we can observe program execution behavior at different levels:
> > Program -> Module -> Function -> Instruction -> Memory access -> Bus -> Signal
>
> The higher the layer, the easier it is to understand the behavior, but the more vague the details become;
> the lower the layer, the more precise the details, but the harder it is to understand the behavior.
> Therefore, a scientific debugging method should be:
> * First, use appropriate software tools to help you quickly locate the approximate location of the bug.
> * Then, combine waveforms to conduct more fine-grained diagnosis within a small range to find the exact location of the bug.

> #### todo::Build sdb for NPC
> You need to implement functions for NPC such as single-step execution, printing registers, and scanning memory.
> Expression evaluation and watchpoints are both based on printing registers and scanning memory.
> Single-step execution and memory scanning are relatively easy to implement.
>
> To print registers, you need to access the general-purpose registers in the RTL.
> There are two ways to do this, and you can choose either:
> 1. Access via DPI-C.
> 1. Access general-purpose registers through C++ files compiled by Verilator,
>    such as `top->rootp->NPC__DOT__isu__DOT__R_ext__DOT__Memory`.
>    The specific C++ variable name is related to the module names and variable names in Verilog, and can be found by reading the compiled C++ header files.
>    However, the C++ variable name may change when modifying RTL code or changing Verilator versions, requiring manual synchronization.

> #### todo::Add trace support to NPC
> You have already implemented itrace, mtrace, and ftrace in NEMU; try to implement them in NPC.
> For implementing itrace, note the following two points:
> * You need to obtain the currently executing instruction via DPI-C.
> * You need to link the capstone library; for details, you can refer to `nemu/src/utils/filelist.mk`.
>
> After obtaining the currently executing instruction and memory access information in the simulation environment, implementing mtrace and ftrace will not be difficult.





<!-- DiffTest是处理器调试的一大杀手锏, 在为NPC实现更多指令之前, 为其搭建DiffTest是一个明智的选择. 
> 在这里, DUT是NPC, 而REF则选择NEMU. 为此, 你需要
> * 在`nemu/src/cpu/difftest/ref.c`中实现DiffTest的API, 包括`difftest_memcpy()`,
>   `difftest_regcpy()`和`difftest_exec()`. 此外`difftest_raise_intr()`是为中断准备的, 目前暂不使用
> * 在NEMU的menuconfig中选择共享库作为编译的目标
> ```
> Build target (Executable on Linux Native)  --->
<!-- >   (X) Shared object (used as REF for differential testing)
> ```
> * 重新编译NEMU, 成功后将会生成动态库文件`nemu/build/riscv32-nemu-interpreter-so`
> * 在NPC的仿真环境中通过动态链接方式链接上述的动态库文件, 通过其中的API来实现DiffTest的功能,
>   具体可以参考NEMU的相关代码
>
> 尝试在打开DiffTest机制的情况下在NPC中正确运行dummy程序.
> 为了检查DiffTest机制是否生效, 你可以为NPC中`addi`指令的实现注入一个错误,
> 观察DiffTest是否能够按照预期地报告这一错误.
>
> 注意, 为了再次将NEMU编译成ELF, 你还需要修改NEMU中menuconfig的编译目标. --> 

<!-- > #### comment::我可以选择Spike作为REF吗?
> 考虑到NEMU比Spike的实现更简单, 而且大家也更熟悉, 我们还是优先推荐大家把自己的NEMU作为REF.
> 总有一天你需要在REF中添加一些个性化的功能来帮助你调试,
> 我们不希望大家觉得REF的代码跟自己没有关系.
> 因此, 如果你具备了阅读开源软件代码的能力, 是可以把Spike作为REF的. -->




> #### todo::Add DiffTest Support to NPC
> DiffTest is a powerful tool for processor debugging. It is wise to set up DiffTest for NPC before implementing more instructions in it.
> Here, the DUT is NPC, and the REF is NEMU. To do this, you need to:
> * Implement the DiffTest API in `nemu/src/cpu/difftest/ref.c`, including `difftest_memcpy()`,
>   `difftest_regcpy()` and `difftest_exec()`. In addition, `difftest_raise_intr()` is prepared for interrupts and is not used currently.
> * Select the shared library as the compilation target in NEMU's menuconfig:
> ```
> Build target (Executable on Linux Native)  --->
>   (X) Shared object (used as REF for differential testing)
> ```
> * Recompile NEMU. After successful compilation, the dynamic library file `nemu/build/riscv32-nemu-interpreter-so` will be generated.
> * Link the above dynamic library file in the simulation environment of NPC through dynamic linking to implement the DiffTest function via its API.
>   You can refer to the relevant code of NEMU for details.
>
> Try to run the dummy program correctly in NPC with the DiffTest mechanism enabled.
> To check if the DiffTest mechanism works, you can inject an error into the implementation of the `addi` instruction in NPC and
> observe whether DiffTest can report this error as expected.
>
> Note that you need to modify the compilation target in NEMU's menuconfig to recompile NEMU into an ELF.

> #### comment::Can I choose Spike as the REF?
> Considering that NEMU is simpler to implement than Spike and that everyone is more familiar with it, we still recommend using your own NEMU as the REF.
> Someday you will need to add some personalized features to the REF to help you debug,
> and we don't want you to feel that the REF code has nothing to do with you.
> Therefore, if you have the ability to read open-source software code, you can use Spike as the REF.










<!-- ## 实现RV32E指令集

为了编译出RV32E的程序, 我们还要在AM中搭建相应的AM运行时环境.
AM项目已经提供了`riscv32e-npc`的基本框架, 你需要在这个基础上进行一些完善工作.
不过你之前已经搭建过`minirv-npc`的AM了, 因此这对你来说并不困难.

> #### todo::搭建riscv32e-npc的AM
> 你需要完成如下内容:
> * 为`riscv32e-npc`提供`run`目标, 从而支持一键编译程序并仿真.
> * 实现`riscv32e-npc`中的`halt()`函数, 从而通知NPC的仿真环境结束仿真,
>   并让其得知程序的运行结果是否正确.

准备好这些基础设施之后, 你就可以方便地在NPC中实现更多的RV32E指令了.
这些指令你已经在NEMU中都实现过了, 但在RTL中实现它们, 还需要注意一些细节:
* 计算指令: 这部分指令的执行主要是ALU单元完成的, 你已经在数字电路实验接触过它们了. 具体地
  * 加减法运算 - 在之前实现`addi`指令的时候, 你已经实现补码加法了.
    在电路中, 补码减法可以通过补码加法来实现.
    在RISC-V中, 加减法指令都无需判断进位和溢出
  * 逻辑运算 - 这个很简单
  * 移位运算 - 这个也不难, 直接用运算符就可以实现
  * 比较运算 - 可以归约到减法运算, 通过判断减法运算的结果来得出比较运算的结果
* 分支指令: 可以通过ALU中的减法运算来计算分支是否跳转 -->




## Implementing the RV32E Instruction Set

To compile programs for RV32E, we need to set up a corresponding AM runtime environment in AM.
The AM project already provides a basic framework for `riscv32e-npc`, and you need to perform some improvements based on this framework.
However, since you have already set up the AM for `minirv-npc` before, this should not be difficult for you.

> #### todo::Set up AM for riscv32e-npc
> You need to complete the following:
> * Provide a `run` target for `riscv32e-npc` to support one-click program compilation and simulation.
> * Implement the `halt()` function in `riscv32e-npc` to notify the NPC simulation environment to end the simulation,
>   and let it know whether the program's running result is correct.

After preparing these infrastructure components, you can conveniently implement more RV32E instructions in NPC.
You have already implemented these instructions in NEMU, but there are some details to note when implementing them in RTL:
* Arithmetic and logic instructions: The execution of these instructions is mainly completed by the ALU unit, which you have encountered in digital circuit experiments. Specifically:
  * Addition and subtraction operations - You have already implemented two's complement addition when implementing the `addi` instruction earlier.
    In circuits, two's complement subtraction can be implemented through two's complement addition.
    In RISC-V, addition and subtraction instructions do not need to judge carry and overflow.
  * Logical operations - These are straightforward.
  * Shift operations - These are also not difficult and can be implemented directly using operators.
  * Comparison operations - These can be reduced to subtraction operations, and the result of the comparison operation is obtained by judging the result of the subtraction operation.
* Branch instructions: The decision of whether a branch jumps can be calculated through subtraction operations in the ALU.










<!-- 

> #### question::硬件如何区分有符号数和无符号数?
> 尝试编写以下程序:
> ```c
> #include <stdint.h>
> int32_t fun1(int32_t a, int32_t b) { return a + b; }
> uint32_t fun2(uint32_t a, uint32_t b) { return a + b; }
> ```
> 然后编译并查看反汇编代码:
> ```bash
> riscv64-linux-gnu-gcc -c -march=rv32g -mabi=ilp32 -O2 test.c
> riscv64-linux-gnu-objdump -d test.o
> ```
> 这两个函数有什么不同? 思考一下这是为什么?

> #### todo::如果你是初学者, 尝试自己画出架构图
> 如果你是处理器设计的初学者, 尝试画出一个完整的单周期处理器架构图.

> #### option::观察ALU的综合结果
> 尝试使用`yosys-sta`项目对ALU进行综合, 观察综合结果, 回答如下问题:
> 1. 我们知道, 补码减法可以用加法器来实现,
>    而比较指令和分支指令本质上也需要通过补码减法来实现.
>    如果我们在RTL代码中直接编写`-`或`<`等各种运算符,
>    yosys能否自动将它们的减法功能合并为同一个加法器?
> 1. 移位运算符`<<`和`>>`被yosys综合成什么电路?
> 1. yosys从运算符直接综合出电路是否有改进的空间?
>
> Hint: 如果你觉得32位数据的综合结果难以阅读,
> 可以考虑先观察并分析16位, 8位甚至4位数据的综合结果. -->

> #### question::How does hardware distinguish between signed and unsigned numbers?
> Try writing the following program:
> ```c
> #include <stdint.h>
> int32_t fun1(int32_t a, int32_t b) { return a + b; }
> uint32_t fun2(uint32_t a, uint32_t b) { return a + b; }
> ```
> Then compile and view the disassembly:
> ```bash
> riscv64-linux-gnu-gcc -c -march=rv32g -mabi=ilp32 -O2 test.c
> riscv64-linux-gnu-objdump -d test.o
> ```
> What's the difference between these two functions? Think about why this is the case.

> #### todo::If you're a beginner, try drawing the architecture diagram yourself
> If you're new to processor design, try drawing a complete single-cycle processor architecture diagram.

> #### option::Observe the synthesis results of the ALU
> Try synthesizing the ALU using the `yosys-sta` project, observe the synthesis results, and answer the following questions:
> 1. We know that two's complement subtraction can be implemented with an adder,
>    and comparison instructions and branch instructions also essentially need to use two's complement subtraction.
>    If we directly write various operators like `-` or `<` in RTL code,
>    can yosys automatically merge their subtraction functions into the same adder?
> 1. What circuits do the shift operators `<<` and `>>` get synthesized into by yosys?
> 1. Is there room for improvement when yosys synthesizes circuits directly from operators?
>
> Hint: If you find the synthesis results for 32-bit data difficult to read,
> you can consider first observing and analyzing the synthesis results for 16-bit, 8-bit, or even 4-bit data.









<!-- 
> #### todo::在NPC中正确运行之前的所有测试
> 有了基础设施的强大帮助, 你应该可以很容易地正确实现支持RV32E的NPC了.
> 实现后, 尝试将之前运行的所有测试重新编译到`riscv32e-npc`, 然后在NPC上运行它们.

> #### comment::RV32E不包含乘除指令, NPC如何正确运行包含乘除法操作的C程序?
> 这是因为RISC-V指令集是模块化的, gcc可以根据指令集是否包含M扩展决定如何编译乘除法操作.
> 若指令集中不包含M扩展, gcc将会把乘除法操作编译成形如``__mulsi3()``的函数调用,
> 这些函数用于提供整数算术运算操作的软件模拟版本, 即用加减操作计算出乘除法的结果.
> 这些函数声明可参考[这个页面][libgcc], 它们的函数体在函数库libgcc中,
> 通常在链接过程会将libgcc链接到ELF可执行文件中.
>
> 我们将libgcc中一些常见的整数乘除运算操作对应的软件模拟函数移植到`riscv32e-npc`中,
> 因此可以编译出不包含乘除法指令也能正确进行乘除法操作的ELF可执行文件.

[libgcc]: https://gcc.gnu.org/onlinedocs/gccint/Integer-library-routines.html -->


> #### todo::Run all previous tests correctly on NPC
> With the strong support of the infrastructure, you should be able to easily and correctly implement NPC supporting RV32E.
> After implementation, try recompiling all previously run tests for `riscv32e-npc` and then run them on NPC.

> #### comment::RV32E does not include multiply and divide instructions. How can NPC correctly run C programs containing multiplication and division operations?
> This is because the RISC-V instruction set is modular, and gcc can decide how to compile multiplication and division operations based on whether the instruction set includes the M extension.
> If the instruction set does not include the M extension, gcc will compile multiplication and division operations into function calls such as ``__mulsi3()``.
> These functions are used to provide software-emulated versions of integer arithmetic operations, that is, to calculate the results of multiplication and division using addition and subtraction operations.
> The declarations of these functions can be referred to on [this page][libgcc], and their function bodies are in the library libgcc.
> Usually, libgcc is linked into the ELF executable file during the linking process.
>
> We have ported some common software-emulated functions corresponding to integer multiplication and division operations in libgcc to `riscv32e-npc`.
> Therefore, we can compile ELF executable files that can correctly perform multiplication and division operations without including multiply and divide instructions.

[libgcc]: https://gcc.gnu.org/onlinedocs/gccint/Integer-library-routines.html









<!-- > #### caution::解放思想, 使用正确的工具做事情
> 有同学提出这样的疑问: 为什么要自己折腾verilator和Makefile这些, 明明用modelsim点一个按钮就好了.
> 这是因为, 仅仅使用波形进行调试, 并不是科学的方法.
> 对于`cpu-tests`这些规模很小的程序, 即使你坚持用波形调试, 你也可以存活下来;
> 但随着程序的规模越来越大, 调试效率将会越来越低:
> 如果仿真1亿个周期后出错, 你将要如何在波形中找到错误?
>
> 但大部分同学之前并未思考过如何提升调试的效率.
> 事实上, 这并不是因为大家没有能力(例如trace本质上就是一行`printf()`),
> 而是因为各种不专业的想法束缚了大家:
> * 我不是计算机系的, 软件跟我没关系
> * 我来写硬件的, 软件的部分随便糊弄一下就行
> * 现在公司都用quartus/vivado, "一生一芯"用verilator已经不符合时代发展的潮流
>
> 这些想法会让大家本能地拒绝接触软件领域的思想.
> 例如, 在龙芯杯比赛中, 成功启动Linux是系统展示环节的巅峰成果,
> 然而从比赛结果来看, 并不是每一支参赛队伍都能成功攀登这一巅峰.
> 但我们相信, 只要学会使用正确的工具, 人人都可以在合理的时间内在自己设计的CPU上成功启动Linux.
> 例如, 在时长为3个月的第三期"一生一芯"中, 就有一位之前从未设计过CPU的电子系同学,
> 以一人之力成功在自己的CPU上启动了Linux Debian.
> 事实上, 即使是写一个很小的脚本, 有时候都会大幅提升你的工作效率.
> 相比于坚持传统方法, 了解, 借鉴并吸收其它领域的先进方法, 可以让你变得更强大.

> #### flag::如果你是初学者, 现在可以来看看教科书上的架构图了
> 如果你是处理器设计的初学者, 尝试对比自己画的单周期处理器架构图与书上架构图的异同.
> 思考一下, 两者的架构孰优孰劣? 为什么? -->




> #### caution::Emancipate your mind and use the right tools for the job
> Some students have asked: Why bother with tools like Verilator and Makefile when you can just click a button in ModelSim?
> This is because relying solely on waveforms for debugging is not a scientific approach.
> For small-scale programs like `cpu-tests`, you can get by even if you insist on debugging with waveforms;
> but as the scale of programs grows, debugging efficiency will drop drastically:
> If an error occurs after 100 million cycles of simulation, how will you find the error in the waveform?
>
> However, most students have not previously thought about how to improve debugging efficiency.
> In fact, this is not because of a lack of ability (for example, a trace is essentially just a `printf()` statement),
> but because they are constrained by various unprofessional mindsets:
> * I'm not from the computer science department, so software has nothing to do with me.
> * I'm here to work on hardware; the software part can be just phoned in.
> * Companies now use Quartus/Vivado; using Verilator in "One Student, One Chip" is outdated.
>
> These mindsets make people instinctively resist engaging with ideas from the software field.
> For example, in the Loongson Cup competition, successfully booting Linux is the pinnacle achievement in the system demonstration part.
> Yet, judging from the results, not every participating team can reach this peak.
> But we believe that as long as you learn to use the right tools, anyone can successfully boot Linux on a self-designed CPU within a reasonable time.
> For instance, in the third phase of "One Student, One Chip" (which lasted 3 months), an electronics student who had never designed a CPU before
> successfully booted Linux Debian on his own CPU by himself.
> In fact, even writing a small script can sometimes significantly improve your work efficiency.
> Rather than clinging to traditional methods, understanding, learning from, and absorbing advanced methods from other fields can make you stronger.

> #### flag::If you're a beginner, you can now look at the architecture diagrams in textbooks
> If you're new to processor design, try comparing the single-cycle processor architecture diagram you drew with the ones in textbooks.
> Think about it: which architecture is better, and why?
