<!-- # F4 计算机系统的状态机模型 -->
# F4 State Machine Model of Computer Systems

<!-- 在进一步学习如何设计处理器之前, 我们先来了解处理器工作的基本原理.
不过我们暂时不会从数字电路的视角来介绍处理器,
而是通过一个不那么严谨的数学模型来阐释一些和处理器相关的重要概念.
因此, 你可以先暂时忘记上一节学习的数字电路知识了.
处理器和数字电路确实有密不可分的联系, 我们将再下一节介绍如何通过数字电路来实现处理器.
但目前, 你只需要准备纸和笔就足够了. -->
Before we further study how to design processors, let's first understand the basic principles of how processors work. However, we will not introduce processors from the perspective of digital circuits for the time being.Instead, we will explain some important concepts related to processors through a less rigorous mathematical model. Therefore, you can temporarily set aside the digital circuit knowledge you learned in the previous section.Processors and digital circuits are indeed closely related. In the next section, we will discuss how to implement processors using digital circuits.For now, all you need is paper and a pen.

<!-- ## 处理器的组成和工作原理 -->
## The Composition and Working Principle of Processors

<!-- 计算机是一个机械地进行数据处理的装置,
这里的"机械"是指其原理可以很直白地理解, 并无神秘之处.
中央处理器(CPU)作为计算机的大脑, 其实也是这样的装置. -->
A computer is a device that mechanically processes data.
Here, 'mechanically' refers to the fact that its principles are straightforward and easy to understand. The central processing unit (CPU), which acts as the brain of the computer, is also such a device.

<!-- ### 指令及其编码 -->
### Instructions and Their Codes

<!-- 你应该都接触过电子计算器, 现代计算器至少可以进行加, 减, 乘, 除的四则运算. -->
<!-- 处理器的功能远比电子计算器要强大, 作为处理数据的装置, 其处理方式肯定不只一种.
另外, 既然处理器是一个机械地进行数据处理的装置, 它要做何种处理,
就应该是受到某种方式的控制, 而不存在可以自己思考的智能.
这种控制的处理器的媒介, 就是指令.
例如, 我们可以通过加法指令来控制处理器对两个数据相加,
这和我们在电子计算器中输入`1+2=`来控制它是非常类似的. -->
You should all be familiar with electronic calculators. Modern calculators can perform at least the four arithmetic operations of addition, subtraction, multiplication, and division. The functionality of a processor far exceeds that of an electronic calculator. As a device for processing data, its processing methods are certainly not limited to a single approach. Additionally, since a processor is a device that mechanically processes data, the type of processing it performs should be controlled by some means, and it does not possess the ability to think independently. The medium for controlling the processor is instructions. For example, we can use an addition instruction to control the processor to add two pieces of data together.This is very similar to entering `1+2=` on an electronic calculator to control it.

<!-- 要"用加法指令来控制处理器对两个数据进行相加", 说明一条指令需要给出两方面的信息:
一方面, 计算机需要处理的数据有很多,
因此指令中需要指定需要处理哪些数据, 这称为指令的"操作数"(operand)字段;
另一方面, 计算机处理数据的方式也有很多种,
因此指令中也需要指定用何种方式处理数据, 这称为指令的"操作码"(opcode)字段. -->
To 'use an addition instruction to control the processor to add two pieces of data', it means that an instruction needs to provide two types of information:
On one hand, there are many types of data that a computer needs to process,
so the instruction must specify which data to process, which is referred to as the 'operand' field of the instruction;
On the other hand, there are also many ways for a computer to process data,
so the instruction must also specify the method of data processing, which is referred to as the 'opcode' field of the instruction.

```
+--------+---------------+
| opcode |    operand    |
+--------+---------------+
```

<!-- 注意到有些数据处理的中间结果应该保存起来供后续使用,
因此处理器中应该有一些部件能够保存处理的数据, 这就是寄存器.
为了方便存放数据, 通常来说这样的寄存器不只一个,
而是由多个寄存器组成一个"寄存器组"(Register Set,
有的教科书也称其为"寄存器堆", 英文为Register File).
由于这样的寄存器组用于处理一般数据,
因此也称其为通用寄存器(General Purpose Register, GPR).
相对地, 有一些寄存器的功能并非用于处理一般处理, 它们不属于GPR. -->
It has been noted that some intermediate results of data processing should be saved for subsequent use.
Therefore, the processor should have components capable of storing processed data, which are known as registers.
For the convenience of storing data, there is usually more than one such register,
but rather a group of registers called a 'Register Set' (
some textbooks also refer to it as a 'Register File').
Since such a register set is used for processing general data,
these registers are also referred to as general purpose registers (GPR).
In contrast, some registers are not designed for general-purpose processing and do not belong to the GPR category.

<!-- 例如, 要计算`1+2+...+10`, 但一条加法指令只能计算两个数据相加的结果,
因此需要将`1+2`的结果保存在GPR中的某个寄存器`r`中, 然后计算`r+3`等等.
这样, 指令就需要在操作数字段中指定从哪个GPR中读出数据, 以及将计算结果存回哪个GPR中.
至于操作码, 处理器只需要约定好每种操作码代表何种操作即可.

处理器作为一个数字电路, 所有信息都可以用`0`和`1`来表示, 指令也不例外.
例如, 某简单处理器有4个GPR, 支持3种指令, 其中2种如下: -->
For example, to calculate `1+2+...+10`, but a single addition instruction can only calculate the sum of two data items, so the result of `1+2` needs to be stored in a register `r` in the GPR, and then `r+3` is calculated, and so on.
In this way, the instruction needs to specify in the operand field which GPR to read the data from and which GPR to store the calculation result in.
As for the opcode, the processor only needs to agree on what each opcode represents.

As a digital circuit, the processor can represent all information using `0` and `1`, and instructions are no exception.
For example, a simple processor with 4 GPRs supports 3 types of instructions, two of which are as follows:
<!-- ```
 7  6 5  4 3   2 1   0
+----+----+-----+-----+
| 00 | rd | rs1 | rs2 | R[rd]=R[rs1]+R[rs2]    add指令, 寄存器相加
+----+----+-----+-----+
| 10 | rd |    imm    | R[rd]=imm              li指令, 装入立即数, 高位补0
+----+----+-----+-----+
``` -->
```
 7  6 5  4 3   2 1   0
+----+----+-----+-----+
| 00 | rd | rs1 | rs2 | R[rd]=R[rs1]+R[rs2]    add instruction, add two registers together
+----+----+-----+-----+
| 10 | rd |    imm    | R[rd]=imm              li instruction, load immediate value, fill high bits with zeros
+----+----+-----+-----+
```

<!-- 由于指令只有3种, 因此最少可以用2位操作码就能区分所有指令.
在上述例子中, 操作码是`00`, 表示`add`指令; 操作码是`10`, 表示`li`指令.
为了方便叙述, 指令通常有相应的名称, 如`add`指令和`li`指令. -->
Since there are only three types of instructions, a minimum of two opcodes can be used to distinguish between all instructions.
In the above example, the opcode is `00`, which represents the `add` instruction; the opcode is `10`, which represents the `li` instruction.
For convenience, instructions usually have corresponding names, such as the `add` instruction and the `li` instruction.

<!-- 关于操作数, 因为GPR只有4个, 因此可以用2位来指定一个GPR的地址(`00`, `01`, `10`, `11`).
操作数据的来源称为"源寄存器", 上述的`add`指令需要从两个源寄存器中获取加数,
两个源寄存器的地址分别记为`rs1`和`rs2`, 分别用`R[rs1]`和`R[rs2]`来表示GPR中存放的内容;
操作需要写入的目的称为"目的寄存器", 一般记为`rd`.
其中, 第2条`li`指令的操作数稍有不同, 其源操作数不再是GPR,
而是直接将指令中的`imm`字段解析成一个二进制数来使用, 这种操作数称为"立即数". -->
Regarding operands, since there are only 4 GPRs, a 2-bit number can be used to specify the address of a GPR (`00`, `01`, `10`, `11`).
The source of the operand data is called the 'source register.' The above `add` instruction requires two source registers to obtain the addends, with the addresses of the two source registers denoted as `rs1` and `rs2`, respectively, and the contents stored in the GPRs represented as `R[rs1]` and `R[rs2]`;
The destination where the operation is written is called the 'destination register', generally denoted as `rd`. Among these, the second `li` instruction has a slightly different operand format. Its source operand is no longer a GPR,
but is directly parsed from the `imm` field in the instruction into a binary number for use. This type of operand is called an 'immediate operand'.

<!-- 综上, 上述指令的长度都是8位.
我们可以根据上述的指令编码规则来理解一条指令的含义,
一些具体的指令例子如下: -->
In summary, the length of the above instructions is 8 bits.
We can understand the meaning of an instruction based on the above instruction encoding rules.
Some specific instruction examples are as follows:
<!-- ```
00100001   add指令, 将R[0]和R[1]相加, 结果写入R[2]
10110000   li指令, 将立即数0000写入R[3]
10000101   li指令, 将立即数0101写入R[0]
``` -->
```
00100001   add instruction, add R[0] and R[1], and write the result to R[2]
10110000   li instruction, write the immediate value 0000 to R[3]
10000101   li instruction, write the immediate value 0101 to R[0]
```

<!-- ### 存储程序 -->
### Stored-Program

<!-- 事实上, 在我们认识中几乎无所不能的计算机,
就是靠不断执行一条条指令来完成各种复杂任务的.
你在计算机上运行的各种软件程序, 最终也是在执行一条条的指令.
因此, 程序的本质就是一段指令序列.
说起来你可能不信, 毕竟上面这些指令的行为非常简单, 和电子计算器没什么区别,
那计算机凭什么能比电子计算器强大那么多呢? -->
In fact, computers, which we believe to be almost omnipotent,
complete various complex tasks by continuously executing a series of instructions. The various software programs you run on your computer are ultimately executing a series of instructions. Therefore, the essence of a program is a sequence of instructions. You may find it hard to believe, because the above instructions are very simple and no different from those of an electronic calculator. So why are computers so much more powerful than electronic calculators?

<!-- 答案在于计算机的工作机制: 它可以让程序来自动控制计算机的执行.
具体地, 我们可以先把一段指令序列放在存储器(如现代计算机的内存)中,
让计算机从内存中取出指令来执行;
重要的是, 当计算机执行完一条指令之后, 就继续执行下一条指令.
为了能让计算机知道下一条指令在哪里, 还需要有一个用于指示当前执行到哪条指令的部件,
这个部件称为“程序计数器”(Program Counter, PC). -->
The answer lies in how computers work: they allow programs to automatically control the computer's execution. Specifically, we can first store a sequence of instructions in memory (such as the RAM of modern computers), and have the computer fetch instructions from memory to execute; crucially, after the computer completes executing one instruction, it proceeds to execute the next instruction. To enable the computer to know where the next instruction is located, there must also be a component that indicates which instruction is currently being executed, this component is called the 'Program Counter' (PC).

<!-- 从此以后, 计算机只需要做一件事情: -->
From now on, computers only need to do one thing:
<!-- ```
重复以下步骤:
  从PC指示的存储器位置取出指令
  执行指令
  更新PC
``` -->
```
Repeat the following steps:
  Fetch the instruction from the memory location indicated by the PC.
  Execute the instruction.
  Update the PC.
```
<!-- 这样, 我们只要将一段指令序列放置在存储器中,
然后让PC指向第一条指令, 计算机就会自动执行这一段指令序列, 永不停止.
这就是"存储程序"(Stored-Program)的基本思想.
如今的各种主流计算机, 本质上都是"存储程序"计算机. -->
In this way, we only need to place a sequence of instructions in the memory,
then let the PC point to the first instruction, and the computer will automatically execute this sequence of instructions without stopping.
This is the basic idea of 'Stored-Program' computers.
Today's mainstream computers are essentially all 'Stored-Program' computers.

<!-- 还有更巧妙的设计!
既然PC存储了当前执行指令的位置, 那PC也应该是一个寄存器,
这样的话, 我们还可以设计相应的指令来修改它, 从而增加程序执行过程的灵活性.
例如, 我们可以在上文提到的2条指令的基础上, 再添加第3条指令: -->
There is an even more ingenious design!
Since the PC stores the location of the currently executing instruction, the PC should also be a register.
In this case, we can also design corresponding instructions to modify it, thereby increasing the flexibility of the program execution process.
For example, we can add a third instruction based on the two instructions mentioned above:
<!-- ```
 7  6 5         2 1  0
+----+---- -----+-----+
| 11 |   addr   | rs2 | if (R[0]!=R[rs2]) PC=addr bner0指令, 若不等于R[0]则跳转
+----+----------+-----+
``` -->
```
 7  6 5         2 1  0
+----+---- -----+-----+
| 11 |   addr   | rs2 | if (R[0]!=R[rs2]) PC=addr bner0 instruction, if not equal to R[0], jump
+----+----------+-----+
```
<!-- 这条`bner0`指令十分特殊, 它是`Branch if Not Equal r0`的缩写,
如果执行这条指令的时候`R[rs2]`与`R[0]`不相等,
则将PC寄存器更新为`addr`, 即让PC指向`addr`处的指令.
不过, PC寄存器并不是用于处理一般数据, 因此它不属于GPR.

有了上面这些指令, 我们就可以让计算机做一些不简单的事情了. -->
The `bner0` instruction is quite special; it stands for `Branch if Not Equal r0`. If `R[rs2]` and `R[0]` are not equal when this instruction is executed, the PC register is updated to `addr`, meaning that the PC points to the instruction at `addr`.  However, the PC register is not used to process general data, so it does not belong to the GPR.

With these instructions, we can now have the computer perform some more complex tasks.

<!-- ### 一个数列求和的例子 -->
### An Example of Summing a Sequence of Numbers

<!-- 让我们用指令来计算`1+2+...+10`这一数列的和.
为了方便理解, 我们先不采用`0`和`1`来表示指令.
我们用`r0`, `r1`, `r2`和`r3`分别指代4个GPR, 并且用逗号来分隔指令的操作数.
假设以下指令序列存放在存储器中, 用于计算上述数列之和,
其中`:`前的数字表示PC, `#`及其后的文字表示注释: -->
Let's use instructions to calculate the sum of the sequence `1+2+...+10`. For ease of understanding, we will not use `0` and `1` to represent instructions. We will use `r0`, `r1`, `r2`, and `r3` to represent the four GPRs, and use commas to separate the operands of the instructions. Assume the following instruction sequence is stored in memory to calculate the sum of the above sequence, where the number before `:` represents the program counter (PC), and the text following `#` represents a comment:
<!-- ```
0: li r0, 10   # 这里是十进制的10
1: li r1, 0
2: li r2, 0
3: li r3, 1
4: add r1, r1, r3
5: add r2, r2, r1
6: bner0 r1, 4
7: bner0 r3, 7
``` -->
```
0: li r0, 10   # This is decimal 10.
1: li r1, 0
2: li r2, 0
3: li r3, 1
4: add r1, r1, r3
5: add r2, r2, r1
6: bner0 r1, 4
7: bner0 r3, 7
```

<!-- 乍眼一看, 你可能很难理解上面的指令序列如何实现数列求和.
让我们来把自己当作处理器, 通过执行一条条指令来理解这个过程.
为了理解指令执行的过程, 我们还需要记录寄存器的变化.
我们用`(PC, r0, r1, r2, r3)`的格式来记录寄存器的值,
这一格式也反映了处理器所处的状态.
例如`(7, 2, 3, 1, 8)`表示接下来将要执行编号为`7`的指令,
当前4个GPR的值分别为`2`, `3`, `1`, `8`.
我们约定在开始的时刻, 处理器的状态是`(0, 0, 0, 0, 0)`.
以下是处理器执行前若干条指令的过程: -->
At first glance, you may find it difficult to understand how the above instruction sequence implements the summation of a sequence. Let's imagine ourselves as a processor and understand the process by executing each instruction one by one. To understand the process of instruction execution, we also need to record the changes in the registers. We use the format `(PC, r0, r1, r2, r3)` to record the values of the registers, which also reflects the state of the processor. For example, `(7, 2, 3, 1, 8)` indicates that the next instruction to be executed is numbered `7`, and the current values of the four GPRs are `2`, `3`, `1`, and `8`. We agree that at the start, the processor's state is `(0, 0, 0, 0, 0)`. The following is the process of the processor executing several instructions:

<!-- ```
PC r0 r1 r2 r3
(0, 0, 0, 0, 0)   # 初始状态
(1, 10, 0, 0, 0)  # 执行PC为0的指令后, r0更新为10, PC更新为下一条指令的位置
(2, 10, 0, 0, 0)  # 执行PC为1的指令后, r1更新为0, PC更新为下一条指令的位置
(3, 10, 0, 0, 0)  # 执行PC为2的指令后, r2更新为0, PC更新为下一条指令的位置
(4, 10, 0, 0, 1)  # 执行PC为3的指令后, r3更新为1, PC更新为下一条指令的位置
(5, 10, 1, 0, 1)  # 执行PC为4的指令后, r1更新为r1+r3, PC更新为下一条指令的位置
(6, 10, 1, 1, 1)  # 执行PC为5的指令后, r2更新为r2+r1, PC更新为下一条指令的位置
(4, 10, 1, 1, 1)  # 执行PC为6的指令后, 因r1不等于r0, 故PC更新为4
(5, 10, 2, 1, 1)  # 执行PC为4的指令后, r1更新为r1+r3, PC更新为下一条指令的位置
......
``` -->
```
PC r0 r1 r2 r3
(0, 0, 0, 0, 0)   # initial state
(1, 10, 0, 0, 0)  # After executing the instruction with PC = 0, r0 is updated to 10, and PC is updated to the location of the next instruction.
(2, 10, 0, 0, 0)  # After executing the instruction with PC = 1, r1 is updated to 0, and PC is updated to the location of the next instruction.
(3, 10, 0, 0, 0)  # After executing the instruction with PC = 2, r2 is updated to 0, and PC is updated to the location of the next instruction.
(4, 10, 0, 0, 1)  # After executing the instruction with PC = 3, r3 is updated to 1, and PC is updated to the location of the next instruction.
(5, 10, 1, 0, 1)  # After executing the instruction with PC = 4, r1 is updated to r1 + r3, and PC is updated to the location of the next instruction.
(6, 10, 1, 1, 1)  # After executing the instruction with PC = 5, r2 is updated to r2 + r1, and PC is updated to the location of the next instruction.
(4, 10, 1, 1, 1)  # After executing the instruction with PC = 6, since r1 does not equal r0, PC is updated to 4.
(5, 10, 2, 1, 1)  # After executing the instruction with PC = 4, r1 is updated to r1 + r3, and PC is updated to the location of the next instruction.
......
```

<!-- > #### todo::继续执行上述指令 -->
<!-- > 尝试继续执行指令, 记录寄存器的状态变化过程.
> 你发现执行到最后时, 处理器处于什么样的状态?
> 上述数列的求和结果在哪个寄存器中? -->
> #### todo::Continue to implement the above instructions.
> Try to continue executing the instructions and record the changes in the register states.
> What state is the processor in when the execution is complete?
> In which register is the sum of the above sequence stored?

<!-- 可以看到, 处理器的工作过程就是按照指令的含义机械地更新寄存器的状态.
到此为止, 你已经理解处理器工作的基本原理了. -->
As you can see, the processor works by mechanically updating the status of the registers according to the meaning of the instructions. At this point, you have understood the basic principles of how a processor works.

<!-- 事实上, 计算机的优势在于其极快的运算速度: 现代处理器的主频已经到GHz量级了,
以2GHz为例, 这意味着处理器在1秒内会经过2000000000个时钟周期.
而用上述指令序列计算`1+2+...+10`只需要不到40条指令,
如果按每周期执行1条指令来计算, 现代处理器只需要花费0.00000002s, 即20ns, 即可完成计算.
如果我们人工按电子计算器, 1秒按10个键已经算是手速非常快了,
但输入`1+2+...+10=`需要按22次按键, 算下来也需要2s.
如果要计算`1+2+...+10000`, 我们只需要将上述PC为0的指令改为`li r0, 10000`即可
(不过需要更长的指令来表示`10000`这个立即数),
按同样的方式计算, 需要执行约30000条指令, 也只需要花费0.000015s, 即15us.
如果人工按电子计算器, 则需要按48894次按键, 算下来需要4889s!
即使我们用等差数列的求和公式心算(`(10000 + 1) * 10000 / 2`), 也需要若干秒才能算出正确答案,
和强大的计算机相比可谓是相形见绌. -->
In fact, the advantage of computers lies in their extremely fast processing speed: the clock speed of modern processors has reached the GHz level. Taking 2GHz as an example, this means that the processor undergoes 2,000,000,000 clock cycles in one second. Using the aforementioned instruction sequence to calculate `1+2+...+10` requires fewer than 40 instructions. If we assume one instruction is executed per cycle, a modern processor would only need 0.00000002 s, or 20 ns, to complete the calculation. If we were to manually use an electronic calculator, pressing 10 keys per second would already be considered very fast,but entering `1+2+...+10=` would require 22 key presses, which would take approximately 2 seconds. To calculate `1+2+...+10000`, we simply need to modify the above instruction with a PC of 0 to `li r0, 10000`. (though a longer instruction is needed to represent the immediate value `10000`), and using the same method, it would take approximately 30,000 instructions, which would only take 0.000015 s, or 15 us. If done manually on an electronic calculator, it would require pressing the keys 48,894 times, which would take 4,889 seconds! Even if we use the formula for the sum of an arithmetic sequence (`(10,000 + 1) * 10,000 / 2`) to calculate mentally, it would still take several seconds to arrive at the correct answer, which pales in comparison to the power of a computer.

<!-- ### 重新审视编程 -->
### Rethinking Programming

<!-- 你之前可能接触过编程语言, 但应该很少思考编程的本质.
所谓编程, 实际上是利用给定功能的组合来完成复杂任务的过程.
大家可能接触过C++, Python, Scratch等编程语言, 这些都属于高级编程语言.
而上述通过指令的组合来实现数列求和的例子, 其实也是编程! -->
You may have been exposed to programming languages before, but you probably haven't thought much about the essence of programming. Programming is actually the process of completing complex tasks by combining given functions. You may have been exposed to programming languages such as C++, Python, and Scratch, which are all high-level programming languages. The example above, which uses a combination of instructions to calculate the sum of a sequence, is also programming!

<!-- 上述的`add`和`li`等指令, 在计算机领域里面属于汇编语言的范畴.
汇编语言是指令的符号化表示.
与汇编语言相比, 还有更底层的机器语言, 它就是指令的二进制表示,
可以被通过数字电路实现的处理器直接执行.
例如, 上述数列求和程序的机器语言表示如下: -->
The above instructions, such as `add` and `li`, belong to the category of assembly language in the field of computer science. Assembly language is a symbolic representation of instructions. Compared with assembly language, there is an even lower-level machine language, which is the binary representation of instructions. It can be directly executed by a processor implemented through digital circuits. For example, the machine language representation of the above sequence summation program is as follows:

```
10001010    # 0: li r0, 10
10010000    # 1: li r1, 0
10100000    # 2: li r2, 0
10110001    # 3: li r3, 1
00010111    # 4: add r1, r1, r3
00101001    # 5: add r2, r2, r1
11010001    # 6: bner0 r1, 4
11011111    # 7: bner0 r3, 7
```

<!-- 事实上, 上述机器语言表示就是根据前文约定的指令编码将汇编语言翻译成`0`和`1`的序列.
只要了解指令的编码规则, 汇编语言和机器语言可以互相转换.
不过如果只看机器语言, 程序员是很难理解的;
相比之下, 汇编语言能更直观地表示指令的操作码和操作数, 可读性比机器语言更好. -->
In fact, the above machine language representation translates assembly language into a sequence of `0`s and `1`s based on the instruction encoding agreed upon earlier. As long as you understand the encoding rules for instructions, assembly language and machine language can be converted back and forth. However, it is difficult for programmers to understand machine language on its own. In contrast, assembly language can represent instruction opcodes and operands more intuitively, making it more readable than machine language.

<!-- > #### todo::计算10以内的奇数之和
> 尝试用上述指令编写一个程序, 求出10以内的奇数之和, 即计算`1+3+5+7+9`.
> 编写后, 尝试列出处理器状态的变化过程, 以此来检查你编写的程序是否正确. -->
> #### todo::Calculate the Sum of Odd Numbers Less than 10.
> Try writing a program using the above instructions to calculate the sum of odd numbers less than 10, i.e., calculate `1+3+5+7+9`.
> After writing the program, try to list the changes in the processor status to check whether the program you wrote is correct.

<!-- ## 指令集架构的状态机模型 -->
##  State Machine Model of Instruction Set Architecture

<!-- 上文介绍的GPR, PC, 存储器, 指令及其执行过程,
在计算机领域中属于指令集架构(Instruction Set Architecture, 缩写为ISA, 也简称指令集)的范畴.
你可能听说过x86, ARM, RiSC-V等概念, 它们其实都是ISA.
上文提到的那个只有3条指令的例子, 其实也是一种ISA,
为了方便叙述, 我们将其称为sISA(simple ISA). -->
The aforementioned GPR, PC, memory, instructions, and their execution processes belong to the category of Instruction Set Architecture (ISA) in the field of computer science. You may have heard of concepts such as x86, ARM, and RISC-V; these are all examples of ISAs. The example mentioned earlier with only three instructions is also a type of ISA. For convenience, we refer to it as sISA (simple ISA).

<!-- ISA的本质是一系列规范, 这些规范通常记录在相应的手册中, 它们定义了一台模型机的功能和行为.
所谓的模型机就是一台只存在于思维中的机器,
我们只讨论其具备的功能和行为, 而不讨论其具体实现.
因此, 围绕模型机开展学习可以将原理和实现细节分离, 有助于大家理解处理器的本质.
等到我们把这台思维中的模型机通过数字电路实现出来, 我们就得到了一台真正的计算机. -->
The essence of ISA is a set of specifications, which are typically documented in corresponding manuals. These specifications define the functions and behaviour of a model machine. A model machine is a machine that exists only in the mind.  We discuss only its functions and behaviour, not its specific implementation.   Therefore by studying the model machine, we can separate principles from implementation details, which helps us understand the essence of a processor.  When we implement this model machine in our minds through digital circuits, we obtain a real computer.  

<!-- 在进一步解释ISA中具体包含什么之前,
我们先来介绍一个对我们理解计算机系统非常重要的数学模型: 状态机. -->
Before further explaining what ISA specifically includes, let's first introduce a mathematical model that is very important for our understanding of computer systems: the state machine.

<!-- 状态机的定义包含如下部分:
* 状态集合$S=\{S_1,S_2,\dots\}$
* 激励事件集合$E$
* 状态转移规则$next:S\times E\to S$
  * 描述每个状态在不同激励事件下的次态(next state),
    即二元函数$next(S, E)$给出了在状态$S$下接收到激励事件$E$后的次态
* 初始状态$S_0\in S$ -->
The definition of a state machine includes the following parts:
* State set $S=\{S_1,S_2,\dots\}$
* Event set $E$
* State transition rules $next:S\times E\to S$
  *    Describe the next state of each state under different events,
    i.e., the binary function $next(S, E)$ specifies the next state after receiving stimulus event $E$ while in state $S$
* Initial state $S_0\in S$

<!-- 虽然上述定义在数学意义上并非100%严谨, 但这对我们理解计算机系统的行为来说已经足够了. -->
Although the above definition is not 100% rigorous in a mathematical sense, it is sufficient for us to understand the behaviour of computer systems.

<!-- 现在我们来从状态机的视角去理解ISA:
* 状态集合. 回忆时序逻辑电路的相关内容, 状态是那些可以稳定存储信息的元素.
  对这个含义进行引申, 在ISA中, 状态应该包含PC, GPR和内存.
  也即, ISA中的一个状态是一组具体的PC, GPR和内存,
  而全体状态的集合$S$则是PC, GPR和内存所有取值的组合, 即$S=\{(PC, R, M)\}$.
* 激励事件集合. 在ISA中, 执行指令会改变状态, 因此执行指令就是这个状态机的激励事件.
* 状态转移规则. 按照定义, 在ISA中, 状态转移规则用于描述“在某个状态下执行某指令后的次态”,
  也即指令的语义, 它约定了执行某指令后, 状态应该发生怎么样的变化,
  从而从一个状态转移到另一个.
* 初始状态. 在未执行任何指令之前的状态. -->
Now let's understand ISA from the perspective of a state machine:
* State set. Recall the relevant content of sequential logic circuits: states are elements that can stably store information.  
  Extending this meaning, in ISA, states should include PC, GPR, and memory.
  That is, a state in the ISA is a specific combination of PC, GPR, and memory,   and the set of all states $S$ is the combination of all possible values of PC, GPR, and memory, i.e., $S=\{(PC, R, M)\}$.
* Set of events. In the ISA, executing an instruction changes the state, so executing an instruction is the event for this state machine.
* State transition rules. By definition, in the ISA, state transition rules describe the 'next state after executing a certain instruction in a given state,'
i.e., the semantics of the instruction. They specify how the state should change after executing a certain instruction,  
thereby transitioning from one state to another.
* Initial state. The state before any instructions have been executed.

<!-- 以上述的sISA为例, 其状态机模型如下:
* 状态集合$S=\{(PC, R, M)\}=\{(PC, r0, r1, r2, r3, M)\}$.
  例如, 在数列求和例子中, 某个状态
  $$\begin{array}{l}
  & S_k=(5, 10, 1, 0, 1, \\
  & [10001010, 10010000, 10100000, 10110001, \\
  & 00010111, 00101001, 11010001, 11011111])
  \end{array}$$
  其中$[\ ]$表示内存中存储的信息, 这里就是上文指令序列的编码.
  不过由于在sISA中, 指令并不会修改内存中存储的信息,
  为了简化表示, 我们可以省略状态中对内存的描述: $S_k=(5, 10, 1, 0, 1)$.
* sISA作为一种具体的ISA, 激励事件同样是执行指令.
* 在sISA中, 状态转移规则就是以下3条指令的语义: -->
Taking the aforementioned sISA as an example, its state machine model is as follows:
* State set $S=\{(PC, R, M)\}=\{(PC, r0, r1, r2, r3, M)\}$.
  For example, in the sequence summation example, a certain state
  $$\begin{array}{l}
  & S_k=(5, 10, 1, 0, 1, \\
  & [10001010, 10010000, 10100000, 10110001, \\
  & 00010111, 00101001, 11010001, 11011111])
  \end{array}$$
  where $[\ ]$ denotes the information stored in memory, which is the encoding of the instruction sequence mentioned earlier.
  However, since instructions in sISA do not modify the information stored in memory,
  to simplify the representation, we can omit the description of memory in the state: $S_k=(5, 10, 1, 0, 1)$.
* As a specific ISA, sISA also uses instruction execution as the event.
* In sISA, the state transition rules are the semantics of the following three instructions:
  <!-- ```
   7  6 5  4 3   2 1   0
  +----+----+-----+-----+
  | 00 | rd | rs1 | rs2 | R[rd]=R[rs1]+R[rs2]       add指令, 寄存器相加
  +----+----+-----+-----+
  | 10 | rd |    imm    | R[rd]=imm                 li指令, 装入立即数, 高位补0
  +----+----+-----+-----+
  | 11 |   addr   | rs2 | if (R[0]!=R[rs2]) PC=addr bner0指令, 若不等于R[0]则跳转
  +----+----------+-----+
  ``` -->
    ```
   7  6 5  4 3   2 1   0
  +----+----+-----+-----+
  | 00 | rd | rs1 | rs2 | R[rd]=R[rs1]+R[rs2]       add instruction, add two registers together
  +----+----+-----+-----+
  | 10 | rd |    imm    | R[rd]=imm                 li instruction, load immediate number, fill high bits with zeros
  +----+----+-----+-----+
  | 11 |   addr   | rs2 | if (R[0]!=R[rs2]) PC=addr bner0 instruction, if not equal to R[0], then jump
  +----+----------+-----+
  ```
  <!-- 例如, $S_{k+1}=next(S_k, 00101001)$表示,
  在状态为$S_k=(5, 10, 1, 0, 1)$时执行指令`00101001`后的次态为$S_{k+1}$.
  根据上文, 该指令的行为是`R[2] = R[2] + R[1]`, 因此$S_{k+1}=(6, 10, 1, 1, 1)$.
  这其实是上述数列求和例子执行过程中的其中一步. -->
  For example, $S_{k+1}=next(S_k, 00101001)$ means that
  when the state is $S_k=(5, 10, 1, 0, 1)$, executing the instruction `00101001` results in the next state $S_{k+1}$.
  According to the above, the behaviour of this instruction is `R[2] = R[2] + R[1]`, so $S_{k+1}=(6, 10, 1, 1, 1)$.
  This is actually one of the steps in the execution process of the above sequence summation example.
<!-- * 初始状态$S_0=(0, 0, 0, 0, 0)$. -->
* Initial state $S_0=(0, 0, 0, 0, 0)$.

<!-- > #### caution::人生如戏
> 我们在上文中已经用自然语言和数列求和的例子解释了计算机的工作原理.
> 我们之所以还要给大家介绍充满数学符号的状态机模型, 是为了帮助大家揭开计算机的神秘面纱:
> 计算机自从诞生以来, 其工作过程就是一个数学游戏, 状态机模型只不过是这个数学游戏的规则.
>
> 事实上, 无论是上面的指令集, 还是后面我们要介绍的程序和处理器,
> 这些计算机的核心概念在本质上都是一致的: 它们都是状态机这个数学游戏.
> 因此, 如果你已经掌握了上面的游戏规则, 你就已经做好了理解计算机的准备. -->
> #### caution::Life Is Like a Play.
> We have already explained how computers work using natural language and examples of summing sequences in the preceding text.
> The reason we are introducing the state machine model filled with mathematical symbols is to help you uncover the mystery of computers:
> Since their birth, the working process of computers has been a mathematical game, and the state machine model is simply the rules of this mathematical game.
>
> In fact, whether it is the instruction set mentioned above or the programs and processors we will introduce later,
> these core concepts of computers are fundamentally consistent: they are all part of the mathematical game known as the state machine.
> Therefore, if you have mastered the rules of the game mentioned above, you are already prepared to understand computers.

<!-- 而对于x86, ARM, RiSC-V这些商业级别的真实ISA,
它们的GPR数量更多, 指令数量更多, 指令行为也更复杂.
但其本质原理和上述只有3条指令的sISA并没有本质区别,
因此, 如果你将来需要理解它们, 你只需要阅读相应的手册, 了解更多指令的细节即可. -->
As for commercial-grade real ISAs such as x86, ARM, and RISC-V,
they have more GPRs, more instructions, and more complex instruction behaviour. However, their fundamental principles are essentially the same as those of the sISA with only three instructions mentioned above. Therefore, if you need to understand them in the future, you only need to read the corresponding manuals to learn more about the details of the instructions.

<!-- ## C程序入门 -->
## C Programming for Beginners

<!-- 上文介绍了汇编语言, 虽然采用汇编语言也可以编程,
但如果要开发更大的程序, 汇编语言就不方便了.
这是因为用汇编语言编程需要关注数据如何在GPR之间流动,
而且一条指令能进行的操作普遍很少, 即使是一段简单的程序逻辑,
可能都需要十几条指令才能表达.
事实上, 现代的程序开发通常采用高级编程语言. -->
The above section introduced assembly language. Although assembly language can be used for programming, it is inconvenient for developing larger programs. This is because programming in assembly language requires attention to how data flows between GPRs, and each instruction can generally perform only a few operations. Even a simple program logic may require dozens of instructions to express. In fact, modern program development typically uses advanced programming languages.

<!-- 高级编程语言有很多, 但我们选择C语言, 因为它在高级编程语言中属于比较简单的一类,
我们可以很容易将C语言与计算机系统的工作过程建立关联, 从而帮助我们理解计算机的本质. -->
There are many advanced programming languages, but we chose C because it is one of the simpler ones among high-level programming languages. We can easily associate C with the working process of computer systems, which helps us understand the essence of computers.

<!-- ### 一个简单的C语言示例 -->
### A Simple C Language Example

<!-- 让我们先来看一个简单的代码示例: -->
Let's start with a simple code example:
```c
/* 1 */ int main() {
/* 2 */   int x = 1;
/* 3 */   int y = 2;
/* 4 */   int z = x + y;
/* 5 */   printf("z = %d\n", z);
/* 6 */   return 0;
/* 7 */ }
 ```
<!-- 这个示例将计算`1+2`, 并输出计算结果.
我们对代码的细节含义进行一些说明: -->
This example calculates `1+2` and outputs the result.
Let's explain the details of the code:
<!-- * 在`/*`和`*/`之间的内容是C语言的注释(comment),
  注释内容不影响程序的逻辑, 因此注释主要是给程序员阅读的.
  例如, 上述代码和以下代码的逻辑是等价的: -->
* The content between `/*` and `*/` is a comment in C language.
  Comments do not affect the logic of the program, so they are mainly for programmers to read.
  For example, the above code and the following code are logically equivalent:
  ```c
  /* This is
     an example. */
  int main() {
    int x = 1;
    int y = 2;
    int z = x + y;
    printf("z = %d\n", z);
    return 0;
  }
  ```
<!-- * `int`表示整数类型, 它是`integer`的缩写. -->
* `int` represents the integer type, which is short for `integer`.
<!-- * `int main() { ... }`定义了一个名称为`main`的函数.
  函数是C语言的基本模块, 执行C程序的过程, 就是执行C程序中函数代码的过程.
  特别地, `main`函数是一个特殊的函数, 它是C程序的入口,
  也即, C程序将从`main`函数开始执行. -->
* `int main() { ... }` defines a function named `main`.
  Functions are the basic modules of the C language. The process of executing a C program is the process of executing the function code in the C program.
  In particular, the `main` function is a special function. It is the entry point of the C program,
  which means that the C program will start executing from the `main` function.
<!-- * 大括号中的内容`{ ... }`是函数体, 由语句组成,
  每条语句用于指示程序执行一个操作.
  大括号中的语句默认按顺序执行. -->
* The content within curly brackets `{ ... }` is the function body, which consists of statements.
  Each statement is used to instruct the program to perform an operation.
  The statements within curly brackets are executed in order by default.
<!-- * `int x = 1;`定义了一个变量, 变量的名称为`x`, 并将其初值赋为`1`.
  变量是程序中存储信息的对象, 类似上文提到的GPR.
  在C语言中, 一条语句以分号`;`结束.
  `int y = 2;`同理. -->
* `int x = 1;` defines a variable named `x` and assigns it an initial value of `1`.
  Variables are objects that store information in a program, similar to the GPR mentioned above.
  In C language, a statement ends with a semicolon `;`.
  `int y = 2;` works the same way.
<!-- * `int z = x + y;`定义了一个变量`z`, 并将其初值赋为`x + y`. -->
* `int z = x + y;` defines a variable `z` and assigns it an initial value of `x + y`.
<!-- * `printf("z = %d\n", z);`是一个函数调用语句, 它调用了函数`printf`.
  程序中的函数调用和数学上的求函数值有一些相似之处, 例如在数学领域中,
  已知$f(x)=x+1$, 求$f(3)$的过程就是将$3$代入$f$的定义中进行计算的过程;
  `printf("z = %d\n", z);`就是将两个参数`"z = %d\n"`和`z`代入`printf`的定义中并执行.
  在C程序中, `printf`是一个特殊的函数, 它用于向终端输出信息,
  第一个参数中的`%d`表示将第二个参数`z`按十进制格式输出.
  因此, 上述函数调用会将变量`z`的当前值按十进制格式输出到终端. -->
*  `printf(‘z = %d\n’, z);` is a function call statement that calls the function `printf`.
  Function calls in programs are similar to calculating function values in mathematics. For example, in mathematics,
  given that $f(x) = x + 1$, the process of finding $f(3)$ involves substituting $3$ into the definition of $f$ and performing the calculation;
  `printf(‘z = %d\n’, z);` substitutes the two parameters `‘z = %d\n’` and `z` into the definition of `printf` and executes it.
  In a C program, `printf` is a special function used to output information to the terminal.  
The `%d` in the first parameter indicates that the second parameter `z` should be output in decimal format. Therefore, the above function call outputs the current value of the variable `z` in decimal format to the terminal.
<!-- * `return 0;`是函数返回语句, 表示该函数执行结束,
  并将`0`作为计算结果返回给调用该函数的语句. -->
* `return 0;` is a function return statement, indicating that the function has finished executing,
  and returning `0` as the calculation result to the statement that called the function.

<!-- > #### todo::在线运行C程序 -->
<!-- > 你可以在[Compiler Explorer][compiler explorer]这个在线网站中运行上述C程序.
> 具体地, 在代码编辑器中输入上述C代码后, 点击编辑器上方工具栏的`Add new...`,
> 选择`Execution Only`, 即可弹出执行结果的终端窗口.
> 如果你的操作正确, 你将看到终端窗口输出`z = 3`.
>
> 你可以尝试按照你的理解修改C代码, 并观察程序的输出.
>
> Hint: 你可以收藏这个网站, 在E阶段的前期, 你将会使用这个网站作为开发环境.

[compiler explorer]: https://godbolt.org/ -->
> #### todo::Run C Programs Online
> You can run the above C program on the online website [Compiler Explorer][compiler explorer].
> Specifically, after entering the above C code in the code editor, click `Add new...` in the toolbar above the editor,
> select `Execution Only`, and a terminal window with the execution results will pop up.
> If you have done everything correctly, you will see `z = 3` output in the terminal window.
>
> You can try modifying the C code according to your understanding and observe the program's output.
>
> Hint: You can bookmark this website, as you will use it as a development environment in the early stages of Phase E.

[compiler explorer]: https://godbolt.org/

<!-- 需要注意的是, 上述说明并未详尽所有相关的C语言细节,
部分细节目前无法解释清楚, 我们先省略它们.
不过, 以上说明已经足够帮助你理解讲义的后续内容了. -->
It should be noted that the above explanation does not cover all the relevant details of the C language. Some details cannot be explained clearly at this time, so we will omit them for now. However, the above explanation is sufficient to help you understand the rest of the lecture notes.

<!-- ### C程序的状态机模型 -->
### State Machine Model of C Programs

<!-- 也许你已经隐约感觉到, C语言中的变量和语句的概念,
和上文提到ISA的GPR和指令的概念, 是有那么一点相似之处.
事实上, 从计算机系统的视角来看, 它们之间还真的具有十分密切的关系.
和ISA类似, 我们也可以从状态机的视角来理解C程序: -->
Perhaps you have already sensed that the concepts of variables and statements in C language are somewhat similar to the concepts of GPR and instructions mentioned above in ISA. In fact, from the perspective of computer systems, they are indeed closely related. Similar to ISA, we can also understand C programs from the perspective of state machines:
<!-- * 状态集合. 在C程序中, 最直接的状态就是变量, 因为它们是存储信息的对象.
  除此之外, 我们在上文还提到: `大括号中的语句默认按顺序执行`.
  很自然地, 在C程序的执行过程中, 还需要有一个用于指示当前执行到哪条语句的隐含变量,
  这个隐含变量就是C语言的“程序计数器”(PC), 它也应该属于状态的一部分.
  因此, 在C程序中, 一个状态是一组具体的变量和PC,
  而全体状态的集合$S$则是变量和PC所有取值的组合, 即$S=\{(PC, V)\}$,
  其中$V$表示程序中所有变量的取值. -->
* State set. In C programs, the most direct state is variables, as they are objects that store information. In addition, as mentioned earlier: `the statements within curly braces are executed in order by default`.
  Naturally, during the execution of a C program, there also needs to be an implicit variable to indicate which statement is currently being executed, 
  this implicit variable is the 'program counter' (PC) in the C language, and it should also be part of the state.
  Therefore, in a C program, a state is a set of specific variables and the PC,  
and the set of all states $S$ is the combination of all possible values of variables and the PC, i.e., $S=\{(PC, V)\}$,  
where $V$ represents the values of all variables in the program.
<!-- * 激励事件集合. 在C程序中, 执行语句会改变状态, 因此执行语句就是这个状态机的激励事件. -->
* Set of events. In C programs, execution statements change the state, so execution statements are the events for this state machine.
<!-- * 状态转移规则. 按照C程序的行为, 状态转移规则用于描述“在某个状态下执行某语句后的次态”,
  也即语句的语义, 它约定了执行某语句后, 状态应该发生怎么样的变化,
  从而从一个状态转移到另一个. -->
* State transition rules. According to the behaviour of C programs, state transition rules are used to describe 'the next state after executing a certain statement in a certain state',
  i.e. the semantics of the statement. It specifies how the state should change after executing a certain statement,
  so that it transitions from one state to another.
<!-- * 初始状态. 在未执行任何语句之前的状态, 即$S_0=(main函数第一句条语句的位置, V_0)$. -->
* Initial state. The state before any statements are executed, i.e., $S_0=(the position of the first statement in the main function, V_0)$.

<!-- 给出上述状态机模型之后, 我们就可以从状态机的视角来理解C程序的执行过程了.
考虑上述示例代码, 我们让PC表示程序执行到哪一行, 行号已经通过注释的方式给出.
我们用`(PC, x, y, z)`的格式来记录上述程序的状态.
根据C语言的约定, 初始状态为`(2, ?, ?, ?)`,
其中PC为`2`表示从第2行开始执行, 即`main`函数的第一条语句, `?`表示变量还未定义或未赋初值.
以下是上述C程序的执行过程: -->
After presenting the above state machine model, we can understand the execution process of a C program from the perspective of the state machine. Considering the above example code, we let PC represent the line where the program is executing, and the line number is provided through comments. We use the format `(PC, x, y, z)` to record the state of the above program. According to C language conventions, the initial state is `(2, ?, ?, ?)`, where PC is `2`, indicating that execution starts from line 2, i.e., the first statement of the `main` function, and `?` indicates that the variable has not yet been defined or initialised. The following is the execution process of the above C program:
<!-- ```
PC  x  y  z
(2, ?, ?, ?)    # 初始状态
(3, 1, ?, ?)    # 执行PC为2的语句后, x更新为1, PC更新为下一条语句的位置
(4, 1, 2, ?)    # 执行PC为3的语句后, y更新为2, PC更新为下一条语句的位置
(5, 1, 2, 3)    # 执行PC为4的语句后, z更新为x + y, PC更新为下一条语句的位置
(6, 1, 2, 3)    # 执行PC为5的语句后, 终端输出"z = 3", PC更新为下一条语句的位置
(END, 1, 2, 3)  # 执行PC为6的语句后, 从main函数返回, 程序执行结束
``` -->
```
PC  x  y  z
(2, ?, ?, ?)    # initial state
(3, 1, ?, ?)    # After executing the statement with PC = 2, x is updated to 1, and PC is updated to the position of the next statement.
(4, 1, 2, ?)    # After executing the statement with PC = 3, y is updated to 2, and PC is updated to the position of the next statement.
(5, 1, 2, 3)    # After executing the statement with PC = 4, z is updated to x + y, and PC is updated to the position of the next statement.
(6, 1, 2, 3)    # After executing the statement with PC = 5, the terminal outputs 'z = 3' and PC is updated to the position of the next statement.
(END, 1, 2, 3)  # After executing the statement with PC = 6, the program returns from the main function and execution ends.
```

<!-- ### 用C语言实现数列求和 -->
### Implementing a Sequence Sum in C

<!-- 我们还可以用C语言来计算`1+2+...+10`, 考虑以下C程序: -->
We can also use C language to calculate `1+2+...+10`. Consider the following C program:
```c
/* 1 */ int main() {
/* 2 */   int sum = 0;
/* 3 */   int i = 1;
/* 4 */   do {
/* 5 */     sum = sum + i;
/* 6 */     i = i + 1;
/* 7 */   } while (i <= 10);
/* 8 */   printf("sum = %d\n", sum);
/* 9 */   return 0;
/* 10*/ }
```
<!-- 上述代码中包含一个`do-while`循环, 其行为是,
先执行循环体(在大括号中)中的语句, 然后判断循环条件(在小括号中)是否成立,
若成立, 则重复执行循环体; 否则将结束循环, 继续执行后续语句. -->
The above code contains a `do-while` loop, which behaves as follows: First, execute the statements in the loop body (in the curly brackets), then check whether the loop condition (in parentheses) is true. If true, repeat the loop body; otherwise, exit the loop and continue executing subsequent statements.

<!-- 和上文的汇编语言相比, 我们至少看到了用C语言开发程序的两点优势:
1. 变量的命名可以更直观地反映出其用途, 但汇编语言中, GPR用途只能根据上下文推断
1. 循环的表达更清晰, 可以直接区别循环条件和循环体,
   但在汇编语言中, 循环条件和循环体都是指令, 需要根据上下文推断 -->
Compared to the assembly language mentioned earlier, we can see at least two advantages of developing programs using the C language:
1. Variable names can more intuitively reflect their purpose, but in assembly language, the purpose of GPRs can only be inferred from the context.
1. Loop expressions are clearer, allowing direct distinction between loop conditions and loop bodies,  
 but in assembly language, loop conditions and loop bodies are both instructions, requiring inference from the context.

<!-- 根据上述程序的行为, 前若干条语句的执行过程如下: -->
According to the above procedure, the execution process of the preceding statements is as follows:
<!-- ```
PC sum i
(2, ?, ?)    # 初始状态
(3, 0, ?)    # 执行PC为2的语句后, sum更新为0, PC更新为下一条语句的位置
(5, 0, 1)    # 执行PC为3的语句后, i更新为1, PC更新为下一条语句的位置(第4行无有效操作, 跳过)
(6, 1, 1)    # 执行PC为5的语句后, sum更新为sum + i, PC更新为下一条语句的位置
(7, 1, 2)    # 执行PC为6的语句后, i更新为i + 1, PC更新为下一条语句的位置
(5, 1, 2)    # 执行PC为7的语句后, 由于循环条件i <= 10成立, 因此重新进入循环体
......
``` -->
```
PC sum i
(2, ?, ?)    # initial state
(3, 0, ?)    # After executing the statement with PC = 2, sum is updated to 0, and PC is updated to the position of the next statement.
(5, 0, 1)    # After executing the statement with PC = 3, i is updated to 1, and PC is updated to the position of the next statement (there is no valid operation on line 4, so it is skipped).
(6, 1, 1)    # After executing the statement with PC = 5, sum is updated to sum + i, and PC is updated to the position of the next statement.
(7, 1, 2)    # After executing the statement with PC = 6, i is updated to i + 1, and PC is updated to the position of the next statement.
(5, 1, 2)    # After executing the statement with PC = 7, since the loop condition i <= 10 is true, the loop body is re-entered.
......
```

<!-- > #### todo::继续执行上述程序
> 尝试继续执行上述代码, 记录状态的变化过程.
> 程序执行结束时, 程序处于什么样的状态? -->
> #### todo::Continue to Execute the above Procedures.
> Try to continue executing the above code and record the changes in status.
> What is the state of the program when it finishes executing?

<!-- ## 数字电路的状态机模型 -->
## State Machine Model of Digital Circuits

<!-- 我们在上文提到"把这台思维中的模型机通过数字电路实现出来",
这意味着, 数字电路也能和ISA建立某种关联,
那我们是否也能从状态机的视角去理解数字电路的行为呢? -->
In the previous paragraph, we mentioned 'implementing this model machine in our minds through digital circuits'. This means that digital circuits can also establish some kind of connection with ISA. So, can we also understand the behaviour of digital circuits from the perspective of state machines?

<!-- 答案是肯定的! 根据上一节数字电路的知识,
我们可以很容易地归纳出数字电路的状态机模型: -->
The answer is yes! Based on the knowledge of digital circuits in the previous section,
we can easily summarise the state machine model of digital circuits:
<!-- * 状态集合. 在数字电路中, 只有时序逻辑电路才能存储信息,
  因此一个状态是时序逻辑元件所存储的具体信息,
  而全体状态的集合$S$则是时序逻辑元件所能存储信息的所有组合.
* 激励事件集合. 既然时序逻辑元件表征了数字电路的状态,
  而时序逻辑元件的内部状态可以通过其输入端改变(例如可以通过输入端将数据写入D触发器),
  我们可以将数字电路看成以下模型: -->
* State set. In digital circuits, only sequential logic circuits can store information.
  Therefore, a state is the specific information stored by a sequential logic element,
  and the set of all states $S$ is the combination of all information that can be stored by sequential logic elements.
* Event set. Since sequential logic elements represent the states of digital circuits,
  and the internal state of sequential logic elements can be changed through their input terminals (e.g., data can be written into a D flip-flop through its input terminal),
  we can view digital circuits as the following model:
  ```
      +------------------+
  +-->| Sequential Logic |----+
  |   +------------------+    |
  | next state                | current state
  |                           |
  |  +---------------------+  |
  +--| Combinational Logic |<-+
     +---------------------+
  ```
  <!-- 也即, 让时序逻辑元件的状态发生变化的, 其实是组合逻辑电路输出的信号,
  因此组合逻辑电路就是这个状态机的激励事件. -->
  In other words, it is the signal output by the combinational logic circuit that causes the state of the sequential logic element to change.
  Therefore, the combinational logic circuit is the event for this state machine.
<!-- * 状态转移规则. 时序逻辑元件的状态具体应如何变化, 是由组合逻辑电路的具体逻辑决定的.
* 初始状态. 即电路在复位时, 时序逻辑元件的状态. -->
* State transition rules. How the state of a sequential logic element should change is determined by the specific logic of the combinational logic circuit.
* Initial state. This refers to the state of the sequential logic element when the circuit is reset.

<!-- 例如, Johnson计数器的电路结构如下: -->
For example, the circuit structure of the Johnson counter is as follows:
![image](https://ysyx.oscc.cc/slides/2306/resources/img/03-johnson-counter.jpg)

<!-- 根据电路结构的逻辑, 我们可以从状态机视角来理解上述Johnson计数器的工作过程: -->
Based on the logic of the circuit structure, we can understand the working process of the above Johnson counter from a state machine perspective:
<!-- ```
 A  B  C  D
(0, 0, 0, 0)    # 初始状态
(1, 0, 0, 0)
(1, 1, 0, 0)
(1, 1, 1, 0)
(1, 1, 1, 1)
(0, 1, 1, 1)
(0, 0, 1, 1)
(0, 0, 0, 1)
(0, 0, 0, 0)    # 与初始状态一致
``` -->
```
 A  B  C  D
(0, 0, 0, 0)    # Initial state
(1, 0, 0, 0)
(1, 1, 0, 0)
(1, 1, 1, 0)
(1, 1, 1, 1)
(0, 1, 1, 1)
(0, 0, 1, 1)
(0, 0, 0, 1)
(0, 0, 0, 0)    # Consistent with the initial state
```

<!-- > #### todo::从状态机视角理解数列求和电路的工作过程
> 在上一小节中, 你已经通过寄存器和加法器搭建出一个简单数列求和电路,
> 用于计算`1+2+...+10`. 尝试列出电路状态的变化过程. -->
> #### todo::Understanding the Working Process of a Sequence Summing Circuit from a State Machine Perspective
> In the previous subsection, you built a simple sequence summing circuit using registers and adders
> to calculate `1+2+...+10`. Try to list the changes in the circuit state.

<!-- 当然, 这个Johnson计数器的例子与CPU区别很大, 但如果CPU能用数字电路设计出来,
它一定也包含时序逻辑电路和组合逻辑电路, 因而也一定能从状态机视角来理解CPU的工作过程. -->
Of course, this example of a Johnson counter is very different from a CPU, but if a CPU can be designed using digital circuits,
it must also contain sequential logic circuits and combinational logic circuits, and therefore the working process of a CPU can also be understood from the perspective of a state machine.

<!-- ## 在计算机上执行C程序 -->
## Executing C Programs on a Computer

<!-- 我们从状态机视角去理解C程序的执行过程, 本质上是在我们的思维中执行这个C程序.
但计算机只能执行指令, 它无法理解C程序的含义, 因此也无法执行类似`sum = sum + i;`这样的代码.
那怎么让计算机执行C程序呢?
答案是, 将C程序的代码翻译成行为等价的指令序列, 然后让计算机的电路来执行这个指令序列. -->
We understand the execution process of a C program from the perspective of a state machine, which essentially means executing the C program in our minds. However, computers can only execute instructions; they cannot understand the meaning of a C program, so they cannot execute code such as `sum = sum + i;`. So how do we get a computer to execute a C program? The answer is to translate the C program's code into a sequence of instructions that are behaviourally equivalent, and then have the computer's circuitry execute this sequence of instructions.

<!-- ### 编译 = 将C代码翻译成指令序列 -->
### Compilation = Translating C Code into a Sequence of Instructions

<!-- 这个过程在计算机系统中有一个特殊的名称, 叫"编译"(compile).
从原则上讲, 编译的工作可以人工进行,
但现代程序的规模很大, 人工进行编译是非常繁琐的,
因此通常由一类特殊的程序来开展编译工作, 这类特殊的程序称为"编译器"(compiler). -->
This process has a special name in computer systems: 'compilte'.In principle, compilation can be done manually, but modern programs are very large, and manual compilation is very tedious. Therefore, compilation is usually performed by a special type of program called a 'compiler'.

<!-- 既然执行C程序和执行指令序列都可以从状态机视角去理解,
我们也可以尝试去了解编译器需要完成哪些工作.
我们先将两个状态机的内容列出来(此处暂不关心初始状态): -->
Since executing C programs and executing instruction sequences can both be understood from a state machine perspective, we can also try to understand what tasks a compiler needs to perform. Let's first list the contents of the two state machines (we will not concern ourselves with the initial state here):

<!-- |              | C程序       | ISA            |
|:------------:|:-----------:|:--------------:|
| 状态         | $\{PC, V\}$ | $\{PC, R, M\}$ |
| 激励事件     | 执行语句    | 执行指令       |
| 状态转移规则 | 语句的语义  | 指令的语义     | -->
|              | C program       | ISA            |
|:------------:|:-----------:|:--------------:|
| State         | $\{PC, V\}$ | $\{PC, R, M\}$ |
| Event     | Executed statement    | Executed instruction       |
| State transition rule | Semantics of statement  | Semantics of instruction     |

<!-- 因此, 编译器的工作就是将C程序的状态机翻译成ISA的状态机, 也即,
构造 -->
Therefore, the compiler's job is to translate the state machine of the C program into the state machine of the ISA, or in other words, construct
<!-- $$\begin{array}{l}
compile_S:\{PC, V\}\to\{PC, R, M\}\\
compile_E:\{语句\}\to\{指令序列\}
\end{array}$$
使得
$$compile_S(next(S_{C,k}, 语句))=next(compile_S(S_{C,k}), compile_E(语句))$$
从而有
$$\begin{array}{rl}
 &compile_S(S_{C,k+1}) \\
=&compile_S(next(S_{C,k}, 语句) \\
=&next(compile_S(S_{C,k}), compile_E(语句)) \\
=&next(S_{ISA,k},指令序列) \\
=&S_{ISA,k+1} \\
\end{array}$$ -->
$$\begin{array}{l}
compile_S:\{PC, V\}\to\{PC, R, M\}\\
compile_E:\{statement\}\to\{instruction sequence\}
\end{array}$$
make
$$compile_S(next(S_{C,k}, statement))=next(compile_S(S_{C,k}), compile_E(statement))$$
thus,
$$\begin{array}{rl}
 &compile_S(S_{C,k+1}) \\
=&compile_S(next(S_{C,k}, statement) \\
=&next(compile_S(S_{C,k}), compile_E(statement)) \\
=&next(S_{ISA,k},instruction sequence) \\
=&S_{ISA,k+1} \\
\end{array}$$
<!-- 其中, $S_{C,k}$表示C语言状态机的第$k$个状态, $S_{ISA,k}$表示ISA状态机的第$k$个状态.
用自然语言来描述, 则是: C程序执行一条语句后的状态,
与ISA执行编译得到的指令序列后的状态, 语义上是等价的. -->
In this context, $S_{C,k}$ denotes the $k$ th state of the C language state machine, and $S_{ISA,k}$ denotes the $k$ th state of the ISA state machine. In natural language, this means: The state of a C program after executing a statement is semantically equivalent to the state of the ISA after executing the instruction sequence obtained from compilation.

<!-- 具体地, 对比两个状态机后可以得知, 编译器需要完成以下工作:
* 将C程序的状态翻译成ISA的状态, 也即
  * 将C程序的PC对应到ISA的PC
  * 将C程序的变量对应到ISA的GPR或内存
* 将C程序的状态转移规则翻译成ISA的状态转移规则, 也即, 将语句翻译成指令序列 -->
Specifically, after comparing the two state machines, we can see that the compiler needs to perform the following tasks: 
* Translate the state of the C program into the state of the ISA, i.e.
  * Map the PC of the C program to the PC of the ISA
  * Map the variables of the C program to the GPR or memory of the ISA
* Translate the state transition rules of the C program into the state transition rules of the ISA, i.e., translate statements into instruction sequences.

<!-- > #### todo::结合数列求和的例子理解编译器的工作
> 我们已经给出了数列求和的C程序和相应的指令序列, 尝试从状态机的视角理解它们之间的联系. -->
> #### todo::Understand how compilers work using the example of summing a sequence of numbers
> We have already provided the C program for summing a sequence of numbers and the corresponding instruction sequence. Try to understand the relationship between them from the perspective of a state machine.


<!-- > #### todo::在Compiler Explorer中理解编译器的工作
> 具体地, 点击编辑器上方工具栏的`Add new...`,
> 选择`Compiler`, 即可弹出相应汇编代码的窗口.
> 汇编代码默认采用x86指令集, 你不一定能理解每一条指令的具体含义,
> 但通过背景颜色的高亮和鼠标移动, 你可以看到C代码片段和汇编代码片段之间的对应关系. -->
> #### todo::Understanding how compilers work in Compiler Explorer
> Specifically, click `Add new...` in the toolbar above the editor,
> select `Compiler`, and a window with the corresponding assembly code will pop up.
> The assembly code uses the x86 instruction set by default. You may not understand the specific meaning of each instruction,
> but by highlighting the background colour and moving the mouse, you can see the correspondence between the C code snippet and the assembly code snippet.

<!-- ### CPU设计 = 根据ISA设计数字电路 -->
### CPU design = Designing Digital Circuits Based on ISA

<!-- 同样地, 既然ISA和数字电路都可以从状态机视角去理解,
我们也可以尝试去了解CPU设计应该如何开展.
我们先将两个状态机的内容列出来(此处暂不关心初始状态): -->
Similarly, since ISAs and digital circuits can both be understood from a state machine perspective, we can also try to understand how CPU design should be carried out. Let's first list the contents of the two state machines (we will not concern ourselves with the initial state here):

<!-- |              | ISA            | 数字电路           |
|:------------:|:--------------:|:------------------:|
| 状态         | $\{PC, R, M\}$ | 时序逻辑电路       |
| 激励事件     | 执行指令       | 处理组合逻辑       |
| 状态转移规则 | 指令的语义     | 组合逻辑电路的逻辑 | -->
|              | ISA            | Digital Circuit           |
|:------------:|:--------------:|:------------------:|
| State         | $\{PC, R, M\}$ | Sequential logic circuit       |
| Event     | Execute instruction       | Process combinational logic       |
| State transition rule | Semantics of instruction     | Logic of combinational logic circuit |

<!-- 因此, CPU设计的工作就是用数字电路的状态机实现ISA的状态机, 也即,
构造 -->
Therefore, the task of CPU design is to implement the ISA state machine using a digital circuit state machine, or in other words, construct
<!-- $$\begin{array}{l}
CPUdesign_S:\{PC, R, M\}\to\{时序逻辑电路\}\\
CPUdesign_E:\{指令\}\to\{组合逻辑电路\}
\end{array}$$
使得
$$CPUdesign_S(next(S_{ISA,k}, 指令))=next(CPUdeisgn_S(S_{ISA,k}), CPUdesign_E(指令))$$
从而有
$$\begin{array}{rl}
 &CPUdesign_S(S_{ISA,k+1}) \\
=&CPUdesign_S(next(S_{ISA,k}, 指令) \\
=&next(CPUdesign_S(S_{ISA,k}), CPUdesign_E(指令)) \\
=&next(S_{CPU,k},组合逻辑电路) \\
=&S_{CPU,k+1} \\
\end{array}$$ -->
$$\begin{array}{l}
CPUdesign_S:\{PC, R, M\}\to\{Sequential logic circuit\}\\
CPUdesign_E:\{Instruction\}\to\{Combinational logic circuit\}
\end{array}$$
make
$$CPUdesign_S(next(S_{ISA,k}, Instruction))=next(CPUdeisgn_S(S_{ISA,k}), CPUdesign_E(Instruction))$$
thus,
$$\begin{array}{rl}
 &CPUdesign_S(S_{ISA,k+1}) \\
=&CPUdesign_S(next(S_{ISA,k}, Instruction) \\
=&next(CPUdesign_S(S_{ISA,k}), CPUdesign_E(Instruction)) \\
=&next(S_{CPU,k},Combinational logic circuit) \\
=&S_{CPU,k+1} \\
\end{array}$$
<!-- 其中, $S_{CPU,k}$表示CPU电路状态机的第$k$个状态.
用自然语言来描述, 则是: ISA执行一条和指令后的状态,
与设计出的CPU在组合逻辑电路控制下的次态, 语义上是等价的. -->
Among them, $S_{CPU,k}$ represents the $k$ th state of the CPU circuit state machine. Described in natural language, it is: the state after the ISA executes an instruction is semantically equivalent to the next state of the designed CPU under the control of combinational logic circuits.

<!-- 具体地, 对比两个状态机后可以得知, CPU设计需要完成以下工作:
* 用数字电路的状态实现ISA的状态, 也即, 用时序逻辑电路实现PC, GPR和内存
* 用数字电路的状态转移规则实现ISA的状态转移规则, 也即, 用组合逻辑电路实现指令的功能 -->
Specifically, after comparing the two state machines, we can see that the CPU design needs to accomplish the following tasks:
* Implement the ISA states using digital circuit states, i.e., implement the PC, GPR, and memory using sequential logic circuits.
* Implement the ISA state transition rules using digital circuit state transition rules, i.e., implement the functions of instructions using combinational logic circuits.

<!-- ## 程序, ISA和CPU之间的联系 -->
## The Relationship between Programs, ISAs, and CPUs

<!-- 到此, 我们可以来简单梳理程序, ISA和CPU之间的联系:
1. 根据ISA手册的功能描述, 画一张CPU的结构图 -> 处理器微结构设计
1. 根据结构图设计具体的电路 -> 逻辑设计
1. 开发程序 -> 软件编程
1. 将程序翻译成ISA手册中描述的指令序列 -> 编译
1. 在CPU上执行程序 = 用程序编译出的指令序列控制CPU电路进行状态转移
   * 此时, 三个状态机产生联系: $S_C\sim S_{ISA}\sim S_{CPU}$ -->
At this point, we can briefly review the relationship between the program, ISA, and CPU:
1. Based on the functional description in the ISA manual, draw a diagram of the CPU structure -> processor microarchitecture design
1. Based on the structural design, design the specific circuit -> logic design
1. Develop the program -> Software programming
1. Translate the program into the instruction sequence described in the ISA manual -> Compilation
1. Execute the program on the CPU = Use the instruction sequence compiled from the program to control the CPU circuits to perform state transitions
   * At this point, the three state machines are interconnected: $S_C\sim S_{ISA}\sim S_{CPU}$

<!-- > #### comment::从一到无穷大
> 你或许觉得上文举的示例过于简单, 我们使用的现代计算机真的是这样工作的吗?
> 现在我们来揭开现代计算机的神秘面纱. -->
> #### comment::From one to infinity
> You may think that the examples given above are too simple. Do modern computers really work this way?
> Now let's lift the veil of mystery surrounding modern computers.
><!-- > 我们已经知道, 通过使用补码表示,
> 计算机可以借助同一套加法器硬件来实现算术上的加法和减法,
> 通过提供一条新的减法指令, 程序就可以进行减法操作了.
> 通过跳转指令实现的循环来重复执行加法指令, 我们就实现了算术上的乘法功能;
> 而重复执行减法指令, 则可以实现算术上的除法功能. -->
> We already know that by using two's complement representation,
> computers can use the same set of adder hardware to perform arithmetic addition and subtraction.
> By providing a new subtraction instruction, the program can perform subtraction operations.
> By using a loop implemented with a jump instruction to repeatedly execute the addition instruction, we achieve arithmetic multiplication functionality;
> and by repeatedly executing the subtraction instruction, we can achieve arithmetic division functionality.
><!-- > 上面已经实现了整数的四则运算, 要实现小数的运算也不难.
> 我们知道在数学中可以通过科学记数法来表示一个小数,
> 计算机也可以用类似的方式来表示小数, 只不过采用的是二进制的科学记数法.
> 具体地, 任何一个小数$x$都可以表示成$1.\alpha\times 2^{\beta}$,
> 其中$\alpha$二进制表示的无符号数, $\beta$是二进制表示的有符号数.
> 计算机只要将$\alpha$和$\beta$记录下来, 就相当于通过二进制方式表示了小数$x$.
> 显然, 小数之间的四则运算也可以转换成$\alpha$和$\beta$相关的四则运算. -->
>The four arithmetic operations for integers have already been implemented above, and it is not difficult to implement operations for decimals.
> We know that in mathematics, a decimal can be represented using scientific notation.
> Computers can also represent decimals in a similar way, but they use binary scientific notation.
> Specifically, any decimal number $x$ can be represented as $1.\alpha\times 2^{\beta}$,  
> where $\alpha$ is an unsigned number represented in binary, and $\beta$ is a signed number represented in binary.
> As long as the computer records $\alpha$ and $\beta$, it is equivalent to representing the decimal number $x$ in binary form. 
> Clearly, arithmetic operations between decimal numbers can also be converted into arithmetic operations involving $\alpha$ and $\beta$.
><!-- > 实现了小数的四则运算后, 就可以计算数学意义上的基本初等函数了,
> 包括常函数, 幂函数, 指数函数, 对数函数, 三角函数, 反三角函数.
> 具体地, 除常函数外, 其他5种基本初等函数都可以通过幂级数展开进行计算,
> 而幂级数可以通过四则运算和循环进行计算. -->
>After implementing arithmetic operations on decimals, we can calculate basic elementary functions in a mathematical sense,
> including constant functions, power functions, exponential functions, logarithmic functions, trigonometric functions, and inverse trigonometric functions.
> Specifically, except for constant functions, the other five basic elementary functions can be calculated using power series expansions, 
> and power series can be calculated using arithmetic operations and loops.
><!-- > 实现了基本初等函数的计算后, 就可以通过函数之间的有限次四则运算,
> 乘方, 开方, 以及复合操作, 来计算所有初等函数了.
> 对于复合操作, 我们可以通过程序中的函数调用功能来实现. -->
>After implementing the calculation of basic elementary functions, all elementary functions can be calculated through a finite number of arithmetic operations between functions,
> exponentiation, root extraction, and composite operations.
> For composite operations, we can use the function call function in the program to implement them.
><!-- > 我们还能继续对函数进行求导和积分.
> 根据导数的定义, 我们只需要代入一个很小的$\Delta x$,
> 就能近似计算出函数在某一点的导数.
> 而根据定积分定义, 我们可以将被积区间分成足够多份,
> 然后用被积函数在区间内的某点取值近似代替区间中的取值,
> 然后通过求和计算出函数在被积区间上的黎曼和.
> 当然, 这些都是简单直观的计算方法,
> 为了在计算机中计算出更精确的导数和积分,
> 科学家还提出了一系列的数值分析算法. -->
> We can continue to differentiate and integrate the function.
> According to the definition of the derivative, we only need to substitute a very small $\Delta x$,
> to approximately calculate the derivative of the function at a certain point.
> According to the definition of definite integrals, we can divide the interval being integrated into a sufficient number of segments,
> then approximate the function's value over the interval using its value at a point within the interval,
> and then calculate the Riemann sum of the function over the interval by summing the values.
> Of course, these are simple and intuitive computational methods.
> To calculate more precise derivatives and integrals on a computer,
> scientists have developed a series of numerical analysis algorithms.
><!-- > 上述计算都是在实数域上进行, 要将计算扩展到复数域其实也不难.
> 具体地, 我们只需要对实数分量和虚数分量分别进行计算,
> 另外再应用相关的规则处理虚数单位$i$即可.
> 尽管复数域的有些操作和实数域有所不同, 但只要能用数学语言描述出计算方式,
> 都有办法将其归约到上文的操作中. --> 
>The above calculations are all performed in the real number domain. Extending the calculations to the complex number domain is actually not difficult.
> Specifically, we only need to perform separate calculations on the real and imaginary components,
> and then apply the relevant rules to handle the imaginary unit $i$.
> Although some operations in the complex number field differ from those in the real number field, as long as the calculation method can be described using mathematical language,
> there is always a way to convert it to the operations described above.
><!-- > 支持复数域的求导和积分后, 我们就可以在程序中实现各种物理引擎,
> 对真实世界中的各种物理规律进行模拟.
> 各种力学, 电磁学, 光学, 热学的计算公式,
> 在程序中都是通过一条条简单的指令来完成计算,
> 从而让用户在计算机世界中感受到和物理世界一致的体验.
> 我们在计算机中感受到的一切, 都是通过计算实现的! -->
> After supporting differentiation and integration in complex domains, we can implement various physical engines in the program,
> simulate various physical laws in the real world.
> Various formulas for mechanics, electromagnetism, optics, and thermodynamics
> are calculated in the program through a series of simple instructions,
> allowing users to experience the same physical world in the computer world.
> Everything we experience in the computer is achieved through computation!
><!-- > 当然, 为了让计算过程更高效, 现代ISA还提供了更多的指令,
> 包括乘除指令, 逻辑运算指令(计算与, 或, 非等), 浮点指令, 原子指令等.
> 例如, 相比于通过循环实现乘法, 计算机提供了乘法指令和乘法器电路,
> 可以让程序通过乘法指令高效地计算乘法.
> 一些ISA甚至还提供直接计算基本初等函数的指令,
> 如开方指令, 三角函数指令等. 不难想象,
> 要在电路层次提供计算这些基本初等函数的功能, 是需要电子工程师仔细考量的. -->
>Of course, to make the calculation process more efficient, modern ISAs also provide more instructions,
> including multiplication and division instructions, logical operation instructions (such as AND, OR, NOT, etc.), floating-point instructions, atomic instructions, and so on.
> For example, instead of implementing multiplication through loops, computers provide multiplication instructions and multiplier circuits,
> allowing programs to efficiently calculate multiplication using multiplication instructions.
> Some ISAs even provide instructions for directly calculating basic elementary functions,
> such as square root instructions and trigonometric function instructions. It is not difficult to imagine that
> providing the functionality to calculate these basic elementary functions at the circuit level requires careful consideration by electronic engineers.
><!-- > 除了提供更丰富的指令, 计算机架构师还致力于设计出能更高效执行指令的计算机.
> 例如, 通过流水线技术可以提升计算机执行指令的吞吐,
> 通过超标量技术可以让计算机在一个周期内执行多条指令,
> 而通过缓存技术则可以提升计算机访问内存的效率.
> 这些技术最终都会让计算机用户获得越来越快的性能体验. -->
>In addition to providing richer instructions, computer architects are also committed to designing computers that can execute instructions more efficiently.
> For example, pipeline technology can improve the throughput of computer instruction execution,
> superscalar technology allows computers to execute multiple instructions in a single cycle,
> and cache technology improves the efficiency of computer memory access.
> These technologies ultimately provide computer users with increasingly faster performance experiences.
<!-- 事实上, 无论是1941年平均每秒执行$3\times 10^{-1}$次乘法操作的[Z3计算机][z3 computer],
还是[2024年11月在Top500][top 500]排名第一,
峰值计算能力达到每秒$2.746\times 10^{18}$次浮点操作的超级计算机,
其工作原理都是一脉相承的.
虽然上文列举的例子都经过高度简化,
但它们已经足够帮助你理解计算机系统中最本质的要素及其关联.
在后续学习的过程中, 我们将不断细化这些概念,
最终了解如何根据真实的ISA设计一颗真实的CPU芯片, 并在其上运行真实的程序. -->
In fact, whether it was the [Z3 computer][z3 computer] in 1941, which averaged $3\times 10^{-1}$ multiplication operations per second, or the supercomputer ranked first in [the Top500 list in November 2024][top 500], with a peak computational capability of $2.746\times 10^{18}$ floating-point operations per second, their operating principles are fundamentally the same. Although the examples listed above have been highly simplified, they are sufficient to help you understand the most fundamental elements of computer systems and their interconnections. In subsequent studies, we will continue to refine these concepts, ultimately learning how to design a real CPU chip based on a real ISA and run real programs on it.

[z3 computer]: https://en.wikipedia.org/wiki/Z3_(computer)
[top 500]: https://www.top500.org/lists/top500/2024/11/
