<!--# F3 数字逻辑电路基础
-->
# F3 The basic of digital and logic circuits
<!--
> #### hint::不要使用黑夜模式阅读本章节
> 在黑夜模式下, 图片的显示将难以识别, 建议使用白天模式进行阅读.
-->

> #### hint::Don't use night mode to read this chapter.
> In night mode, the image display will be difficult to recognize, it is recommended to use day mode for reading.

<!--
处理器芯片本质上是数字电路.
因此要学习处理器芯片设计, 数字电路的知识是基础.
数字电路是用来处理数字信号的电路, 而数字信号简单来说是指`0`和`1`这两种离散的信号.
这里的`0`和`1`并不是数学意义上的自然数, 它是指信号的两种不同状态,
其物理意义是信号的电位状态, 通常分低电平和高电平两种状态,
为了简单叙述, 就分别称它们为`0`和`1`.
为了和数学上的`0`和`1`区分开来, 有时候也将上面两种状态称为`逻辑0`和`逻辑1`.
与数字信号相对的是模拟信号, 模拟信号通常是连续的, 例如电流, 电压等都属于模拟信号.
用来处理模拟信号的电路称为模拟电路, 不过在处理器设计中, 我们很少关注它.
-->
Processor chips are essentially digital circuits.
Therefore, to learn processor chip design, knowledge of digital circuits is fundamental.
Digital circuits are circuits used to process digital signals, simply which are discrete signals consisting of `0` and `1`.
The `0` and `1` here are not natural numbers in the mathematical sense,they refer to two different states of a signal. Physically, these correspond to the signal's Potential states, typically low and high levels. For simplicity, we will refer to them as `0` and `1`, respectively.
The `0` and `1` here are not natural numbers in the mathematical sense,they refer to two different states of a signal. Physically, these correspond to the signal's Potential states, typically low and high levels. For simplicity, we will refer to them as `0` and `1`, respectively.
To distinguish them from the mathematical `0` and `1`, these two states are sometimes referred to as `logical 0` and `logical 1`.
Analog signals are the opposite of digital signals. Analog signals are usually continuous, such as current and voltage.
Circuits that process analog signals are called analog circuits, but we rarely pay attention to them in processor design.


<!--
## 通过晶体管实现`0`和`1`

在数字电路里面, `0`和`1`是通过晶体管来实现的.
常用的晶体管是`金属-氧化物-半导体场效应晶体管`
(Metal-Oxide-Semiconductor Field-Effect Transistor, MOSFET), 简称MOS管.
根据工作原理的不同, MOS管又分nMOS(N型MOS, N表示Negative)和pMOS(P型MOS, P表示Positive)两种,
它们都有三个接口, 分别是栅极(gate), 源极(source)和漏极(drain), 其侧视图如下图所示.
-->
Realizing `0` and `1` through transistors
In digital circuits, `0` and `1` are implemented using transistors.
The most commonly used transistor is the `Metal-Oxide-Semiconductor Field-Effect Transistor`
(MOSFET), abbreviated as MOS transistor.
Based on their operating principles, MOSFETs are further classified into two types: nMOS (N-type MOS, where N stands for Negative) and pMOS (P-type MOS, where P stands for Positive).
Both types have three terminals: the gate, source, and drain. Their side views are shown in the figure below.



| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/6f59f0809f5bd1e9065a0e3b2a41ee156cc10310.png) | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/3ce66c7c155dcddc0e3b6f86f3abfdcd94a3968a.png) |
|:-:|:-:|

<!--
晶体管通常作为电路元件, 像开关一样接入到电路中.
但和人工操作的开关不同, 晶体管是一个特殊的开关, 它是由电路中的电压来控制的.
以nMOS为例, 根据其电气特性, nMOS的功能如下:
* 当栅极电压与源极电压之间的差值($V_G-V_S$)较大时, 源极和漏极导通, 相当于开关合上
* 当栅极电压与源极电压之间的差值($V_G-V_S$)较小时, 源极和漏极截止, 相当于开关断开

pMOS的功能表现与nMOS类似, $V_S-V_G$较大时导通, $V_S-V_G$较小时截止.
-->
Transistors are typically used as circuit components and are connected to circuits like switches.
However, unlike manually operated switches, transistors are special switches that are controlled by the voltage in the circuit.

Taking nMOS as an example, according to its electrical characteristics, the functionality of nMOS is as follows:
* When the difference between the gate voltage and the source voltage ($V_G-V_S$) is large, the source and drain are conductive, equivalent to the switch being closed
* When the difference between the gate voltage and the source voltage ($V_G-V_S$) is small, the source and drain are cutoff, equivalent to a switch being open.

The functionality of a pMOS is similar to that of an nMOS: it conducts when $V_S-V_G$ is large and is cutoff when $V_S-V_G$ is small.


<!--
> #### comment::晶体管具体如何通过电压控制开关
> 要理解这个问题需要一些物理和化学的知识, 但这已经超出了处理器设计的范畴,
> 因此这并非"一生一芯"学习过程中必须掌握的内容.
> 如果你确实对这个问题感兴趣, 我们可以简单说明.
>
> 以nMOS为例, 制造nMOS时, 需要在一块硅材料中掺入少量特定杂质元素作为P型衬底(上图中的p-substrate),
> 这些杂质元素并不稳定, 很容易失去一个电子, 使得电子能在P型衬底中自由移动.
> 然后在衬底上方挖出两个N区(上图中的n-channel), 并掺入大量的另一种杂质元素,
> 然后用金属引出两个电极, 分别作为源极和漏极.
> 之后在衬底表面覆盖一层二氧化硅作为绝缘层(上图中的dielectric), 在绝缘层上方再用金属引出一个电极作为栅极.
>
> 工作时, 如果在栅极加足够大的电压, 就会在绝缘体下方形成电场.
> 在电场的作用下, 原本P型衬底中自由移动的电子将向绝缘体方向移动.
> 但由于电子无法穿过绝缘体, 因此会聚集在绝缘体下方, 形成一条导电的沟道,
> 这条沟道连接了N区的源极和漏极, 此时nMOS处于导通状态.
> 相反, 如果在栅极加的电压不足, 沟道就无法形成, 无法连接源极和漏极, 此时nMOS处于截止状态.
>
> pMOS的工作原理和nMOS类似, 但不完全相同, 感兴趣的同学可以搜索相关资料.

由于nMOS和pMOS具有互补的特性, 在数字电路中通常将两者联合使用,
称为CMOS(Complementary Metal-Oxide-Semiconductor)技术.
-->

> #### comment::How exactly do transistors control switches through voltage?
> Understanding this issue requires some knowledge of physics and chemistry, but this is beyond the scope of processor design.
> Therefore, it is not essential knowledge for the "One Student One Chip(OSOC)" learning process.
> If you are truly interested in this issue, we can provide a brief explanation.
> Taking nMOS as an example, when manufacturing nMOS, a small amount of specific impurity elements are doped into a silicon material to form a P-type substrate (the p-substrate in the figure above),these impurity elements are unstable and easily lose an electron, allowing electrons to move freely within the P-type substrate.
>
> Then, two N-regions (the n-channel in the figure above) are etched into the substrate, and a large amount of another type of impurity element is doped into them, followed by the use of metal to connect two electrodes, serving as the source and drain, respectively.A layer of silicon dioxide is then deposited on the substrate surface as an insulating layer (as shown in the dielectric layer in the figure above), and metal electrodes are used as gate electrodes on top of the insulating layer.
>
> When working, applying a sufficiently high voltage to the gate creates an electric field beneath the insulator.Under the influence of the electric field, the free-moving electrons in the P-type substrate will move toward the insulator.  However, since electrons cannot pass through the insulator, they will accumulate beneath it, forming a conductive channel.  This channel connects the source and drain of the N-region, and the nMOS is in the conductive state.Conversely, if the voltage applied to the gate is insufficient, the channel cannot form, and the source and drain cannot be connected, at which point the nMOS is in the cutoff state.  The operating principle of the pMOS is similar to that of the nMOS but not entirely the same.Interested students can search for related materials
>
> Since NMOS and PMOS have complementary characteristics, they are typically used together in digital circuits,referred to as CMOS (Complementary Metal-Oxide-Semiconductor) technology.

<!--下面是一个最简单的CMOS电路:
-->
This is a very simple CMOS circuit:
| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/c8c9110881cea99377527ca612b80b707ad3e7c7.png) | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/8e4aff841429a29a8bd611f571ccfed4fc63a2f4.png) | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/3e6f56adc2cfba1be087ad61de5925be5ba6bfb0.png) |
|:-:|:-:|:-:|

<!--这个CMOS电路的工作方式如下:
* 在A点加高电压时, 下方的n管(nMOS)导通, 上方的p管(pMOS)截止, 相当于Y点与地相连(中图), Y点电压低
* 在A点加低电压时, 下方的n管(nMOS)截止, 上方的p管(pMOS)导通, 相当于Y点与电源相连(右图), Y点电压高
可以看到, CMOS电路将n管和p管的开关特性转换成了电路输出电压的高低.
将物理上的高电压(如$5V$)定义为`逻辑1`(高电平), 低电压(如$0V$)定义为`逻辑0`(低电平),
我们就得到了数字电路中信号的两种基本状态!
-->
This CMOS circuit works as follows:
* When a high voltage is applied at point A, the n-channel transistor (nMOS) below conducts, and the p-channel transistor (pMOS) above cuts off, which is equivalent to point Y being connected to ground (middle picture), and the voltage at point Y is low.

* When a low voltage is applied at point A, the n-channel transistor (nMOS) below is turned off, and the p-channel transistor (pMOS) above is turned on, which is equivalent to point Y being connected to the power supply (right picture), and the voltage at point Y is high.

We can see that CMOS circuits convert the switching characteristics of n-type and p-type transistors into high or low circuit output voltages

Defining a high physical voltage (such as $5V$) as `logical 1` (high level) and a low voltage (such as $0V$) as `logical 0` (low level),
we obtain the two basic states of signals in digital circuits!

<!--
## 通过晶体管搭建门电路
光表示`0`和`1`还不够, 我们还需要通过CMOS电路对`0`和`1`进行各种有意义的转换,
这个过程就是对数字信号进行运算.

-->
Building logic gates with transistors
Representing `0` and `1` is not enough,we also need to use CMOS circuits to perform various meaningful conversions on `0` and `1`.
This process is called digital signal processing.


<!--
### 非门(反相器)
考虑上文的CMOS电路, A点输入为`1`时, Y点输出为`0`;
而A点输入为`0`时, Y点输出为`1`.
这正好就是逻辑上的非运算!
这个门电路就是非门, 也称为反相器.
-->
### Not gate(Inverter)

Considering the CMOS circuit described above, when the input at point A is `1`, the output at point Y is `0`;
when the input at point A is `0`, the output at point Y is `1`.
This is exactly the logical NOT operation!
This gate circuit is a NOT gate, also known as an inverter.
| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/aa5b48e6a02556d4d67a7e443330b59ab82c1432.png) |
|:-:|
<!--
### 与非门
我们来看下面的另一个门电路.
直接看结构不容易理解功能, 我们需要梳理一下它的行为.
具体地, 由于P1和P2并联, 其中一者导通时, Y为`1`;
此外, 由于N1和N2串联, 两者均导通时, Y为`0`.
因此, 我们可以整理出如下表格:
-->
### NAND gate

Let's look at another gate circuit.
| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/0ec7da12ad700070140f4216bc8d596c89a9a92b.png) | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/0f3e91a78d2a3993f0b598a92dfa31362772ef34.png) |
|:-:|:-:|


It is difficult to understand the function by looking at the structure directly, so we need to sort out its behavior.
Specifically, since P1 and P2 are connected in parallel, when one of them is conductive, Y is `1`;
In addition, since N1 and N2 are connected in series, when both are conductive, Y is `0`.
Therefore, we can organize the following table:
<!--
| A | B | P1 | P2 | N1 | N2 | Y |
|:-:|:-:|:--:|:--:|:--:|:--:|:-:|
| 0 | 0 |<font color=green>导通</font>|<font color=green>导通</font>|<font color=brown>截止</font>|<font color=brown>截止</font>| 1 |
| 0 | 1 |<font color=green>导通</font>|<font color=brown>截止</font>|<font color=brown>截止</font>|<font color=green>导通</font>| 1 |
| 1 | 0 |<font color=brown>截止</font>|<font color=green>导通</font>|<font color=green>导通</font>|<font color=brown>截止</font>| 1 |
| 1 | 1 |<font color=brown>截止</font>|<font color=brown>截止</font>|<font color=green>导通</font>|<font color=green>导通</font>| 0 |
-->
| A | B | P1 | P2 | N1 | N2 | Y |
|:-:|:-:|:--:|:--:|:--:|:--:|:-:|
| 0 | 0 |<font color=green>conductivity</font>|<font color=green>conductivity</font>|<font color=brown>cut-off</font>|<font color=brown>cut-off</font>| 1 |
| 0 | 1 |<font color=green>conductivity</font>|<font color=brown>cut-off</font>|<font color=brown>cut-off</font>|<font color=green>conductivity</font>| 1 |
| 1 | 0 |<font color=brown>cut-off</font>|<font color=green>conductivity</font>|<font color=green>conductivity</font>|<font color=brown>cut-off</font>| 1 |
| 1 | 1 |<font color=brown>cut-off</font>|<font color=brown>cut-off</font>|<font color=green>conductivity</font>|<font color=green>conductivity</font>| 0 |
<!--
根据上表, 两个输入均为`1`时, 电路输出`0`, 否则输出`1`.
这正好就是逻辑上的与非运算!
这个门电路就是与非门.
-->
According to the table above, when both inputs are `1`, the circuit output is `0`, otherwise the output is `1`.
This is exactly the logical NAND operation!
This gate circuit is a NAND gate.
<!--
### 与门
将与非门的输出连接到非门的输入, 就得到了与门.
和与非门相比, 与门的逻辑符号的输出端少了一个圆圈.
在门电路的逻辑符号中, 这个圆圈表示取反.
-->
### AND gate
Connecting the output of a NAND gate to the input of a NOT gate results in an AND gate.
Compared to a NAND gate, the output terminal of an AND gate's logic symbol has one less circle.
In the logic symbol of a gate circuit, this circle represents inversion.
| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/72466e8188f8670925026caf7f61b00324fbf5d6.png) | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/83c39f6ac0d0bf09ef4db2d8c93a274088c9be8c.png) |
|:-:|:-:|

<!--
> #### todo::分析门电路
> 尝试分析以下门电路的行为和功能.
>

-->
> #### todo::Analyzing gate circuits
> Try to analyze the behavior and function of the following gate circuit.
>
> | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/27009d95075bd53667312a60e43c65d288ac0557.png) |
> |:-:|

> #### todo::Or gate transistor structure
> The following is the logical symbol for an OR gate. Try to draw the transistor structure of an OR gate.
>
> | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/7aa6ddb2c757445fe93d80432d054b0b1c4cd0c3.png) |
> |:-:|

<!--
### 三输入与非门
上面介绍的门电路都是两个输入的, 有时候需要对多个输入信号进行运算.
一个例子是三输入与非门, 如果用逻辑表达式来表示其行为, 则有`Y = ~(A & B & C)`, 这里的`&`表示与操作.
根据这个逻辑表达式, 我们可以通过一个两输入与门和一个两输入与非门来搭建一个三输入与非门(左图).
另一种方式是使用晶体管来搭建三输入与非门(右图).
-->
### Three-input NAND gate
The gate circuits described above all have two inputs. Sometimes it is necessary to perform operations on multiple input signals.
One example is a three-input NAND gate. If we express its behavior using a logical expression, we have `Y = ~(A & B & C)`, where `&` represents the AND operation.

Based on this logical expression, we can build a three-input NAND gate using a two-input AND gate and a two-input NAND gate (left picture).
Another way is to use transistors to build a three-input NAND gate (right picture).

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/afd58e034589dad1448a01dd42bb5ac6440e56ba.png) | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/84906a5d09cc67eed71200b46c9877b39f9cf542.png) |
|:-:|:-:|

<!--
> #### todo::对比两种实现的晶体管所需要的数量
> 不难分析, 上述晶体管结构同样实现了三输入与非门的功能.尝试对比两种实现方式中所需晶体管的数量.
> Hint: 对于用门电路搭建的设计,
> 其晶体管数量可看作是设计中用到的所有门电路的晶体管数量之和.
-->
> #### todo::Comparison of the number of transistors required for the two implementations
> It is not difficult to analyze that the above transistor structure also realize the function of a three-input NAND gate.Try to compare the number of transistors required in the two implementations.
>
> Hint: For designs built with gate circuits,
> The number of transistors can be considered as the sum of the number of transistors used in all gate circuits in the design.

<!--
> #### comment::全定制电路: 通过晶体管设计电路
> 在晶体管层次设计的电路称为全定制电路.
> 通过三输入与非门的例子, 我们可以看到, 全定制电路所需要的晶体管数量更少, 因此电路面积也更小.
> 在实际生产中, 除了面积更小之外, 全定制电路的主频也更高, 功耗更低.
> 现代处理器芯片包含动辄上亿个晶体管, 全部使用全定制电路来开发是不现实的.
> 对于超大规模集成电路的设计, 更常见的是采用的是半定制电路设计方法.
-->
> #### comment::Fully customized circuitry: Circuitry designed using transistors
> Circuits designed at the transistor level are called fully customized circuits.
> Through the example of a three-input NAND gate, we can see that fully customized circuits require fewer transistors and therefore have a smaller circuit area.
> In actual production, in addition to having a smaller area, fully customized circuits also have a higher main frequency and lower power consumption.
>
> However, designing fully customized circuits is difficult and the development cycle is long.
>
>Modern processor chips contain hundreds of millions of transistors, and it is impractical to develop them all using fully customized circuits. For the design of very large-scale integrated circuits, it is more common to use a semi-custom circuit design method.
>
> The design of semi-custom circuits can be further divided into two methods: the standard cell-based design method and the gate array-based design method.
>
> The former involves pre-designing some commonly used logic units, such as AND gates, OR gates, and flip-flops, using a fully custom approach.
>
> These logic units are referred to as standard cells.Then, large-scale circuits are constructed using these standard cells.
> Returning to the example of the three-input NAND gate, if the two-input AND gate and the two-input NAND gate are considered standard cells, then to construct the three-input NAND gate using them can be regarded as a semi-custom circuit design method.
>
> As for design methods based on gate arrays, a common example is FPGA.
>
> However, we don't plan to use FPGA in the future. Interested students can search for relevant information.
>
> In modern processor chip design, semi-custom circuit design methods based on standard cells are used in most cases.
>
> Only when pursuing ultimate performance (e.g. when a company's products dominate the market by pursuing high performance) will some of the core modules in the circuit be fully customized.

<!--
## 异或门
异或门用于进行异或(eXclusive OR, XOR)运算, 其逻辑符号如下图所示.异或是一个特殊的运算, 通常在处理逻辑数据时使用, 其真值表如下:



   异或运算的行为有两种理解方式:
   1. 异或的"异"表示"不同", 因此当输入A和B不同时, 结果为`1`, 否则为`0`.
   1. 或运算表示两个输入中至少一个为`1`.
   和或运算不同, 异或运算排除了两个输入均为`1`的情况,
   因此也称为"排斥或", 其中的"排斥"和英文exclusive
   对应; 相对地, 或运算也称为"相容或", 表示允许两个输入均为`1`.

   有了真值表, 我们可以得到相应的逻辑表达式, 相应步骤如下:1. 根据输入情况描述一个表项.
   对于真值表中的每个表项, 考虑每个输入信号, 若输入为`1`, 则取输入信号本身;
   若输入为`0`, 则取输入信号的非.
   对这些信号进行与运算, 即可得到该表项的描述.
   例如, 表中`A = 1, B = 0`的对应描述是`A & ~B`.

   2. 将输出为`1`的表项的对应描述组合成最终的逻辑表达式.
   考虑真值表中输出为`1`的表项, 对这些表项的描述进行或运算即可.
   例如, 在异或运算的真值表中, 输出为`1`的情况有两种,
   一种是`A = 1, B = 0`, 对应描述是`A & ~B`;
   另一种是`A = 0, B = 1`, 对应描述是`~A & B`.
   将这两种描述进行或运算, 得到异或运算的逻辑表达式`Y = A ^ B = (A & ~B) | (~A & B)`.

   上述步骤总是可以将一个真值表转换为一个由与运算和或运算组成的逻辑表达式.
根据这个逻辑表达式, 你可以很容易地用与门和或门搭建出相应的电路.
-->
## XOR gate

An XOR gate is used to perform exclusive OR (XOR) operations. Its logic symbol is shown in the figure below.

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/1ac31d265c8c7b5c399114c3beaa45e8d78af000.png) |
|:-:|

XOR is a special calculation typically used when processing logical data. Its truth table is as follows:

| A | B | Y |
|:-:|:-:|:-:|
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |

There are two ways to understand the behavior of the XOR operation:

1. The "X" in XOR stands for "different," so when inputs A and B are different, the result is `1`,otherwise, it is `0`.

1. The OR operation indicates that at least one of the two inputs is `1`.
Unlike the AND operation, the XOR operation excludes the case where both inputs are `1`,
so it is also called "exclusive OR," where ‘exclusive’ corresponds to the English term "exclusive",Conversely, the OR operation is also called "compatible OR," indicating that both inputs can be `1`.

With the truth table, we can obtain the corresponding logical expression. The corresponding steps are as follows:
1. Describe a table entry based on the input conditions.
For each table entry in the truth table, consider each input signal. If the input is `1`, take the input signal itself;
if the input is `0`, take the negation of the input signal.
Perform a bitwise AND operation on these signals to obtain the description of the table entry.
For example, the description corresponding to `A = 1, B = 0` in the table is `A & ~B`.
2. Combine the corresponding descriptions of table entries with an output of `1` into the final logical expression.

Consider the table entries where the output is `1` in the truth table. Perform a logical OR operation on the descriptions of these table entries.
For example, in the truth table for the XOR operation, there are two cases where the output is `1`:
One is `A = 1, B = 0`, corresponding to the description `A & ~B`;
the other is `A = 0, B = 1`, corresponding to the description `~A & B`.
Performing a logical OR operation on these two descriptions yields the logical expression for the XOR operation: `Y = A ^ B = (A & ~B) | (~A & B)`.



Unlike the AND operation, the XOR operation excludes the case where both inputs are `1`,
so it is also called "exclusive OR," where ‘exclusive’ corresponds to the English term "exclusive";
Conversely, the OR operation is also called "compatible OR," indicating that both inputs can be `1`.

With the truth table, we can derive the corresponding logical expression, following these steps:
1. Describe a table entry based on the input conditions.
For each table entry in the truth table, consider each input signal: if the input is `1`, take the input signal itself;
If the input is `0`, take the negation of the input signal.
Perform a AND operation on these signals to obtain the description of the table entry.
For example, the corresponding description for `A = 1, B = 0` in the table is `A & ~B`.
2. Combine the corresponding descriptions of the table entries with an output of `1` to form the final logical expression.
   Consider the table entries with an output of `1` in the truth table, and perform a logical OR operation on the descriptions of these entries.
   For example, in the truth table for the XOR operation, there are two cases where the output is `1`:
   one is `A = 1, B = 0`, with the corresponding description being `A & ~B`;
   the other is `A = 0, B = 1`, corresponding to the description `~A & B`.
  Performing a logical OR operation on these two descriptions yields the logical expression for the XOR operation: `Y = A ^ B = (A & ~B) | (~A & B)`.

The above steps can always convert a truth table into a logical expression composed of AND and OR operations.
Based on this logical expression, you can easily build the corresponding circuit using AND gates and OR gates.

<!--
> #### comment::卡诺图化简
> 你可能会在一些数字电路的教科书上听说过这个技术; 如果你没有听说过, 那很好.
> 你可能需要为了考试而学习它, 但在"一生一芯"这种面向动手实践的项目中, 你几乎不会使用它.
> 我们想说的是, 这个技术的可扩展性非常低:
> 在真实的项目中, 你面对的变量数量很可能是5个以上, 甚至多达十几个,
> 要用卡诺图去化简这样的表达式, 效率是很低的.
> 事实上, 现代工具通常会采用QMC算法或者espresso算法来对逻辑表达式进行化简,
> 因此, 你很少需要对逻辑表达式进行手动化简,
> 上文介绍的方法已经足够帮助你写出一个正确的逻辑表达式, 化简的工作交给现代工具即可.
> 如果你感兴趣, 你可以搜索相关资料来进一步了解这些算法.
-->
> #### comment::Karnaugh Map Simplification
> You may have heard of this technique in some digital circuit textbooks;if you haven't, that's fine. You may need to learn it for exams, but in hands-on projects such as "One Student One Chip," you won't ever use it.
>
> What we express is that this technology has very low scalability: In real-world projects, the number of variables you encounter is likely to be five or more, and could even reach as high as a dozen or more. Using a Karnaugh map to simplify expressions is highly inefficient. In fact, modern tools typically use the QMC algorithm or the Espresso algorithm to simplify logical expressions, Therefore, you rarely need to manually simplify logical expressions, The methods described above are sufficient to help you write a correct logical expression; the simplification work can be given to modern tools. If you are interested in it, you can search for related information to learn more about these algorithms.

> #### todo::Build an XOR gate using other logic gates.
> Try to build an XOR gate in Logisim using the gate circuits mentioned above.
> After building up, using simulation to check whether your plan is correct.
>
> You have verified that your solution is correct, to calculate how many transistors your solution uses.

<!--
> #### option::寻找更优的搭建方案
> 不考虑全定制电路, 尝试寻找一种晶体管数量最少的方案来实现异或门,
> 并在Logisim中测试你的方案是否正确.
> Hint: 有一种方案只需要使用14个晶体管, 因此最优方案的晶体管数量应不多于14个.
-->
> #### option::Looking for a better construction plan
> Without considering fully customized circuits, try to find a solution with the fewest transistors to implement an XOR gate and test your solution in Logisim to see if it is correct.
>
> Hint:There is a solution that requires only 14 transistors, so the optimal solution should use no more than 14 transistors.

> #### option::Fully customized circuit for XOR gates
> The picture below shows a fully customized implementation of an XOR gate. Try to analyze its behavior.
>
> | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/d177bb7997ba32e4cef2b06bdf2f084745e0cc08.png) |
> |:-:|

> #### todo::Design XNOR gate
> There is another operation called the "XNOR" operation. When inputs A and B are the same, the result is `1`; otherwise, it is `0`.
> The XNOR operation can be considered the inverse of the result of the XOR operation.
>
> Try to build an XNOR gate in Logisim using the gate circuits mentioned above.
> After building it, use the simulation to check if your design is correct.

> #### option::Fully customized circuit for XNOR gates
> Try to build a XNOR gate using the minimum number of transistors.
>
> Hint:There is a solution that only requires six transistors, so the optimal solution should use no more than six transistors.

## Machine representation of integers
We already know that CMOS circuits can represent and deal with `0` and `1`.

However, the physical world we live in is not limited to `0` and `1`.
Therefore, we need to consider how to use `0` and `1` to represent various types of information in the physical world.
This representation method is called "encoding."
There is a lot of information in the physical world. Let's first consider how to represent integers.

<!--
### 整数的二进制编码
我们在小学甚至幼儿园的时候就已经对"数"的概念有基本的认识.
在日常生活中, 我们使用的是十进制(decimal)计数法.
一个十进制数的真值(即其表示的实际数值), 可以通过加权求和(weighted sum)展开式得到.
例如, 十进制数`734`的加权展开如下:
通常, 对于$n$位$b$进制数$a_{n-1}a_{n-2}\dots a_1a_0$, 其真值可通过以下加权求和展开式得到:
其中$b$称为基(base), $b^i$称为每一位的权(weight).
令$b=2$, 并让$a_i$只在`0`和`1`中取值, 我们就得到了二进制(binary)计数法.
由于十进制也使用`0`和`1`, 一般在书面上需要添加一些前缀或下标, 表明某数采用二进制表示:
有的编程语言通过前缀`0b`表示二进制数, 如`0b00101110`;
-->
### Binary encoding of integers
We already have a basic understanding of the concept of "numbers" in secondary school and even kindergarten.

In daily life, we use the decimal counting system.
The true value of a decimal number (i.e., the actual value it represents) can be obtained through a weighted sum expansion.

For example, the weighted expansion of the decimal number `734` is as follows:
$$734 = 100\times7+10\times3+1\times4=10^2\times7+10^1\times3+10^0\times4$$


For an $n$-digit base-$b$ number $a_{n-1}a_{n-2}\dots a_1a_0$, its true value can be obtained through the following weighted sum expansion formula:
$$\sum_{i=0}^{n-1}a_ib^i=a_{n-1}b^{n-1}+a_{n-2}b^{n-2}+\dots+a_1b^1+a_0$$

Among them, $b$ is called the base, and $b^i$ is called the weight of each digit.

Let $b=2$, and let $a_i$ take values only from `0` and `1`, and we obtain the binary counting method.

Since the decimal system also uses `0` and `1`, it is generally necessary to add some prefixes or subscripts in writing to indicate that a number is represented in binary:
Some programming languages use the prefix `0b` to denote binary numbers, such as `0b00101110`;
<!--
有的教材采用下标`B`表示二进制数, 如$00101110_{B}$.
在讲义中, 我们主要采用前缀`0b`.
例如, 二进制数`0b00101110`的真值是
-->

Some textbooks use the subscript `B` to denote binary numbers, such as $00101110_{B}$.
In this lecture notes, we mainly use the prefix `0b`.
For example, the truth value of the binary number `0b00101110` is
$$2^7\times0+2^6\times0+2^5\times1+2^4\times0+2^3\times1+2^2\times1+2^1\times1+2^0\times0=46$$
<!--
要将一个二进制数转换为十进制数, 可通过如下加权求和展开式求得:
-->
To convert a binary number to a decimal number, you can use the following weighted sum expansion formula to obtain decimal number:
$$\sum_{i=0}^{n-1}a_i2^i=a_{n-1}2^{n-1}+a_{n-2}2^{n-2}+\dots+a_12^1+a_0$$

<!--
要将一个十进制数转换为二进制数, 就需要求出加权求和展开式中各个二进制位$a_{n-1}a_{n-2}\dots a_1a_0$.
为此, 我们可以将上述加权求和展开式改写如下:
-->
To convert a decimal number to a binary number, we need to find the weighted sum expansion of each binary digit $a_{n-1}a_{n-2}\dots a_1a_0$.
To do this, we can rewrite the above weighted sum expansion as follows:
$$\begin{array}{ll}
\displaystyle\sum_{i=0}^{n-1}a_i2^i&=a_{n-1}2^{n-1}+a_{n-2}2^{n-2}+\dots+a_12^1+a_0 \\
&=(a_{n-1}2^{n-2}+a_{n-2}2^{n-3}+\dots+a_1)\times2+a_0 \\
&=((a_{n-1}2^{n-3}+a_{n-2}2^{n-4}+\dots+a_2)\times2+a_1)\times2+a_0 \\
&=\dots \\
&=(\dots(((a_{n-1}\times2+a_{n-2})\times2+a_{n-3})\times2+a_{n-4})\dots\times2+a_1)\times2+a_0 \\
\end{array}$$
<!--
通过上述改写, 我们可以发现, 如果将十进制数不断除以2,
这个过程中得到的余数就分别对应$a_0,a_1,\dots,a_{n-1}$.
我们可以使用"短除法"来列出这一计算过程, 例如, 对于十进制数`46`:
-->
Through the above rewriting, we can see that if we continuously divide a decimal number by 2,
the remainders obtained in this process correspond to $a_0, a_1, \dots, a_{n-1}$.
We can use "short division" to list this calculation process. For example, for the decimal number `46`:
<!--
```
2 | 46   -> 0          ^  低位
  +----                |
 2 | 23   -> 1         |
   +----               |
  2 | 11   -> 1        |
    +----              |
   2 | 5    -> 1       |
     +----             |
    2 | 2    -> 0      |
      +----            |
     2 | 1    -> 1     |  高位
       +----
         0 (商为0, 结束)
```
-->
```
2 | 46   -> 0          ^  lower-bit
  +----                |
 2 | 23   -> 1         |
   +----               |
  2 | 11   -> 1        |
    +----              |
   2 | 5    -> 1       |
     +----             |
    2 | 2    -> 0      |
      +----            |
     2 | 1    -> 1     |  higher-bit
       +----
         0 (Business is zero, end.)
```
<!--
最后将所得余数从高位到低位组合, 得到`0b101110`, 即为`46`的二进制表示,
与上文提到的`0b00101110`在省略高位的`0`后一致.

-->
Finally, combining the remainders from high to low to obtain `0b101110`, which is the binary representation of `46`.
Consistent with the aforementioned `0b00101110` after omitting the high-bit `0`.
<!--
### 整数的十六进制编码

二进制虽然能被数字电路直接处理, 但对人来说很难阅读和记忆.
例如, 对于二进制数`0b1011111011101111`, 我们很难一眼就看出来有多少位.
此外, 在二进制数和十进制数之间互相转换, 需要经过一定的数学计算过程,
对人来说, 这些计算过程通常无法快速完成.

为了解决这些问题, 计算机领域还通常采用十六进制(hexadecimal)计数法.
十六进制计数法中, 每一位数字有16种可能, 除了`0~9`以外,
还有`a`, `b`, `c`, `d`, `e`, `f`(大写亦可),
数值上分别表示`10`, `11`, `12`, `13`, `14`, `15`.
有的编程语言通过前缀`0x`表示十六进制数, 如`0xbeef`;
有的教材采用下标`H`表示十六进制数, 如$\mathrm{beef}_{H}$.
在讲义中, 我们主要采用前缀`0x`.
类似地, 在十进制和十六进制之间进行转换, 可以通过加权求和展开式和短除法来进行.
例如, 十六进制数`0xbeef`的加权展开如下:

虽然数字电路无法直接处理十六进制数, 但由于$16=2^4$,
因此可以在1位十六进制数和4位二进制数之间相互转换,
-->
### Hexadecimal encoding of integers

Although binary can be processed directly by digital circuits, it is difficult for people to read and remember.

For example, for the binary number `0b1011111011101111`, it is hard to tell at a glance how many bits it has.

In addition, converting between binary and decimal numbers requires certain mathematical calculations,which are usually not to finish quickly.
In order to solve these problems,the computer domain also usually uses the hexadecimal counting system.

In the hexadecimal number method, each digit has 16 possible values, in addition to `0~9`,
there are also `a`, `b`, `c`, `d`, `e`, `f` (uppercase is also acceptable),which represent the values `10`, `11`, `12`, `13`, `14`, `15`, respectively.

Some programming languages use the prefix `0x` to represent hexadecimal numbers, such as `0xbeef`; Some textbooks use the subscript `H` to represent hexadecimal numbers, such as $\mathrm{beef}_{H}$.


In this lecture note, we mainly use the prefix `0x`.
Similarly, conversions between decimal and hexadecimal can be performed using weighted sum expansion and short division.

For example, the weighted expansion of the hexadecimal number `0xbeef` is as follows:
$$16^3\times11+16^2\times14+16^1\times14+16^0\times15=48879$$

Although digital circuits cannot directly process hexadecimal numbers, since $16=2^4$,it is possible to convert between 1-bit hexadecimal numbers and 4-bit binary numbers,which greatly improves the efficiency of conversion between hexadecimal and binary.
<!--
这大大提升了十六进制和二进制之间的转换效率.
例如, 对于二进制数`0b1011111011101111`, 我们可以从右到左每4位分成一组(高位不足4位时补`0`),
直接写出每组对应的十六进制数字:
-->
For example, for the binary number `0b1011111011101111`, we can group every 4 bits from right to left (padding with `0`s when the high-order bits are less than 4),
and directly write out the corresponding hexadecimal digits for each group:
```
     1011 1110 1110 1111
      |    |    |    |
      b    e    e    f
```
<!--
因此, 该二进制数对应的十六进制数即为`0xbeef`.
可以看到, 和二进制表示的`0b1011111011101111`相比, 十六进制表示的`0xbeef`更加简洁紧凑.
-->
Therefore, the hexadecimal number corresponding to this binary number is `0xbeef`.
You can see , compared to the binary representation `0b1011111011101111`, the hexadecimal representation `0xbeef` is more brief and compact.

<!--
> #### option::八进制(octal)计数法
> 在计算机中, 有的场景也会使用八进制, 其原理和十六进制类似,
> 感兴趣的同学可以自行推导八进制和十进制之间, 以及八进制和二进制之间的转换方法.
-->
> #### option::Octal number method
> In computers, octal is also used in some scenarios, and its principle is similar to that of hexadecimal.
> Interested students can derive the conversion methods between octal and decimal, as well as between octal and binary, on their own.

<!--
## 通过门电路搭建基本组合逻辑电路
有了门电路后, 我们就可以通过多个门电路的组合来搭建一些在数字电路中常用的模块了.
-->
## Build basic combinational logic circuits using gate circuits

With gate circuits, we can build some modules commonly used in digital circuits by combining multiple gate circuits.

<!--
### 译码器
译码器(decoder)是一种将$k$位输入转换成最多$2^k$种不同输出的电路.一类常见的译码器是n选1译码器(1-of-n decoder), 它有$n$位输入, $2^n$位输出, 其行为如下:
将输入解析为一个二进制数值$x$, 并使输出的第$x$位为`1`, 其他位为`0`.由于该输出仅有1位为`1`, 因此也称为"独热码"(One-hot).例如, 一个2-4译码器有2位输入$A_1A_0$, 有4位输出$Y_3Y_2Y_1Y_0$, 其真值表和电路图如下:
-->
### Decoder

A decoder is a circuit that converts a $k$-bit input into to $2^k$ different outputs.

A common type of decoder is the 1-of-n decoder, which has $n$ bits of input and $2^n$ bits of output. Its behavior is as follows:

It parses the input into a binary value $x$ and sets the $x$th bit of the output to `1`, with all other bits set to `0`.

Since only one bit of the output is `1`, it is also called a "one-hot code."

For example, a 2-4 decoder has a 2-bit input $A_1A_0$ and a 4-bit output $Y_3Y_2Y_1Y_0$. Its truth table and circuit diagram are as follows:

| $A_1$ | $A_0$ |   | $Y_3$ | $Y_2$ | $Y_1$ | $Y_0$ |
|:-----:|:-----:|:-:|:-----:|:-----:|:-----:|:-----:|
|   0   |   0   |   |   0   |   0   |   0   |   1   |
|   0   |   1   |   |   0   |   0   |   1   |   0   |
|   1   |   0   |   |   0   |   1   |   0   |   0   |
|   1   |   1   |   |   1   |   0   |   0   |   0   |

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/cff133cf0330c0254c2f4d0997d4c66c487dbccc.png) |
|:-:|

<!--
> #### todo::搭建2-4译码器
> 尝试在Logisim中用门电路搭建一个2-4译码器, 它有2位输入, 4位输出.
> 搭建后, 通过仿真检查你的方案是否正确.
> Logisim中也直接提供了译码器等现成的元件,在计算机中, n选1译码器常用于实现寻址的部分功能,
此时译码器的输入即为地址, 输出则是选择信号, 其中与地址对应的选择信号为`1`.
-->
> #### todo::Build 2-4 decoders
> try to build a 2-4 decoder in Logisim using gate circuits. It has 2 input bits and 4 output bits.
> After building it, use simulation to check if your design is correct.
>
> Logisim also provides ready-made components such as decoders,but we still require everybody to build them using gate circuits,in order to better learn the basic principles of digital circuits.

In computers, n-to-1 decoders are often used to implement part of addressing functions.
At the time, the input of the decoder is the address, and the output is the select signal, where the selection signal corresponding to the address is `1`.

<!--
> #### hint::配置门电路输入的数量和极性
> 在Logisim中, 用户可以配置门电路输入的数量和极性,> 其中极性属性可以选择一个信号在送入逻辑门前是否取反,
> 若是, 相应输入端将多出一个圆圈, 表示取反.
> 具体配置方式可阅读官方文档中关于门电路的内容.
-->
> #### hint::Configure the number and polarity of gate circuit inputs
> In Logisim, users can configure the number and polarity of gate circuit inputs.
> The polarity attribute can be used to select whether a signal should be inverted before being sent to the logic gate.
> If it is, an additional circle will appear on the corresponding input terminal to indicate inversion.
> For specific configuration methods, please refer to the official documentation on gate circuits.

> #### comment::Addressing and Addressing
> "Address" is a technical term in the field of computer science, but we can also understand it through examples from daily life.
> You have probably used Excel software to view tables. In a table, each row stores an item,
> and multiple items are typically stored consecutively in increasing by row number.
> In Excel, the row number is also displayed on the far left, allowing you to quickly determine which row you are currently viewing.
> If you need to view the item in row 176, you wouldn't start from row 1 and check each row to see if it's row 176,
> However, you can simply drag the scroll bar to quickly locate the 176th row.
> This is because row numbers are continuous, allowing you to quickly skip over previous rows.
>
> In fact, many data sets in computers are also stored continuously like tables.
> For example, memory can be viewed as a massive table, where each row is a storage unit capable of holding 1 byte of data.
> stick, this table has $2^{32}=4294967296$ rows.
> Similarly, thanks to the continuity between storage units, if a computer needs to access one of these storage units.
> It doesn't need to check sequentially starting from the first storage unit,instead, it can quickly locate the corresponding storage unit using a "row number."
> This "row number" is referred to as an ‘address’ in a computer, and the process of locating the corresponding storage unit based on the address is called "addressing."
>
> The reason why computers can quickly find the corresponding storage unit through addresses is that computers can quickly convert addresses into a set of selection signals through n-to-1 decoders, and then select the target data through this group of selection signals.

<!--
> #### todo::Logisim中的子电路功能
> 译码器在后续的数字电路设计中会经常用到, 为了避免用户重复设计相同的电路,
> Logisim提供了子电路功能, 相应电路只需要设计一次, 后续即可反复实例化.
> 具体操作方式请阅读官方手册中的`Subcircuits(子电路)`部分.
> 学习如何使用Logisim的子电路功能后, 尝试将你设计的译码器封装成子电路.
-->
> #### todo::Subcircuit Function in Logisim
> Decoders are frequently used in subsequent digital circuit designs. To avoid users having to redesign the same circuit repeatedly,
> Logisim provides a subcircuit function, allowing the corresponding circuit to be designed once and then instantiated repeatedly in subsequent designs.
> For specific instructions, please refer to the "Subcircuits" section of the official manual.
>
> After learning how to use Logisim's subcircuit function, try to encapsulate the decoder you designed into a subcircuit.

<!--
> #### todo::译码器的扩展
> 3-8译码器有3位输入, 8位输出.
> 尝试实例化两个2-4译码器, 并添加少量门电路, 从而实现3-8译码器的功能.
> 搭建后, 通过仿真检查你的方案是否正确.
> 在Logisim中, 模块的输入信号和输出信号通常连接到一些输入或输出元件,
> 通过这些元件的状态, 可以得知输入信号或输出信号的当前值.
> 如果你想了解中间信号的当前值, 可以使用元件库提供的`Probe(探针)`元件,
> 你可以在Logisim元件库的`Wiring(线路)`类别下找到它, 具体使用方式请RTFM.
-->
> #### todo::Decoder extension
> The 3-8 decoder has 3 input and 8 output.
> Try to instantiate two 2-4 decoders and add a few logic gates to implement the functionality of the 3-8 decoder.
> After building, using simulation to verify that your design is correct.
>
> In Logisim, the input signals and output signals are typically connected to input or output components,
> and the current values of the input signals or output signals can be determined by the state of these components.
> If you want to know the current value of middle signals, you can use the `Probe` component provided in the component library.
> You can find it in the `Wiring` category of the Logisim component library. For specific use instructions, please find the friendly mannual.

<!--
> #### hint::配置元件的数据位宽
> 在Logisim中, 用户可以配置元件的数据位宽.
> 例如, 当一个与门的数据位宽设置为`4`时, 表示每个端口可以连接4位信号,
> 此时功能上等价于通过4个1位的与门分别对4位信号中的每一位进行处理.
> 通过数据位宽的功能, 用户可以方便地设计出处理模式相似的电路.
> 具体配置方式可阅读官方文档中关于门电路的内容.
> 同时, 你可能需要抽取一组信号中的若干位, 或者将若干位信号组合成一组信号来整体连接,
> 这需要用到`Splitter(分线器)`, 你可以在Logisim元件库的`Wiring(线路)`类别下找到它, 具体使用方式请RTFM.
-->
> #### hint::Data width of configuration components
> In Logisim, users can configure the data bit width of components.
> For example, when the data bit width of an AND gate is set to `4`, it means that each port can connect to 4-bit signals.
> At this time, it is functionally equivalent to using 4 1-bit AND gates to process each bit of the 4-bit signal separately.
> With the data bit width function, users can easily design circuits with similar processing modes.
> For specific configuration methods, please refer to the official documentation on gate circuits.
>
> Additionally, you may need to extract several bits from a group of signals or combine several bits of signals into a single group for overall connection,which requires the use of a `Splitter`. You can find it in the `Wiring` category of the Logisim component library. For specific usage instructions, please find the friendly mannual.(RTFM)


<!--
另一类常见的译码器是转码器(code translator),
它可以按照指定的规则将一种编码的输入转换成另一种编码的输出.
和n选1译码器不同, 转码器不要求输出中最多包含1个`1`.
转码器的一个常见应用是七段数码管译码器(7-segment decoder).
七段数码管是一个由7段发光二极管按"8"字型排列组成的输出元件, 其示意图如下图所示.
图中用字母a-g分别标识每一段发光二极管的位置, 只要某控制信号有效,
相应的发光二极管就会被点亮.
图中还有一个用h标识的小数点, 在一些需要使用小数的场景会使用.七段数码管译码器的功能是将一组4位的输入信号解析为二进制整数,然后输出一组用于控制七段数码管亮灭情况的控制信号,
使得七段数码管可以显示和输入对应的数字.
-->
Another common type of decoder is a code translator,which can convert an input encoded in one format into an output encoded in another format according to specified rules.
Unlike an n-to-1 decoder, a code translator doesn't require the output to contain at most one `1`.

A common application of a code translator is a 7-segment decoder.

A 7-segment tube display is an output device composed of seven segments of light-emitting diodes arranged in an "8" shape, as shown in the photo below.

The letters a-g are used to identify the position of each segment of light-emitting diodes. As long as a control signal is active,
the corresponding light-emitting diode will be lit up.
There is also a decimal point marked with the letter h, which is used in some scenarios that require decimals.

```txt
   a
  ---
f| g |b
  ---
e|   |c
  ---    .h
   d
```

The function of a seven-segment tube display decoder is to parse a set of four-digit input signals into binary integers,then output a set of control signals used to Control signal for controlling the lighting and extinguishing of seven-segment digital tubes,so that the seven-segment digital tube can display and input the corresponding numbers.
<!--
例如:

上述例子展示了如何在七段数码管中显示数字`4`.
具体地, 显示数字`4`需要点亮七段数码管中的b, c, f, g这4根发光二极管,因此相应的控制信号需要设置为有效(此处假设高电平有效, 实际使用中需要核实七段数码管元件的输入极性);对于其他无需点亮的发光二极管, 相应的控制信号需要设置为无效.若按照a-h从左到右排列, 输出的控制信号应为`01100110`.
因为`4`对应的二进制表示为`0b0100`, 因此七段数码管译码器需要在输入为`0100`时输出`01100110`.
按照同样的方式, 可分析出0-9各数字的输入输出情况.

-->
For example:
```txt
input    output
        abcdefgh
 0100   01100110
```

The above example demonstrates how to display the number `4` on a seven-segment display to show.

Specifically, to display the number `4`, the b, c, f, and g segments of the seven-segment display must be illuminated,so the corresponding control signals must be set to active (here assuming high-level active; in actual use, verify the input polarity of the seven-segment tube display component);


For other diodes that don't need to be illuminated, the corresponding control signals must be set to inactive.

If arrange from left to right as a-h, the output control signal should be `01100110`.
Since `4` corresponds to the binary representation `0b0100`, the seven-segment display decoder must output `01100110` when the input is `0100`.
Using the same method, You can analyzed the input and output conditions for each digit from 0 to 9.

<!--
> #### todo::搭建七段数码管译码器
> 尝试在Logisim中通过门电路搭建一个七段数码管译码器, 它有4位输入和8位输出,
> 分别与拨码开关和七段数码管相连.
> 七段数码管译码器支持十进制数字的显示, 即当输入对应0-9时,
> 七段数码管显示对应的数字; 对于其他输入, 七段数码管只显示小数点.
> 搭建后, 通过仿真检查你的实现是否正确.
> Hint:
> * 七段数码管元件可在元件库中找到, 实例化后,
>   可以通过将鼠标指针悬停在元件的端口上, 来查看该端口的功能描述.
> * 可以先用n选1译码器生成一组独热码,
>   然后再通过一层或门来分别决定每个发光二极管在哪些输入的情况下应该点亮.
-->
> #### todo::Build a seven-segment digital tube decoder
> Try to build seven-segment display decoder using logic gates in Logisim. It has 4 input and 8 output,connected to a DIP switch and a seven-segment digital tube display, respectively.
> The seven-segment display decoder supports the display of decimal numbers, meaning that when the input corresponds to 0-9,
> he seven-segment display shows the corresponding number; for other inputs, the seven-segment digital tube display only shows the decimal point.
> After building, using simulation to check if your implementation is correct.
>
> Hint:
> * seven-segment display components can be found in the component library. After instantiation,you can hover the mouse pointer over the component's port to view the port's functional description.
> * You can first use an N-to-1 decoder to generate a group of unique codes,then use a layer of AND gates to determine which inputs should cause each LED to light up.

<!--
> #### todo::搭建七段数码管译码器(2)
> 尝试在Logisim中通过门电路搭建一个支持十六进制数字的七段数码管译码器.
> 和上述的十进制数字相比, 当输入对应10-15时,
> 七段数码管分别显示A, b, C, d, E, F.
> 搭建后, 通过仿真检查你的实现是否正确.
-->
> #### todo::Build seven-segment display decoder (2)
> Try to build a seven-segment display decoder that supports hexadecimal numbers through using gate circuits in Logisim.
> Compared to the decimal numbers mentioned above, when the input corresponds to 10-15,the seven-segment display display shows A, b, C, d, E, and F, respectively.
> After building it, using simulation to check if your implementation is correct.

<!--
### 编码器
编码器(encoder)的功能和n选1译码器相反, 它用于将独热码转换成相应的二进制数值.
具体地, 编码器有$2^n$位输入, $n$位输出,
如果输入为独热码, 且第$x$位为1, 则输出$x$的二进制数值;如果输入不为独热码, 则输出是未定义的.例如, 一个4-2编码器有4位输入$A_3A_2A_1A_0$, 有2位输出$Y_1Y_0$, 其真值表如下.
下表在输入不为独热码时, 输出为`X`, 表示输出未定义(undefined), 可为任意值.
-->
### Encoder

The function of an encoder is the opposite of that of an n-to-1 decoder; it is used to convert a unique code into the corresponding binary value.
Specifically, an encoder has $2^n$ input bits and $n$ output bits.
If the input is a One-hot code and the $x$th bit is 1, then the output is the binary value of $x$.

If the input is not a One-hot code, the output is undefined.


For example, a 4-2 encoder has 4-bit input $A_3A_2A_1A_0$ and 2-bit output $Y_1Y_0$, with the following truth table.
In the table below, when the input isn't a One-hot code, the output is `X`, indicating that the output is undefined and can be any value.

| $A_3$ | $A_2$ | $A_1$ | $A_0$ |   | $Y_1$ | $Y_0$ |
|:-----:|:-----:|:-----:|:-----:|:-:|:-----:|:-----:|
|   0   |   0   |   0   |   1   |   |   0   |   0   |
|   0   |   0   |   1   |   0   |   |   0   |   1   |
|   0   |   1   |   0   |   0   |   |   1   |   0   |
|   1   |   0   |   0   |   0   |   |   1   |   1   |

<!--
> #### comment::理解未定义的输出
> 有一些运算或模块需要满足一定的前提条件, 才能得到有意义的输出.
> 一个例子是数学上的除法运算.
> 你多少会听说过类似的说法: 除数为`0`时, 是不能除的.
> 这里的"不能除"这三个字其实是自然语言, 并不是数学系统中的语言.
> 如果用数学语言来描述, "除数不为`0`"是进行除法运算的前提条件,
> 当除数为`0`时, 这个前提条件不再成立, 此时无法定义出一个正确且有意义的计算结果,
> 因此也称结果是未定义的.
> 上述编码器的例子也是类似的, "输入为独热码"是编码器正确工作的前提条件,
> 当输入不为独热码时, 这个前提条件不再成立, 此时无法定义出一个正确且有意义的输出.
> 但具体到数字电路层次, 输出信号要么为`0`, 要么为`1`,
> 但无论取什么值, 输出信号的含义都是不正确的.
> 不过既然如此, 此时电路的设计者就可以为这些未定义情况下的输出信号取任意值.
> 这种设计方式的背后其实隐含着一种约定:
> 如果编码器的使用者希望编码器能输出正确的结果, 就需要保证"输入为独热码"的前提条件得到满足;
> 反之, 如果不满足这个前提条件, 那就算是编码器的使用者违反约定, 此时编码器的输出是无意义的,
> 如果后续电路对这些无意义的输出进行处理, 引发的结果由编码器的使用者承担.
因此, 设计编码器时, 我们可以不关心其他情况的输出,
只需要保证在输入为独热码时能得到正确的输出即可:
-->
> #### comment::Understanding undefined output
> Some calculations or modules require certain precondition to be met in order to produce meaningful output.
> One example is the mathematical calculation of division.
> You may have heard something like this: "You can't divide by `0`."
> The phrase "can't divide" here is natural language, not the language of the mathematical system.
> If using mathematical language to descibe it, "the divisor is not `0`" is a precondition for performing division.
> When the divisor is `0`, this precondition no longer holds, and it is impossible to define a correct and meaningful calculation result.
> Therefore, the result is also referred to as undefined.
>
> The example of the encoder is similar. "The input is a One-hot code" is a precondition for the encoder to operate correctly.
> When the input is not a One-hot code, this precondition no longer holds, and it is impossible to define a correct and meaningful output.
>
> However, at the digital circuit level, the output signal is either `0` or `1`,but regardless of the value taken, the meaning of the output signal is incorrect.
> But since that's the case, the circuit designer can assign any value to the output signal under these undefined conditions.
>
> There is actually an agreement behind this design method:
> If the encoder user wants the encoder to output correct results, they must ensure that the precondition of "input being One-hot code" is met;
> Conversely, if this precondition is not met, then the encoder user is violating the convention, and the encoder's output is meaningless.
> If subsequent circuits process these meaningless outputs, the resulting consequences are the responsibility of the encoder user.


Therefore, when designing an encoder, we can ignore the outputs in other cases,
and only need to ensure that the correct output is obtained when the input is One-hot code:
$Y_0 = A_1 | A_3$, $Y_1 = A_2 | A_3$.

<!--
> #### todo::搭建编码器
> 尝试在Logisim中通过门电路搭建一个16-4编码器, 它有16位输入和4位输出,
> 分别与拨码开关和七段数码管译码器相连,
> 使得编码器的输出结果通过十六进制数字显示在七段数码管中.
> 搭建后, 通过仿真检查你的实现是否正确.
在计算机中, 编码器常用于根据用独热码表示的选择信号生成相应地址.
另一种理解是用于找出独热码中`1`的位置.
上述编码器要求使用者保证输入是独热码, 如果希望在输入不为独热码的时候仍然输出有效的信息,
则需要使用另一种编码器——优先编码器(priority encoder).
优先编码器有$2^n$位输入, $n$位输出,
和上文介绍的编码器不同, 优先编码器允许输入信号中出现多个`1`,此时最高位的`1`将被优先编码.
因此, 如果输入不全为0, 则输出最高位的`1`的位置;如果输入全为0, 则输出是未定义的.例如, 一个4-2优先编码器有4位输入$A_3A_2A_1A_0$, 有2位输出$Y_1Y_0$, 其真值表如下.
-->
> #### todo::Build encoder
> Try to build a 16-4 encoder in Logisim using gate circuits. It has 16-bit input and 4-bit output,connected to a DIP switch and a seven-segment display decoder,so that the encoder's output results are displayed as hexadecimal numbers on the seven-segment display.
> After building it, using simulation to check if your implementation is correct.

In computers, encoders are commonly used to generate corresponding addresses based on selection signals represented by unique codes.
Another interpretation is that they are used to determine the position of `1` in One-hot code.

The above encoder requires the user to ensure that the input is One-hot code. If you wish to output valid information even when the input is not One-hot code,you need to use another type of encoder —— priority encoder.

A priority encoder has $2^n$ input bits and $n$ output bits.
Unlike the encoders described above, a priority encoder allows multiple `1`s in the input signal.

In this case, the highest-bit `1` is prioritized in the encoding.
Therefore, if the input is not all zeros, the output is the position of the highest-bit `1`;
if the input is all zeros, the output is undefined.


For example, a 4-2 priority encoder has 4-bit input $A_3A_2A_1A_0$ and 2-bit output $Y_1Y_0$, with the following truth table.

| $A_3$ | $A_2$ | $A_1$ | $A_0$ |   | $Y_1$ | $Y_0$ |
|:-----:|:-----:|:-----:|:-----:|:-:|:-----:|:-----:|
|   0   |   0   |   0   |   1   |   |   0   |   0   |
|   0   |   0   |   1   |   X   |   |   0   |   1   |
|   0   |   1   |   X   |   X   |   |   1   |   0   |
|   1   |   X   |   X   |   X   |   |   1   |   1   |
|   0   |   0   |   0   |   0   |   |   X   |   X   |

<!--
> #### todo::搭建4-2优先编码器
> 根据上述真值表, 尝试列出每一位输出的逻辑表达式.
> 然后尝试在Logisim中通过门电路搭建一个4-2优先编码器.
> 搭建后, 通过仿真检查你的方案是否正确.
> 实现后, 对比4-2编码器和4-2优先编码器所需的门电路数量.
-->
> #### todo::Build the 4-2 priority encoder
> Based on the truth table above, try to list the logical expressions for each output bit.
> Then try to build a 4-2 priority encoder in Logisim using gate circuits.
> After building it, simulate it to check if your solution is correct.
>
> After implementation, compare the number of gate circuits required for the 4-2 encoder and the 4-2 priority encoder.

<!--
> #### option::优先编码器的扩展
> 16-4优先编码器有16位输入, 4位输出.
> 尝试实例化若干个4-2优先编码器, 并添加少量门电路, 从而实现16-4优先编码器的功能.
> 然后将16-4优先编码器与拨码开关和七段数码管译码器相连,
> 使其输出结果通过十六进制数字显示在七段数码管中.
> 搭建后, 通过仿真检查你的实现是否正确.
-->
> #### option::Extension of the priority encoder
> The 16-4 priority encoder has 16-bit input and 4-bit output.
> Try to instantiate several 4-2 priority encoders and add a few logic gates to achieve the functionality of a 16-4 priority encoder.
> Then connect the 16-4 priority encoder to a DIP switch and a seven-segment display decoder, so that the output results are displayed as hexadecimal numbers on the seven-segment display.
> After building it, using simulation to check whether your implementation is correct.

<!--
> #### option::前导0和前导1的计数
> 计算机有时候需要计算一个数据的"前导0"的数量,
> 即需要计算该数据的二进制表示的高位有多少个连续的`0`.
> 假设数据的位宽是16位, 那么对于数据`16392`,
> 其二进制表示是`0b0100000000001000`, 因此前导0的数量为1.
> 类似可定义"尾随0", 即数据的二进制表示的低位有多少个连续的`0`.
> 同样以数据`16392`为例, 其尾随0的数量为3.
> 类似可定义"前导1"和"尾随1".
> 思考一下, 如何通过优先编码器快速计算它们?



-->
> #### option::Counting of leading 0 and leading 1
> Sometimes, a computer needs to calculate the number of "leading zeros" in a piece of data,
> that is, the number of consecutive `0` in the high-bit bits of the binary representation of the data.
> Assuming the data width is 16 bits, for the data `16392`,
> its binary representation is `0b0100000000001000`, so the number of leading zeros is 1.
>
> Similarly, we can define "trailing 0", which refers to the number of consecutive `0` in the lower bits of the binary representation of the data.
> Using the data `16392` as an example, the number of trailing 0 is 3.
> Similarly, we can define "leading 1" and "trailing 1."
>
> Think about how to quickly calculate these using a priority encoder?

<!--
### 多路选择器
多路选择器可以根据控制端的输入来从多个数据端中选择一路进行输出.
多路选择器也称"多路复用器", 或简称"选择器".
最简单的选择器是"1位2选1选择器", 它可以根据控制端的输入从两路1位的数据中选择一路进行输出.
1位2选1选择器的逻辑符号, 电路结构和真值表如下:

可以看到, 选择器中包含了一个n选1译码器,
如果把选择器的控制信号看作地址, 这个n选1译码器则生成了相应的选择信号,
这组选择信号让被选择的一路数据成功通过与门, 未被选择的数据通过与门后将会变成`0`,
最后通过一个或门将被选择的数据传递到输出端.
-->
### Multiplexer

The Multiplexer can select one of the multiple data terminals for output according to the input of the control terminal.
A multiplexer is also known as a "multiplexer" or simply a "selector."
The simplest selector is a "1-bit 2-to-1 selector," which can choose one of the two 1-bit data for output according to the input of the control terminal.
The logic symbol, circuit structure, and truth table for a 1-bit 2-to-1 selector are as follows:

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/0c0de1e3fe8583bfe6be723a69af85799e6aadf6.png) | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/257e79181d040da7483b0f1fd8ffd648085fa471.png) |
|:-:|:-:|

| $S$ |   |  $Y$  |
|:---:|:-:|:-----:|
|  0  |   | $D_0$ |
|  1  |   | $D_1$ |


As we can see, the selector contains an n-to-1 decoder.
If the control signal of the selector is regarded as an address, this n-to-1 decoder generates the corresponding selection signal.
This group of selection signals allows the selected data to successfully pass through the AND gate, while the unselected data will become `0` after passing through the AND gate.
Finally, the selected data is transmitted to the output end through an OR gate.

<!--
> #### todo::搭建1位2选1选择器
> 尝试在Logisim中通过门电路搭建一个1位2选1选择器.
> 搭建后, 通过仿真检查你的方案是否正确.
在计算机中, 选择器是使用频率很高的元件,
因为计算机的本质是用于处理数据, 而数据的来源和处理方式都很多,
因此需要大量的选择器来对数据来源和处理结果进行选择.
-->
> #### todo::Build a 1 bit 2-to-1 selector
> Try to build a 1-bit 2-to-1 selector in Logisim using gate circuits.
> After building it, using simulation to check if your design is correct.


In computers, selectors are frequently used components,because computers are essentially used to process data, and there are many sources and processing methods for data.
Therefore, a large number of selectors are needed to select data sources and processing results.

<!--
> #### todo::搭建3位4选1选择器
> 尝试画出3位4选1选择器的电路结构图,
> 然后在Logisim中通过门电路搭建一个3位4选1选择器.
> 搭建后, 通过仿真检查你的方案是否正确.
> Hint:
> * 如果你不理解"3位4选1选择器"的含义, 你需要先仔细阅读上文对"1位2选1选择器"的说明
> * 对于数据中的每一位, 都可以复用n选1译码器生成的选择信号进行选择
-->
> #### todo::Build a 3-bit 4-to-1 selector
> Then build a 3-bit 4-to-1 selector in Logisim using logic gates.
> After building it, use simulation to verify that your design is correct.
>
> * If you do not understand the meaning of a "3-bit 4-to-1 selector," you should first carefully read the explanation of the "1-bit 2-to-1 selector" in the preceding text.
> * For each bit in the data, you can reuse the selection signals generated by the n-to-1 decoder for selection.

<!--
> #### todo::搭建可切换进位计数制的七段数码管
> 通过5个拨码开关和1个七段数码管, 实现如下功能:
> 当选择信号为`0`时, 七段数码管以十进制方式显示数据;
> 当选择信号为`1`时, 七段数码管以十六进制方式显示数据.
> 在输入数据为10-15时, 两种显示方式有所不同.
-->
> #### todo::Build a seven-segment display with switchable carry counting system
> Using 5 DIP switches and 1 seven-segment display, the following functions are implemented:
> Among them, 4 DIP switches are used as data input, and the remaining 1 DIP switch is used as the choice of carry counting system.
> When the selection signal is `0`, the seven-segment display shows the data in decimal format;
> When the selection signal is `1`, the seven-segment display shows the data in hexadecimal format.
> When the input data is 10-15, the two display way differ.

<!--
### 比较器
比较器用于检查两个输入的每一位是否完全一致.
由于异或门(和同或门)已经具备比较1位数据的功能,
因此可通过异或门(和同或门)搭建多位数据的比较器.
下图是一个4位比较器的电路结构图:
-->
### Comparator

Comparators are used to check whether each bit of two inputs is completely consistent.
Since XOR gates (and XOR gates) already have the function of comparing 1-bit data,so multiple-bit data comparators can be built using XOR gates (and XOR gates).
The following picture shows the circuit structure of a 4-bit comparator:

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/4ed5c5580eee6c4962049d6ecbc6e06c18ee5e76.png) |
|:-:|

<!--
> #### todo::搭建比较器
> 尝试在Logisim中通过门电路搭建一个4位比较器, 然后通过两组拨码开关对比两组数据是否相等,
> 若相等, 则点亮一个LED灯.
> 搭建后, 通过仿真检查你的方案是否正确.
-->
> #### todo::Build comparator
> Try to build a 4-bit comparator in Logisim using gate circuits, then use two groups of DIP switches to compare whether the two groups of data are equal.
> Try to build a 4-bit comparator in Logisim using gate circuits, then use two groups of DIP switches to compare whether the two groups of data are equal.
> If they are equal, lighting up an LED.
> After building it, using simulation to check whether your solution is correct.

<!--
### 加法器
加法是算术运算的基础, 因此需要考虑如何通过门电路实现加法.
首先考虑1位加法器.加法的输入是两个加数, 输出和`S`(sum);加法的结果可能会产生进位, 为了不丢失这部分信息, 还需要输出进位C(carry). 根据加法运算的规则, 我们很容易列出1位加法器的真值表:
具体地, 当且仅当两个加数不同时, 和为`1`;
当且仅当两个加数都为`1`时, 进位为`1`.
根据真值表, 我们可以得到`S`和`C`的逻辑表达式:


考虑多位加法器, 由于低位产生的进位需要参与到高位的加法运算过程,
因此我们需要设计一种新的加法器, 让其能将从低位传播过来的进位作为输入:
具体地, 这种加法器有3个输入`A`, `B`, `Cin`, 其中`Cin`表示从低位传入的进位;
有2个输出`S`, `Cout`, 其中`Cout`表示加法运算产生的进位输出.
为了与上文的加法器区别开来, 这种输入有进位的加法器称为全加器(Full Adder, FA),
上文介绍的输入无进位的加法器称为半加器(Half Adder, HA).

-->
### Adder
Addition is the foundation of arithmetic calculations, so it is necessary to consider how to implement addition using logic gates.

First, We can consider a 1-bit adder.
The inputs to addition are two addends, and the outputs are the sum `S`;

The result of addition may generate a carry, so to avoid losing this information, the carry `C` must also be output.
Based on the rules of addition, we can easily list the truth table for a 1-bit adder:


| `A` | `B` |   | `S` | `C` |
|:---:|:---:|:-:|:---:|:---:|
|  0  |  0  |   |  0  |  0  |
|  0  |  1  |   |  1  |  0  |
|  1  |  0  |   |  1  |  0  |
|  1  |  1  |   |  0  |  1  |

`S = A ^ B`, `C = A & B`.
Specifically, the sum is `1` if and only if the two addends are different;
the carry is `1` if and only if both addends are `1`.
Based on the truth table, we can obtain the logical expressions for `S` and `C`:
`S = A ^ B`, `C = A & B`.


When considering a multi-digit adder, since the carry generated by the lower bit needs to be incorporated into the addition process of the higher bit,we need to design a new adder that can use the carry propagated from the lower bit as input:Specifically, this adder has three inputs `A`, `B`, and `Cin`, where `Cin` represents the carry propagated from the lower bit;
it has two outputs `S` and `Cout`, where `Cout` represents the carry output generated by the addition operation.
To distinguish it from the adder described above, this type of adder with carry input is called a full adder (FA),
while the adder without carry input described above is called a half adder (HA).

<!--
> #### todo::搭建1位全加器
> 尝试列出1位全加器的真值表, 并在Logisim中通过门电路搭建一个1位全加器.
> 搭建后, 通过仿真检查你的方案是否正确.
-->
> #### todo::Build a full adder
> Try to list the truth table for a 1-bit full adder and build a 1-bit full adder in Logisim using gate circuits.
> After building it, using simulation if your solution is correct through simulation.

<!--
> #### todo::搭建1位全加器(2)
> 尝试实例化若干个半加器, 并添加少量门电路, 从而实现一个1位全加器.
> 搭建后, 通过仿真检查你的方案是否正确.
有了全加器之后, 我们就可以用它来搭建多位加法器了.
例如, 下图展示了一个4位加法器的电路结构.
可以看到, 多位加法器的工作原理和小学学习的多位数加法的计算过程很类似,
都是从低位到高位逐位计算, 只不过小学学习的是十进制加法, 这里讨论的是二进制加法.
这种多位加法器称为"行波进位加法器"(Ripple-Carry Adder, RCA),
因为计算过程中产生的进位就像波浪一样从低位向高位传播.
-->
> #### todo::Build a full adder (2)
> Try to instantiate several half-adder circuits and adding a few logic gates to implement a 1-bit full adder.
> After building it, using simulation if your solution is correct through simulation.


With a full adder, we can use it to build a multi-bit adder.
For example, the picture below shows the circuit structure of a 4-digit adder.
As we can see, the working principle of a multi-bit adder is similar to the calculation process of multi-bit addition learned in elementary school,
They are both involving step-by-step calculation from the least significant bit to the most significant bit. However, while elementary school teaches decimal addition, here we are discussing binary addition.
This type of multi-bit adder is called a "Ripple-Carry Adder" (RCA),
because the carry generated during the calculation process propagates from the lower bit to the higher bit like a wave.
| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/245e89032204ce190201ccb95c41bbbfbfdddb8a.png) |
|:-:|

<!--
> #### todo::搭建4位加法器
> 尝试在Logisim中通过门电路搭建一个4位加法器,
> 用七段数码管按十六进制显示加法器的两个输入和结果,
> 并用一个LED灯指示加法结果是否产生进位.
> 搭建后, 通过仿真检查你的方案是否正确.
-->
> #### todo::Build a 4-bit adder
> Try to build a 4-bit adder in Logisim using gate circuits.
> Use a seven-segment display to show the two inputs and the result of the adder in hexadecimal.
> Use an LED to show if there's a carry in the addition result.
> After building it, using simulation if your solution is correct.

<!--
## 整数的编码
回顾上文介绍的二进制表示中提到的案例

在这种表示方式中, 每一个二进制位都代表真值的大小,
这种表示称为"无符号二进制整数"(unsigned binary integer), 简称"无符号数".
显然, 在一个$n$位的无符号数中, 最小数是$0$, 最大数是$2^n - 1$.
而刚才你实现的加法器, 其实也是一个无符号数的加法器.
那么, 计算机应该如何表示负数呢?
我们在数学上表示一个负数, 是在一个负号`-`后添加这个负数的绝对值, 例如`-5`.
既然计算机只能处理二进制, 那就需要考虑如何用二进制来对包括负数在内的整数进行编码.
一个直接的想法是通过一个二进制位来编码整数的符号位,
剩下的二进制位用于编码整数的绝对值.
这种表示称为"有符号二进制整数"(signed binary integer), 简称"有符号数".
-->
## Encoding of integers

Review the examples mentioned in the binary representation described above.
$$00101110_{B}=2^7\times0+2^6\times0+2^5\times1+2^4\times0+2^3\times1+2^2\times1+2^1\times1+2^0\times0=46$$

In this representation, each binary bit represents the magnitude of the true value.
This representation is called an "unsigned binary integer," simply called "unsigned number."
Obviously, in an $n$-bit unsigned number, the smallest number is $0$, and the largest number is $2^n - 1$.
The adder you just implemented is also actually an adder for unsigned numbers.

So, how should computers represent negative numbers?

In mathematics, we represent a negative number by adding a negative sign `-` followed by the absolute value of the negative number, such as `-5`.

Since computers can only process binary numbers, we need to consider how to encode integers, including negative numbers, using binary numbers.
One straightforward idea is to use a single binary bit to encode the sign bit of the integer, with the remaining binary bits used to encode the absolute value of the integer.

<!--
### 原码(sign-and-magnitude)
原码是一种直观的编码方式, 最高位表示符号位, `0`表示正数, `1`表示负数,
其余位表示对应真值的绝对值. 例如:


通过上述观察, 我们可以得出以下结论:
-->
### sign-and-magnitude
The sign-and-magnitude is an intuitive encoding method, where the hignest bit represents the sign bit, `0` represents a positive number, `1` represents a negative number,and the remaining bits represent the absolute value of the corresponding truth value. For example:
```
0b00000111 = 7
0b10000111 = -7
0b00100010 = 34
0b10100010 = -34
```
<!--
考虑采用8位的RCA进行原码加法:
* 当两数皆为正数时, 通过RCA进行加法所得的结果按原码解释,
  与将两数按原码解释后得到的结果在数学意义上相加, 两者一致.
  因此, 在这种情况下, 可以直接通过RCA进行原码加法.
* 当两数为负时, RCA所得结果与数学意义不符, 区别在于符号位.
  因此, 在这种情况下, 电路需要对符号位进行特殊处理.
* 当仅有一数为负时, RCA所得结果与数学意义不符,
  不仅符号位有可能错误, 绝对值也错误.
  因此, 在这种情况下, 不能使用RCA进行原码加法.
  事实上, 在数学意义上计算第三种情况时, 应该让绝对值较大的一方减去另一方,
符号取绝对值较大的一方.
这意味着, 为了计算原码加法, 电路上还需要设计一个减法器,
然后根据两数符号和绝对值的情况, 选择出正确的处理结果.
-->

Consider using 8-bit RCA for sign-and-magnitude addition:
```
 0b00000111 (7)     0b10000111 (-7)     0b10000111 (-7)    0b00000111 (7)
+0b00100010 (34)   +0b10100010 (-34)   +0b00100010 (34)   +0b10000111 (-7)
-----------        -----------         -----------        -----------
 0b00101001 (41)    0b00101001 (41)     0b10101001 (-41)   0b10001110 (-14)
```
Based on the above observations, we can draw the following conclusions:

* When both numbers are positive, the result obtained by performing addition using RCA is interpreted in its sign-and-magnitude,and is mathematically equivalent to the result obtained by adding the two numbers after interpreting them in their sign-and-magnitude.
  Therefore, in this case, sign-and-magnitude addition can be performed directly using RCA.

* When both numbers are negative, the result obtained by RCA does not align with mathematical meaning, with the difference lying in the sign bit.
  Therefore, in this case, the circuit must perform special handling on the sign bit.
* When only one number is negative, the result obtained by RCA doesn't align with mathematical meaning,not only may the sign bit be incorrect, but the absolute value is also incorrect.
  Therefore, in this case, RCA can't be used for sign-and-magnitude addition.

In fact, when calculating the third case in a mathematically meaningful way, the larger absolute value should subtract the other and the sign should be taken from the larger absolute value.
This means that, to perform sign-and-magnitude addition, the circuit also needs to design a subtractor and then select the correct result based on the signs and absolute values of the two numbers.

<!--
> #### todo::搭建4位减法器
> 根据4位加法器的设计思路, 尝试在Logisim中通过门电路搭建一个4位减法器,
> 用七段数码管按十六进制显示减法器的两个输入和结果,
> 并用一个LED灯指示减法结果是否产生借位.
> 并用一个LED灯指示减法结果是否产生借位.
> 搭建后, 通过仿真检查你的方案是否正确.
-->
> #### todo::Build a 4-bit subtractor
> Based on the design idea of a 4-bit adder, try to build a 4-bit subtractor in Logisim using gate circuits.
> Use a seven-segment display to show the two inputs and the result of the subtractor in hexadecimal.
> Use an LED to indicate whether the subtraction result produces a borrow.
> After building it, using simulation to check if your solution is correct.

<!--
> #### todo::搭建4位原码加法器
> 理解原码加法器的工作原理后, 尝试用加法器, 减法器和多路选择器等部件,
> 在Logisim中搭建一个4位原码加法器.
> 为了显示符号位, 你可以额外实例化一个七段数码管,
> 结果为负数时显示负号`-`, 否则不显示.
> 搭建后, 通过仿真检查你的方案是否正确.
-->
> #### todo::Build a 4-bit sign-magnitude adder
> After understanding how a sign-and-magnitude adder works, try to exploit adders, subtractors, and multiplexers to build a 4-bit sign-and-magnitude adder in Logisim.
> To display the sign bit, you can instantiate an additional seven-segment display.
> Display a minus sign `-` when the result is negative, otherwise don't display anything.
> After building it, using simulation to check if your solution is correct.

### one's complement
One's complement is another encoding method that attempts to solve the problem of negative numbers in the addition of sign-and-magnitude.
Specifically, for positive numbers and `0`, the representation is consistent with the sign-and-magnitude;for negative numbers, the representation is the bitwise complement of the sign-and-magnitude of the corresponding opposite number.
For example:
```
0b00000111 = 7
0b11111000 = -7
0b00100010 = 34
0b11011101 = -34
```
<!--
考虑采用8位的RCA进行反码加法:
-->
Consider using 8-bit RCA for one's complement addition:
```
 0b00000111 (7)     0b11111000 (-7)     0b11111000 (-7)    0b00000111 (7)
+0b00100010 (34)   +0b11011101 (-34)   +0b00100010 (34)   +0b11111000 (-7)
-----------        -----------         -----------        -----------
 0b00101001 (41)    0b11010101 (-42)    0b00011010 (26)    0b11111111 (-0)
```

Based on the above observations, we can draw the following conclusions:

* When both numbers are positive, the result obtained by addition using RCA is interpreted as a complement, and when the two numbers are interpreted as complements and added mathematically, the results are consistent.
Therefore, in this case, complement addition can be performed directly using RCA.

* When one of the numbers is negative, the result obtained via RCA doesn't align with mathematical meaning, although the sign bit is correct, the absolute value portion is incorrect.
* Specifically, when adding two numbers that are opposite in sign, according to the definition of two's complement, the result is always `0b11111111`.
  Interpreted as a two's complement, the true value of the result is `-0`. If it is treated as a mathematical `0`, then the RCA result is correct.

However, if `-0` is used as input for RCA calculations, an incorrect result is obtained:
```
 0b00000111 (7)     0b11111000 (-7)
+0b11111111 (-0)   +0b11111111 (-0)
-----------        -----------
 0b00000110 (6)     0b11110111 (-8)
```
<!--
上述例子说明, 不能直接使用RCA计算反码加法.
为了计算反码加法, 一种方式是先将反码转换为真值等价的原码,
然后使用原码加法器计算结果, 再将结果转换为真值等价的反码.
-->
The above example shows that RCA can't be used directly to calculate complement addition.
To calculate complement addition, one method is to first convert the complement to its true value equivalent sign-and-magnitude,then use the sign-and-magnitude adder to calculate the result, and finally convert the result back to its true value equivalent complement.
<!--
> #### todo::搭建4位反码加法器
> 尝试按照上述思路, 在Logisim中搭建一个4位反码加法器.
> 搭建后, 通过仿真检查你的方案是否正确.
-->
> #### todo::Build a 4-bit complement adder
> Try to build a 4-bit complement adder in Logisim according to the above approach.
> After building it, using simulation to check whether your solution is correct.

<!--
> #### option::搭建4位反码加法器(2)
> 事实上, 我们只需要在RCA所得结果的基础上做一些微小的调整, 就能得到正确的反码加法结果.
> 观察3位反码的计算, 尝试找出反码计算结果时结果出现偏差的规律,
> 然后根据这一规律, 在RCA的基础上添加相应电路,
> 从而用更简单的方法搭建出4位反码加法器.
> 搭建后, 通过仿真检查你的方案是否正确.
-->
> #### option::Build a 4-bit complement adder (2)
> In fact, we only need to make some minor adjustments to the results obtained from RCA to obtain the correct complement addition results.
> Observe the calculation of 3-bit complement codes and try to identify the patterns causing discrepancies in the complement calculation results.
> Then, based on this pattern, add the corresponding circuitry to the RCA,
> thereby constructing a 4-bit complement adder using a simpler method.
> After construction, verifying the correctness of your design through simulation.

<!--
### 补码(two's complement)
-->
### two's complement
<!--
补码是现代计算机中常用的整数编码方式, 它进一步修复了反码计算错误时结果的偏差.
具体地, 对于正数和`0`, 其表示与原码一致;
对于负数, 其表示为相应相反数的原码的按位取反后加`1`. 例如:
-->
Two's complement is a commonly used integer encoding method in modern computers. It further corrects the deviation in the results when calculating the complement code.
Specifically, for positive numbers and `0`, the representation is consistent with the sign-and-magnitude;for negative numbers, the representation is the bitwise complement of the sign-and-magnitude of the corresponding opposite number plus `1`. For example:
```
0b00000111 = 7
0b11111001 = -7
0b00100010 = 34
0b11011110 = -34
```

<!--
对于$n$位的补码, 最大数是`0b011...11`, 对应的真值是$2^{n-1}-1$,
最小数是`0b100...00`, 对应的真值是$-2^{n-1}$.
在补码中, 最小数是一个特殊的数, 它不能通过对某个正数进行"取反加1"来得到.
以8位补码为例, 最大数`0b01111111=127`, 对其进行"取反加1", 得到的是`0b10000001=-127`;
而最小数`0b10000000=-128`, 对其进行"取反加1",
得到的是`0b01111111+1=0b10000000=-128`, 与其自身相同.
这是因为`128`已经超过了8位补码所能表示的范围.
-->
For an $n$-bit two's complement, the largest number is `0b011...11`, corresponding to the true value $2^{n-1}-1$ and the smallest number is `0b100...00`, corresponding to the true value $-2^{n-1}$.
In two's complement, the smallest number is a special number that can't be obtained by "inverting and adding 1" to a positive number.
Taking an 8-bit two's complement as an example, the largest number `0b01111111=127`, when inverted and added by 1, results in `0b10000001=-127`;
while the smallest number `0b10000000=-128`, when inverted and incremented by 1,results in `0b01111111+1=0b10000000=-128`, which is the same as itself.
This is because `128` exceeds the range that 8-bit two's complement can represent.

<!--
设某正数$p$的补码表示为$\mathrm{0b}0p_{n-2}p_{n-3}\dots p_1p_0$,
并设其相反数$q$的补码表示为$\mathrm{0b}1q_{n-2}q_{n-3}\dots q_1q_0$.
根据补码的定义, 有$\mathrm{0b}q_{n-2}q_{n-3}\dots q_1q_0=\mathrm{0b}\bar{p_{n-2}}\bar{p_{n-3}}\dots\bar{p_1}\bar{p_0}+1$,
其中$\bar{p_i}$表示$p_i$的按位取反.
将两侧的二进制表示加权展开, 有
$$\sum_{i=0}^{n-2}2^iq_i=\sum_{i=0}^{n-2}2^i\bar{p_i}+1$$
此外, 由于$p_i$为`0`或`1`, 故$\bar{p_i}$为`1`或`0`, 因此有$p_i+\bar{p_i}=1$.
-->

Let's assume the two's complement representation of a positive number $p$ be $\mathrm{0b}0p_{n-2}p_{n-3}\dots p_1p_0$,
and let the two's complement representation of its opposite number $q$ be $\mathrm{0b}1q_{n-2}q_{n-3}\dots q_1q_0$.
According to the definition of two's complement, we have $\mathrm{0b}q_{n-2}q_{n-3}\dots q_1q_0=\mathrm{0b}\bar{p_{n-2}}\bar{p_{n-3}}\dots\bar{p_1}\bar{p_0}+1$,
where $\bar{p_i}$ denotes the bitwise complement of $p_i$.
Expanding the weighted binary representations on both sides, we have
$$\sum_{i=0}^{n-2}2^iq_i=\sum_{i=0}^{n-2}2^i\bar{p_i}+1$$
Furthermore, since $p_i$ is either `0` or `1`, $\bar{p_i}$ is either `1` or `0`, so $p_i+\bar{p_i}=1$.
<!--
考虑$q$的真值, 有
-->
Considering the truth value of $q$, there is $$\begin{array}{ll}
q&\displaystyle=-p=-(\mathrm{0b}0p_{n-2}p_{n-3}\dots p_1p_0)=-\sum_{i=0}^{n-2}2^ip_i=-\sum_{i=0}^{n-2}2^i(1-\bar{p_i})=-\sum_{i=0}^{n-2}2^i+\sum_{i=0}^{n-2}2^i\bar{p_i} \\
 &\displaystyle=-(2^{n-1}-1)+\sum_{i=0}^{n-2}2^i\bar{p_i}=-2^{n-1}+(\sum_{i=0}^{n-2}2^i\bar{p_i}+1)=-2^{n-1}+\sum_{i=0}^{n-2}2^iq_i \\
\end{array}$$

<!--
因此, 补码的符号位可以以$-2^{n-1}$为权来展开, 从而求得其真值.
例如, 用这种方式对`0b11111001`加权展开, 则有
-->
Therefore, the sign bit of the two's complement code can be expanded using $-2^{n-1}$ as the weight to obtain its true value.

For example, using this method to expand `0b11111001` with weights, we have
$$-2^7+2^6\times1+2^5\times1+2^4\times1+2^3\times1+2^2\times0+2^1\times0+2^0\times1=-7$$

<!--
与编码的真值一致.
-->
Consistent with the truth of the code.
<!--
考虑采用8位的RCA进行补码加法:
-->
Consider using 8-bit RCA for two's complement addition:

```
 0b00000111 (7)     0b11111001 (-7)     0b11111001 (-7)    0b00000111 (7)
+0b00100010 (34)   +0b11011110 (-34)   +0b00100010 (34)   +0b11111001 (-7)
-----------        -----------         -----------        -----------
 0b00101001 (41)    0b11010111 (-41)    0b00011011 (27)    0b00000000 (0)
```
<!--
通过上述观察, 我们可以看到, 用RCA计算补码加法时,
即使输入包含负数, RCA所得结果仍然符合数学意义.
这意味着, 我们也可以用RCA来计算补码的减法.
这是因为在数学意义上, `A-B=A+(-B)`, 但我们已经说明了,
无论`A`和`B`为何值, RCA所得结果都符合数学意义,
因此有
-->
Through the above observations, we can see that when calculating two's complement addition using RCA,even if the input contains negative numbers, the result obtained by RCA still makes sense mathematically.
This means that we can also use RCA to calculate two's complement subtraction.
This is because, in mathematical terms, `A-B=A+(-B)`, but we have already explained that
regardless of the values of `A` and `B`, the result obtained by RCA is mathematically valid,
therefore
<!--
```
用RCA计算A+(-B) = 数学意义上的A+(-B) = 数学意义上的A-B
```
-->
```
Using RCA to calculate A+(-B) = A+(-B) in mathematical terms = A-B in mathematical terms
```
<!--
正是由于可以用加法器计算补码的加法和减法, 现代计算机中普遍用补码来表示整数.

为什么通过RCA计算补码加法可以得出正确的结果呢?
以4位二进制数为例, 我们将二进制数按顺时针顺序排列:
-->
It is because addition and subtraction of two's complement can be calculated using an adder that two's complement is commonly used to represent integers in modern computers.

Why does calculating two's complement addition using RCA yield the correct result?
Take a 4-bit binary number as an example. We arrange the binary numbers in a clockwise order:
```
              0000 (0)
      (-1) 1111  0001 (1)
   (-2) 1110   ^    0010 (2)
 (-3) 1101     |      0011 (3)
(-4) 1100      +       0100 (4)
 (-5) 1011            0101 (5)
   (-6) 1010        0110 (6)
      (-7) 1001  0111 (7)
              1000 (-8)
```
<!--
RCA是在二进制层次上进行加法, 加一个正数, 相当于把指针按顺时针方向拨动;
加一个负数, 相当于把指针按逆时针方向拨动.
而要让某种编码的加法结果符合数学意义,
就要使得该编码对应的真值也按顺时针递增.
上图的括号`()`展示了补码的例子, 可以看到,
只要不跨越`7`和`-8`之间的边界, 用RCA计算补码加法的结果总是符合数学意义.
我们会在下文进一步讨论跨越边界的情况.
-->
RCA performs addition at the binary layer. Adding a positive number is equivalent to moving the pointer clockwise;adding a negative number is equivalent to moving the pointer counterclockwise.
To ensure that the result of addition in a particular encoding aligns with mathematical meaning,the corresponding truth values must also increase in a clockwise direction.
The parentheses `()` in the figure above illustrate an example of two's complement. As shown,as long as the boundary between `7` and `-8` is not crossed, the result of two's complement addition calculated using RCA always aligns with mathematical meaning.
We will discuss cases where the boundary is crossed in the following sections.
<!--
```
              原码                                  反码
              0000 (0)                             0000 (0)
      (-7) 1111  0001 (1)                  (-0) 1111  0001 (1)
   (-6) 1110   ^    0010 (2)            (-1) 1110   ^    0010 (2)
 (-5) 1101     |      0011 (3)        (-2) 1101     |      0011 (3)
(-4) 1100      +       0100 (4)      (-3) 1100      +       0100 (4)
 (-3) 1011            0101 (5)        (-4) 1011            0101 (5)
   (-2) 1010        0110 (6)            (-5) 1010        0110 (6)
      (-1) 1001  0111 (7)                  (-6) 1001  0111 (7)
              1000 (-0)                            1000 (-7)
```
-->

```
        sign-and-magnitude                                  One's complement
              0000 (0)                             0000 (0)
      (-7) 1111  0001 (1)                  (-0) 1111  0001 (1)
   (-6) 1110   ^    0010 (2)            (-1) 1110   ^    0010 (2)
 (-5) 1101     |      0011 (3)        (-2) 1101     |      0011 (3)
(-4) 1100      +       0100 (4)      (-3) 1100      +       0100 (4)
 (-3) 1011            0101 (5)        (-4) 1011            0101 (5)
   (-2) 1010        0110 (6)            (-5) 1010        0110 (6)
      (-1) 1001  0111 (7)                  (-6) 1001  0111 (7)
              1000 (-0)                            1000 (-7)
```
<!--
而对于原码和反码, 就不满足上述性质.
可以看到, 原码在`0b0000`和`0b1111`之间也存在一个不连续的边界,
在这个边界的两侧, 虽然二进制编码是连续的, 但编码对应的真值并不连续,
从而使得计算结果与数学意义不符.
例如, 用原码计算`0-1`时, 相当于是让指针指向`0`后,
往逆时针拨动一格, 结果是`-7`, 与数学意义不符.
反码也是类似的, 用反码计算`0-1`, 将会得到`-0`.
However, the sign-and-magnitude and the complement code don't satisfy the above properties.
As we can see, there is also a discontinuous boundary between `0b0000` and `0b1111` in the sign-and-magnitude.
On both sides of this boundary, although the binary encoding is continuous, the truth values corresponding to the encoding aren't continuous,resulting in calculation results that don't align with mathematical meaning.
For example, when calculating `0-1` using the sign-and-magnitude, it is equivalent to moving the pointer one step counterclockwise after pointing to `0`, resulting in `-7`, which doesn't align with mathematical meaning.
The one's complement behaves similarly; calculating `0-1` using the one's complement yields `-0`.
-->

<!--
> #### comment::为什么反码和补码的英文分别是one's complement和two's complement?
> 事实上, complement是计数系统中的一个概念, 中文是"补数".
> 在这个计数系统中, 要减去一个数, 可以通过加上该数的补数来计算得到.
>
> 在一个`n`位的`b`进制的计数系统中, 对于某数$a$, 有两种补数:
> 一种是基数的补数(radix complement), 在这个例子中是`b`'s complement, 定义为$b^n-a$;
> 另一种是减基数的补数(diminished radix complement),
> 在这个例子中是`b-1`'s complement, 定义为$b^n-1-a$.
> 这两种补数都可以通过相应的计算方法得出减法的结果.
> 特别地, 当`b=2`时, 这两种补数分别是two's complement和one's complement.
-->
> #### comment::Why are the English terms for one's complement and two's complement?
>
> In fact, complement is a concept in counting systems, and the Chinese term for it is "complement".
> In this counting system, to subtract a number, you can calculate it by adding the complement of that number.
>
> In an `n`-bit `b`-based counting system, for a given number $a$, there are two types of complements:
> One is the radix complement, which in this example is `b`'s complement, defined as $b^n-a$;
> The other is the diminished radix complement,
> which in this example is the `b-1`'s complement, defined as $b^n-1-a$.
> Both of these complements can be used to calculate the result of subtraction.
> Specifically, when `b=2`, these two complements are the two's complement and the one's complement, respectively.
>
> If you are interested in related content, please refer to [Related Wikipedia page][wikipedia complement].

[wikipedia complement]: https://en.wikipedia.org/wiki/Method_of_complements

<!--
### 溢出检测
-->
### overflow detection
<!--
回顾上文的分析, 即使是补码, 也存在编码连续但真值不连续的边界,
即`0b0111...111`和`0b1000...000`之间的边界, 它们分别表示最大数和最小数.
如果加法的计算跨越了这个边界, 计算所得结果将与数学意义不符.
特别地, 这个边界之所以存在, 是因为对于给定的二进制位数,
其表示范围总是有限的, 因此必定存在超过表示范围的数值.
这种计算结果超过编码表示范围的情况, 称为"溢出"(overflow).
显然, 如果计算发生溢出, 则所得结果肯定与数学意义不符.
为此, 通常需要在计算加法的同时, 检测结果是否发生溢出.

从数学意义上来看, 加法结果发生溢出, 要么是两个正数相加, 结果为负数,
要么是两个负数相加, 结果为正数,
这两种情况分别对应了从两个不同的方向跨越上述的不连续边界.
从这个视角来看, 我们只需要考虑符号位的加法情况, 即可检查是否发生溢出.
让我们考虑一个$n$位加法器中符号位对应全加器的输入输出情况:
-->
Looking back at the previous analysis, even with two's complement, there is a boundary where the encoding is continuous but the true values are not continuous,namely the boundary between `0b0111...111` and `0b1000...000`, which represent the maximum and minimum numbers, respectively.
If the addition calculation crosses this boundary, the result won't correspond to the mathematical meaning.
Specifically, this boundary exists because, for a given number of binary bits,the range of values it can represent is always finite, so there must be values that exceed this range.
This situation where the calculation result exceeds the encoding range is called "overflow."
Clearly, if an overflow occurs during the calculation, the result will definitely not align with mathematical meaning.
Therefore, it is typically necessary to detect whether an overflow has occurred while performing the addition calculation.

From a mathematical perspective, an overflow in the addition result occurs either when two positive numbers are added, resulting in a negative number or when two negative numbers are added, resulting in a positive number.
These two cases correspond to crossing the aforementioned discontinuous boundary from two different directions.
From this perspective, we only need to consider the addition of the sign bits to check for overflow.
Let's consider the input and output of the sign bit corresponding to the full adder in an $n$-bit adder:
<!--
| $A_{n-1}$ | $B_{n-1}$ | $C_{n-1}$ |   | $C_n$ | $S_{n-1}$ | 溢出 |
|:---------:|:---------:|:---------:|:-:|:-----:|:---------:|:----:|
|     0     |     0     |     0     |   |   0   |     0     |  否  |
|     0     |     0     |     1     |   |   0   |     1     |  是  |
-->
| $A_{n-1}$ | $B_{n-1}$ | $C_{n-1}$ |   | $C_n$ | $S_{n-1}$ | overflow |
|:---------:|:---------:|:---------:|:-:|:-----:|:---------:|:----:|
|     0     |     0     |     0     |   |   0   |     0     |  NO  |
|     0     |     0     |     1     |   |   0   |     1     |  YES  |

<!--
此处只列出了真值表的前两项.
给出两个输入$A_{n-1}$, $B_{n-1}$和进位输入$C_{n-1}$,
根据全加器的逻辑, 可以得到进位输出$C_n$以及和$S_{n-1}$.
要根据两个加数以及和的符号位来判断是否溢出, 只需要看$A_{n-1}$, $B_{n-1}$和$S_{n-1}$即可.
例如, 第一种情况相当于是"两个正数相加, 结果为正数", 因此未发生溢出;
而第二种情况相当于是"两个正数相加, 结果为负数", 因此发生溢出.
-->
Only the first two items of the truth table are listed here.
Given two inputs $A_{n-1}$, $B_{n-1}$ and the carry input $C_{n-1}$,according to the logic of the full adder, we can obtain the carry output $C_n$ and the sum $S_{n-1}$.
To determine whether an overflow has occurred based on the signs of the two addends and the sum, we only need to examine $A_{n-1}$, $B_{n-1}$, and $S_{n-1}$.
For example, the first case is equivalent to "adding two positive numbers, resulting in a positive number," so no overflow occurs;
while the second case is equivalent to "adding two positive numbers, resulting in a negative number", so an overflow occurs.

<!--
> #### todo::检测补码加法是否发生溢出
> 然后在Logisim中在4位加法器的基础上添加溢出判断逻辑.
> 添加后, 通过仿真检查你的方案是否正确.
-->
> #### todo::Detect whether overflow occurs in two's complement addition
> Complete the truth table above and try to list the logical expressions for overflow conditions.
> Then, add overflow detection logic to the 4-bit adder in Logisim.
> After adding it, checking if your solution is correct through simulation.

## Sequential logic circuit

The modules introduced in the previous section share a common feature: their outputs are determined entirely by their current inputs.
However, the modules described above are not sufficient to implement all circuits.
For example, an electronic clock needs to implement the function "new seconds = old seconds + 1",where the current output also depends on its old value.

<!--
因此, 我们需要实现一种新的电路, 它具备以下两种特性:
-->
Therefore, we need to implement a new circuit with the following two characteristics:
<!--
(1) 可以读出电路的旧状态;
(2) 可以更新电路的状态.
具备上述特性的电路称为时序逻辑电路,
-->
(1) It can read the old state of the circuit;
(2) It can update the state of the circuit.
A circuit with the above characteristics is called a sequential logic circuit.
<!--
它可以存储状态, 其输出由当前输入和旧状态共同决定;
相对地, 上一小节介绍的电路称为组合逻辑电路, 它们没有新旧状态的概念.
-->
It can store states, and its output is determined by both the current input and the old state.
In contrast, the circuits introduced in the previous section are called combinational logic circuits, which don't have the concept of old and new states.
<!--
### 交叉配对反相器
为此, 我们先来考虑如何存储并读出电路的状态.
可以存储状态的最简单电路是交叉配对反相器
(Cross-Coupled Inverters), 其电路结构如下图所示:
-->
### Cross-pairing reverse phase

For this, let's first consider how to store and read out the state of the circuit.
The simplest circuit that can store states is a cross-coupled inverters,whose circuit structure is shown in the picture below:

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/8cd44ebb6a2ad1735c95940a8b47b48d870c8073.png) |
|:-:|
<!--
假设$A_{out}$通过网线传播到$B_{in}$, 以及经过反相器传播到$B_{out}$的总延迟为`T`,
则$B_{out}$通过网线传播到$A_{in}$, 以及经过反相器传播到$A_{out}$的总延迟也为`T`.
上述电路的行为分4种情况讨论:
-->
Assuming that $A_{out}$ is transmitted to $B_{in}$ via a network cable, and the total delay after passing through the inverter to $B_{out}$ is `T`,then the total delay after $B_{out}$ is transmitted to $A_{in}$ via a network cable and passes through the inverter to $A_{out}$ is also `T`.
The behavior of the above circuit can be discussed in four cases:
<!--
1. 假设一开始$A_{out}=0, B_{out}=1$, 也即$Q=0, \bar{Q}=1$.
   经过时间`T`后, $B_{out}$变为$A_{out}$的取反, 即`1`,
   而$A_{out}$变为$B_{out}$的取反, 即`0`.
   也即, 经过时间`T`后, 仍有$Q=0, \bar{Q}=1$,
   与时间`T`之前一致, 因此电路的状态保持不变.
1. 假设一开始$A_{out}=1, B_{out}=0$, 也即$Q=1, \bar{Q}=0$.
   同样分析可得, 经过时间`T`后, 仍有$Q=1, \bar{Q}=0$,
   与时间`T`之前一致, 因此电路的状态保持不变.
1. 假设一开始$A_{out}=0, B_{out}=0$, 也即$Q=0, \bar{Q}=0$.
   经过时间`T`后, $B_{out}$变为$A_{out}$的取反, 即`1`,
   而$A_{out}$变为$B_{out}$的取反, 即`1`.
   也即, 经过时间`T`后, 有$Q=1, \bar{Q}=1$, 因此电路的状态发生变化.
1. 假设一开始$A_{out}=1, B_{out}=1$, 也即$Q=1, \bar{Q}=1$.
   同样分析可得, 经过时间`T`后, 有$Q=0, \bar{Q}=0$, 因此电路的状态发生变化.
-->
   1. Assume that initially $A_{out}=0, B_{out}=1$, i.e., $Q=0, \bar{Q}=1$.
After time `T`, $B_{out}$ becomes the complement of $A_{out}$, i.e. `1`,
while $A_{out}$ becomes the complement of $B_{out}$, i.e. `0`.
   That is, after time `T`, $Q=0, \bar{Q}=1$ still holds,consistent with the state before time `T`, so the circuit's state remains unchanged.
1. Assume that initially $A_{out}=1, B_{out}=0$, i.e., $Q=1, \bar{Q}=0$.
   Similarly, after time `T`, we still have $Q=1, \bar{Q}=0$,
   which is consistent with the state before time `T`, so the circuit state remains unchanged.
1. Assume that initially $A_{out}=0, B_{out}=0$, i.e., $Q=0, \bar{Q}=0$.
   After time `T`, $B_{out}$ becomes the complement of $A_{out}$, i.e. `1`,
   while $A_{out}$ becomes the complement of $B_{out}$, i.e. `1`.
   That is, after time `T`, we have $Q=1, \bar{Q}=1$, so the state of the circuit changes.
1. Assume that initially $A_{out}=1, B_{out}=1$, i.e., $Q=1, \bar{Q}=1$.
  Similarly, after time `T`, we have $Q=0, \bar{Q}=0$, so the circuit state changes.

<!--
由上述分析可知, 当$Q=0, \bar{Q}=1$或$Q=1, \bar{Q}=0$时, 电路处于保持不变的稳定状态.
我们认为电路此时可以稳定地存储1 bit的信息:
当$Q=0, \bar{Q}=1$时, 认为电路存储`0`;
当$Q=1, \bar{Q}=0$时, 认为电路存储`1`.
此时可通过$Q$端读出电路存储的状态.
-->
From the above analysis, it can be seen that when $Q=0, \bar{Q}=1$ or $Q=1, \bar{Q}=0$, the circuit is in a stable state that remains unchanged.
We consider that the circuit can stably store 1 bit of information at this time:
When $Q=0, \bar{Q}=1$, the circuit is considered to store `0`;
When $Q=1, \bar{Q}=0$, the circuit is considered to store `1`.
At this time, the state stored by the circuit can be read out through the $Q$ terminal.

<!--
而当$Q=0, \bar{Q}=0$或$Q=1, \bar{Q}=1$时, 电路会在这两个状态之间反复震荡,
$Q$端一会为`0`, 一会为`1`, 无法表示稳定的信息.
这个状态称为亚稳态(metastable state), 它可能会破坏电路中的其他信息,
使得电路的输出不符合预期, 因此在电路设计的过程中需要避免,
-->
When $Q=0, \bar{Q}=0$ or $Q=1, \bar{Q}=1$, the circuit oscillates repeatedly between these two states,with the $Q$ terminal alternating between `0` and `1`, unable to represent stable information.
This state is called a metastable state, which may destroy other information in the circuit,
causing the circuit's output to deviate from expectations. Therefore, it must be avoided during circuit design.

<!--
下表总结了交叉配对反相器的行为:
-->
The following table summarizes the behavior of cross-coupled inverters:

<!--
| $Q$ | $\bar{Q}$ |   | 新$Q$ | 新$\bar{Q}$ |  说明  |
|:---:|:---------:|:-:|:-----:|:-----------:|:------:|
|  0  |  0        |   |  1    |  1          | 亚稳态 |
|  0  |  1        |   |  0    |  1          | 存储`0`|
|  1  |  0        |   |  1    |  0          | 存储`1`|
|  1  |  1        |   |  0    |  0          | 亚稳态 |
-->
| $Q$ | $\bar{Q}$ |   | newQ | $\bar{Q}$ |  instruction  |
|:---:|:---------:|:-:|:-----:|:-----------:|:------:|
|  0  |  0        |   |  1    |  1          | metastability |
|  0  |  1        |   |  0    |  1          | store `0`|
|  1  |  0        |   |  1    |  0          | store `1`|
|  1  |  1        |   |  0    |  0          | metastability |
<!--
不过, 即使上述交叉配对反相器处于稳定状态, 我们却无法更新其状态,
因为这个电路没有外部输入, 我们无法控制它, 难以在实际中应用.
为了解决这个问题, 我们需要一种更实用的存储元件.
-->
However, even if the above cross-coupled inverter is in a stable state, we can't update its state,because this circuit has no external input, so we can't control it, making it difficult to apply in practice.
To solve this problem, we need a more practical storage element.

<!--
> #### comment::Logisim无法搭建交叉配对反相器
> 由于交叉配对反相器没有输入, Logisim无法决定其初始状态,
> 因而无法搭建可仿真的交叉配对反相器.
> 你只需要了解交叉配对反相器的工作原理即可, 不必完成相关的实验内容.
-->
> #### comment::Logisim can't build cross-coupled inverter.
> Since the cross-coupled inverter has no input, Logisim can't determine its initial state.
> and therefore can't build a cross-coupled inverter that can be simulated.
> You only need to understand how a cross-coupled inverter works; you don't need to complete the related experiments.

### S-R latch
<!--
SR锁存器(S-R Latch)通过将交叉配对反相器中的反相器换成或非门, 来向外部提供控制功能.
其中, S表示Set, 相应控制端用于对锁存器置位(设置为`1`);
R表示Reset, 相应控制端用于对锁存器复位(设置为`0`).
SR锁存器的逻辑符号和电路结构如下:
-->
The SR latch provides control functions to the outside by replacing the inverters in the cross-coupled inverter with OR-NOT gates.
Among them, S stands for Set, and the corresponding control terminal is used to set the latch (set to `1`);
R stands for Reset, and the corresponding control terminal is used to reset the latch (set to `0`).
The logic symbol and circuit structure of the SR latch are as follows:
| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/b0d1fb74bdfab99e7f8fdd0232ba5effd0e300ec.png) | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/aa8cfb24fd05163cd8be1d352bf2f44b1acb6043.png) |
|:-:|:-:|

<!--
根据输入的不同, 我们可以分4种情况讨论SR锁存器的行为:
1. 当`S=1, R=0`时, 上方或非门的行为和反相器一致, 下方或非门的输出恒为`0`.
   此时`Q`为`1`, 故将SR锁存器存储的值更新为`1`.
1. 当`S=0, R=1`时, 上方或非门的输出恒为`0`, 下方或非门的行为和反相器一致.
   此时`Q`为`0`, 故将SR锁存器存储的值更新为`0`.
1. 当`S=0, R=0`时, 两个或非门的行为和反相器一致.
   此时SR锁存器的行为与交叉配对反相器一致, 故SR锁存器将保持之前存储的值.
1. 当`S=1, R=1`时, 两个或非门的输出恒为`0`, 此时无法表示有效的信息.
   同时, 输入从`S=1, R=1`变为`S=0, R=0`时,
   相当于让交叉配对反相器进入$Q=0, \bar{Q}=0$的状态.
   根据上文的分析, 这将导致SR锁存器进入亚稳态, 因此需要避免.
-->
Depending on the input, we can discuss the behavior of the SR latch in four different cases:
1. When `S=1, R=0`, the behavior of the upper OR-NOT(NOR) gate is consistent with that of the inverter, and the output of the lower OR-NOT gate is always `0`.
   At this time, `Q` is `1`, so the value stored in the SR latch is updated to `1`.

1. When `S=0, R=1`, the output of the upper OR-NOT(NOR) gate is always `0`, and the behavior of the lower OR-NOT gate is the same as that of an inverter.
   At this time, `Q` is `0`, so the value stored in the SR latch is updated to `0`.
1. When `S=0, R=0`, the behavior of the two OR-NOT(NOR) gates is consistent with that of the inverter.
   At this point, the behavior of the SR latch is consistent with that of the cross-paired inverter, so the SR latch will retain the previously stored value.
1. When `S=1, R=1`, the output of the two OR-NOT(NOR) gates is always `0`, so no valid information can be represented at this point.
   Additionally, when the input changes from `S=1, R=1` to `S=0, R=0`,
   it is equivalent to putting the cross-coupled inverter into the state $Q=0, \bar{Q}=0$.
   According to the analysis above, this will cause the SR latch to enter a metastable state, so it should be avoided.
<!--
下表总结了SR锁存器的行为:
-->
The following table summarizes the behavior of SR latches:
<!--
| `S` | `R` |   | `Q` |
|:---:|:---:|:-:|:---:|
|  0  |  0  |   | 保持|
|  0  |  1  |   |  0  |
|  1  |  0  |   |  1  |
|  1  |  1  |   | 禁止|
-->
| `S` | `R` |   | `Q` |
|:---:|:---:|:-:|:---:|
|  0  |  0  |   | Keep|
|  0  |  1  |   |  0  |
|  1  |  0  |   |  1  |
|  1  |  1  |   | Stop|

<!--
> #### todo::搭建SR锁存器
> 尝试在Logisim中通过门电路搭建一个SR锁存器.
> 搭建后, 通过仿真检查你的方案是否正确.
>
> 由于手工操作时, 无法通过一次点击直接将两个拨码开关从`11`变成`00`.
> 为了触发亚稳态, 你可以在SR锁存器前额外增加若干与门,
> 让另一个拨码开关同时控制这些与门的其中一个输入端,
> 这样就可以通过这一个拨码开关来让SR锁存器的两个输入端同时变成`0`了.
> 如果你成功触发了亚稳态, Logisim会在窗口底部显示`Oscillation apparent`的信息.
> 此时仿真将无法继续, 你需要通过Logisim的菜单重置仿真.
-->
> #### todo::Build SR latch
> Try to build an SR latch using gate circuits in Logisim.
> After building it, using simulation to check if your design is correct.
>
> When operating manually, it is not possible to change two DIP switches from `11` to `00` with a single click.
> To trigger a metastable state, you can add several additional AND gates before the SR latch,
> Let another DIP switch control one of the inputs of these AND gates at the same time.
> This way, you can use this DIP switch to set both inputs of the SR latch to `0` at the same time.
> enabling you to use this DIP switch to simultaneously set both input terminals of the SR latch to `0`.
> If you successfully trigger the metastable state, Logisim will display the message `Oscillation apparent` at the bottom of the window.
> At this point, the simulation cannot continue, and you need to reset the simulation via the Logisim menu.

<!--
> #### option::用与非门搭建的SR锁存器
> 上文介绍的SR锁存器是用或非门搭建的, 事实上也可以将或非门换成与非门,
> 这种结构的锁存器称为$\bar{S}\bar{R}$锁存器.
> 尝试列出$\bar{S}\bar{R}$锁存器的真值表, 并分析其行为.
-->
> #### option::SR latch constructed with NAND gates
> The SR latch described above is constructed using OR-NOT(NOR) gates. In fact, the OR-NOT gates can also be replaced with AND-NOT(NAND) gates.
> This type of latch is called a $\bar{S}\bar{R}$ latch.
> Try to list the truth table for the $\bar{S}\bar{R}$ latch and analyze its behavior.


<!--
### D锁存器
为了从源头避免亚稳态, 我们可以在SR锁存器前添加若干门电路,将SR锁存器的4种输入限制成3种合法输入, 这就是D锁存器的基本思想.
D锁存器的逻辑符号和电路结构如下, 其中`D`为输入数据, `WE`为写使能(Write Enable).
-->
### D latch
To avoid metastability at the source, we can add several gate circuits before the SR latch
to limit the four inputs of the SR latch to three valid inputs. This is the basic idea behind the D latch.
The logic symbol and circuit structure of the D latch are shown below, where `D` is the input data and `WE` is the write enable (Write Enable).

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/d85e61fe60de9f92c1dadb3f2aa842b0dcfa769c.png) | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/0005c05d8b79336f931ac02bb927b87c82833c26.png) |
|:-:|:-:|

<!--
> #### todo::分析D锁存器的行为
> 尝试根据电路结构图列出真值表, 分析D锁存器的行为.
-->
> #### todo::Analysis of D latch behavior
> Try to list the truth table based on the circuit structure diagram and analyze the behavior of the D latch.

<!--
> #### todo::搭建D锁存器
> 尝试在Logisim中通过门电路搭建一个D锁存器.
> 搭建后, 通过仿真检查你的方案是否正确.
-->
> #### todo::build D latch
> Try to build a D latch using gate circuits in Logisim.
> After building it, using simulation to check if your solution is correct.

<!--
> #### todo::搭建带复位功能的D锁存器
> 尝试为D锁存器添加一个用于复位的输入端和复位功能.
> 当复位信号有效时, D锁存器中存放的值将变为`0`.
-->
> #### todo::Build a D latch with reset function
> Try to add a reset input and reset function to the D latch.
> When the reset signal is active, the value stored in the D latch will become `0`.

<!--
> #### todo::用D锁存器实现位翻转功能
> 实例化一个带复位功能的D锁存器, 并将其输出取反后作为输入.
> 我们预期看到D锁存器的输出将在`0`和`1`之间反复变化,
> 但你应该在仿真过程中看到`Oscillation apparent`的信息, 请分析原因.
-->
> #### todo::Implementing bit flip functionality using D latches
> Instantiate a D latch with reset functionality, invert its output, and use it as input.
> We expect to see the output of the D latch oscillate between `0` and `1`.
> But you should see the message "Oscillation apparent" during simulation. Please analyze the cause.

<!--
### 同步电路
-->
### synchronous circuit

<!--
一个复杂的系统会包含多个模块, 如何控制多个模块协同工作是一个需要考虑的问题.
例如, 某系统包含3个模块, 分别是读数据模块, 加法模块和写结果模块.
我们期望按顺序发生以下事件:
1. 读数据模块先工作
2. 读出数据后, 加法模块才开始计算
3. 加法模块的结果计算好后, 再将结果写入目标存储元件

因此, 我们需要实现一种同步关系: 让事件A在事件B之后发生.
这需要额外的机制来支撑, 总体上有两种:
* 同步电路: 通过全局的周期性时钟信号来实现同步.
  时钟信号是如下图所示的脉冲信号, 它在高低电平之间来回翻转,
  一次高电平和一次低电平加起来称为一个周期.
  在同步电路中, 存储元件仅在时钟信号正边沿(positive edge, 从低电平翻转为高电平, 也称上升沿)
  或负边沿(negative edge, 从高电平翻转为低电平, 也称下降沿)达到时写入数据,
  且能在后续时钟周期稳定读出该数据.
  有了这一特性, 我们可以把需要同步的事件划分到不同的周期中,
  由时钟信号来控制这些事件的先后顺序.
-->
A complex system consists of multiple modules and how to control multiple modules to work together is an issue that needs to be considered.
For example, a system consists of three modules: a data reading module, an addition module, and a result writing module.
We expect the following events to occur in sequence:
1. The data reading module operates first
2. After the data reading, the addition module begins calculations
3. Once the addition module completes its calculations, the results are written to the target storage element

Therefore, we need to establish a   synchronization relationship: ensuring that event A occurs after event B.
This requires extra mechanisms to support it, which can be broadly categorized into two types:
* Synchronization circuits: Achieved through a global periodic clock signal.
  The clock signal is a pulse signal as shown in the picture below, which alternates between high and low levels.
One high level and one low level together form one cycle.
In synchronous circuits, storage elements only write data when the clock signal reaches the positive edge (positive edge, transitioning from low level to high level, also known as the rising edge)
  or the negative edge (from high level to low level, also known as the falling edge) of the clock signal.
  The data then can be stably read out in subsequent clock cycles.
  With this characteristic, we can divide events that require synchronization into different cycles,
  and use the clock signal to control the sequence of these events.

<!--
```txt
      时钟信号示例
            +--- positive edge          +--- negative edge
            V                           V
    +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+
    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
+---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +
```
-->
```txt
      Clock signal example
            +--- positive edge          +--- negative edge
            V                           V
    +---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+
    |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |
+---+   +---+   +---+   +---+   +---+   +---+   +---+   +---+   +
```
<!--
* 异步电路: 通过模块之间的局部通信信号来实现同步.
* Asynchronous circuits: Synchronization is achieved through part communication signals between modules.
相对于异步电路, 同步电路的设计较简单, 对同步电路的分析也比较容易,
尽管由于引入了周期性翻转的时钟信号, 其功耗要高于异步电路, 同步电路仍然被业界广泛采用.
我们后续的学习也会基于同步电路.
-->
Compared to asynchronous circuits, synchronous circuits are simpler to design and easier to analyze.
Although their power consumption is higher than that of asynchronous circuits due to the introduction of periodic clock signals, synchronous circuits are still widely used in the industry.
Our subsequent studies will also be based on synchronous circuits.

<!--
但是, D锁存器作为存储元件, 却无法满足同步电路的要求,
即使将时钟信号连接到D锁存器的写使能端, 也仍然不满足上述要求.
如下图所示, 我们期望数据在时钟上升沿到来时写入存储元件,且在后续时钟周期能从存储元件稳定读出该数据, 但图中红圈处违反了该特性.
-->
However, D latch, as storage elements, can't meet the requirements of synchronous circuits.
Even if the clock signal is connected to the write enable pin of the D latch, it still doesn't meet the aforementioned requirements.
As shown in the picture below, we expect data to be written into the storage element when the clock rising edge arrives and for the data to be stably read out from the storage element in subsequent clock cycles. However, the red circle in the picture violates this characteristic.

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/71fe8cc6f5f06ea92b1afad89968fcde7b022455.png) |
|:-:|

<!--
这是因为锁存器属于电平触发(level-triggered)的存储元件, 只要输入发生变化,锁存器就能立即感知, 并将该变化传播到输出端.
相比之下, 我们需要一种边沿触发(edge-triggered)的存储元件,
只有信号边沿到来时, 才将输入传播到输出端.
-->
This is because latches are level-triggered storage elements. As long as the input changes,
the latch can immediately feel it and spread the change to the output.
In contrast, we need an edge-triggered storage element,which only spread the input to the output when the signal edge arrives.
<!--
### D触发器
-->
### D Flip-Flop

<!--
D触发器(D Flip-Flop)是一种边沿触发的存储元件,
它基于锁存器搭建, 但可以在时钟信号维持电平的时刻巧妙地阻塞输入信号的传播.
D触发器的逻辑符号如下图所示, 其中左下方的`>`符号表示该端口需要连接时钟信号.
D触发器有多种实现方式, 这里先介绍主从式D触发器, 其结构如下图所示.
-->
A D flip-flop is a edge-triggered storage element.
It is based on latch, but can cleverly block the propagation of input signals when the clock signal is maintained at a certain level.
The logic symbol of a D flip-flop is shown in the picture below, where the `>` symbol in the lower left corner indicates that this port needs to be connected to the clock signal.
There are various implementations of the D flip-flop. Here, we first introduce the master-slave D flip-flop, whose structure is shown in the picture below.

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/6bcf7eb766ced95806c75490f70ba9dc060ac43e.png) | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/9ab76d4a01bbe8d6031ccd52a10667193d756e31.png) |
|:-:|:-:|
<!--
主从式D触发器由两个D锁存器构成, 左边的称为主锁存器, 右边的称为从锁存器.
两个D锁存器的写使能端分别与时钟信号及其取反结果相连.
主从式D触发器的工作过程分为如下阶段:
1. 数据准备阶段. 此时时钟信号`clk`处于低电平,
   故主锁存器的写使能端有效, 数据信号`D`可从外部进入主锁存器;
   但由于从锁存器的写使能端无效, 故数据信号无法传播到从锁存器,
   因而整个D触发器的输出端`Q`保持不变.
1. 采样阶段. 当时钟信号`clk`的上升沿到来时,
   主锁存器的写使能端无效, 数据信号`D`无法从外部进入主锁存器,
   `D`的后续变化将无法对主锁存器造成影响,
   从而将时钟信号上升沿到来前的外部数据`D`"锁"在主锁存器中.
   与此同时, 从锁存器的写使能端开始有效,
   主锁存器中"锁住"的数据将传播到从锁存器, 并作为整个D触发器的输出.
1. 维持阶段. 此时时钟信号`clk`处于高电平,
   故主锁存器的写使能端无效, 因此不受数据信号`D`变化的影响;
   从锁存器的写使能端虽然有效, 但由于主锁存器保持不变,
   故从锁存器也保持不变, 因而整个D触发器的输出端`Q`保持不变.
-->
A master-slave D flip-flop consists of two D latches, with the left one referred to as the master latch and the right one as the slave latch.
The write enable pins of the two D latches are connected to the clock signal and its inverted output, respectively.
The operation of the master-slave D flip-flop is divided into the following stages:
1. Data preparation stage. At this time, the clock signal `clk` is at a low level,
   so the write enable pin of the master latch is active, and the data signal `D` can enter the master latch from the outside;
   however, since the write enable pin of the slave latch is inactive, the data signal can't spread to the slave latch,
   so the output pin `Q` of the entire D flip-flop remains unchanged.
1. Sampling phase. When the rising edge of the clock signal `clk` arrives,the write enable pin of the master latch is inactive, so the data signal `D` can't enter the master latch from the external source and any subsequent changes to `D` will not affect the master latch,thereby "locking" the external data `D` from before the rising edge of the clock signal into the master latch.
At the same time, the write enable pin of the slave latch becomes active and the data "locked" in the main latch is spread to the slave latch, serving as the output of the entire D flip-flop.
1. Hold phase. At this time, the clock signal `clk` is at a high level, so the write enable pin of the master latch is inactive and isn't affected by changes in the data signal `D`;
although the write enable pin of the slave latch is active, since the master latch remains unchanged,the slave latch also remains unchanged, and thus the output pin `Q` of the entire D flip-flop remains unchanged.

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/c02632eb6d992361b7bab5f76e755167672a6f56.png) |
|:-:|

<!--
从整体上看, 当时钟上升沿到来时, 数据被写入D触发器,
并能在后续时钟周期稳定读出该数据, 符合同步电路对存储元件的要求.
因此, D触发器是同步电路设计中的基本存储元件.
-->
Overall, when the rising edge of the clock arrives, data is written into the D flip-flop and the data can be read out stably in subsequent clock cycles, meeting the requirements of synchronous circuits for storage elements.
Therefore, D flip-flop is basic storage elements in synchronous circuit design.
<!--
> #### todo::搭建D触发器
> 尝试在Logisim中通过门电路搭建一个D触发器.
> 搭建后, 将时钟端口与一个按钮相连, 按钮的按下和释放分别会产生高低电平, 因此点击一次按钮可产生一个脉冲, 以此来充当时钟信号.
> 尝试长按按钮, 来观察主从式D触发器的工作过程.
-->
> #### todo::Build a D flip-flop
> Try to build a D flip-flop in Logisim using gate circuits.
> After building it, connecting the clock port to a button. Pressing and releasing the button will generate high and low voltage levels, respectively.
> Therefore, clicking the button once generates a pulse, which serves as a clock signal.
> Try pressing down the button to observe the operation of the master-slave D flip-flop.

<!--
> #### todo::搭建带复位功能的D触发器
> 尝试为D触发器添加一个用于复位的输入端和复位功能.
> 当复位信号有效时, D触发器中存放的值将变为`0`.
-->
> #### todo::Build a D flip-flop with reset function
> Try to add a reset input and reset function to the D flip-flop.
> When the reset signal is active, the value stored in the D flip-flop will become `0`.

<!--
> #### todo::用D触发器实现位翻转功能
> 实例化一个带复位功能的D触发器, 并将其输出取反后作为输入.
> 我们预期看到D触发器的输出将在`0`和`1`之间反复变化.
> 尝试和上文D锁存器的结果进行对比
-->
> #### todo::Implementing bit flip functionality using D flip-flops
> Instantiate a D flip-flop with reset functionality, and invert its output before using it as input.
> We expect to see the output of the D flip-flop oscillate between `0` and `1`.
> Try to compare the results with those of the D latch described above.

> #### option::Build a D flip-flop triggered by a falling edge
> The master-slave D flip-flop described above is triggered by a rising edge. Try to build a D flip-flop that is triggered by a falling edge.
> After building it, using simulation to check whether your design is correct.

<!--
> #### comment::D触发器的另一种实现
> 下图是D触发器的另一种实现方式, 称为维持-阻塞式D触发器.
> 和主从式D触发器相比, 它对输入的限制更宽松.
> 感兴趣的同学可以查阅相关资料了解并分析维持-阻塞式D触发器的行为.

有时候我们并不希望无条件更新D触发器, 因此需要为D触发器添加一个使能端,形成带使能端的D触发器, 其逻辑符号如下图所示.
-->
> #### comment::Another implementation of the D flip-flop
> The picture below shows another implementation of a D flip-flop, known as a hold-block D flip-flop.
> Compared to a master-slave D flip-flop, it has more relaxed restrictions on the input.
> Interested students can refer to relevant materials to understand and analyze the behavior of a hold-block D flip-flop.
>
> | ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/54396eb9ec12b15a7dcb3a965d4b881e34476682.png) |
> |:-:|


Sometimes we don't want to unconditionally update the D flip-flop, so we need to add an enable pin to the D flip-flop to form a D flip-flop with an enable pin. Its logic symbol is shown in the picture below.

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/bbe2ddba030a3351a55f56eab35b81425e3a2db0.png) |
|:-:|

<!--
> #### todo::搭建带使能端的D触发器
> 尝试在Logisim中通过D触发器和若干电路, 搭建一个带使能端的D触发器.
> 搭建后, 通过仿真检查你的方案是否正确.
-->
> #### todo::Build a D flip-flop with an enabling pin
> Try to build a D flip-flop with an enable pin in Logisim using D flip-flops and several circuits.
> After building it, checking if your solution is correct through simulation.

<!--
### 寄存器
上述的D触发器只能存储1位数据, 但有时候需要将多位数据作为一个整体来存储和处理.
寄存器(register)是由多个D触发器组成的存储元件, 其电路结构如下图所示.
这些D触发器之间共享相同的时钟信号和使能信号, 从而实现整体存储的效果.
-->
### Register

The above D flip-flop can only store 1 bit of data, but sometimes it is necessary to store and process multiple bits of data as a whole.
Register is a storage element composed of multiple D flip-flops, and its circuit structure is shown in the picture below.
These D flip-flops share the same clock signal and enable signal, thereby achieving the effect of overall storage.

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/7566ecb3027dd1b0df21e614f6bd3e2bf21e8198.png) |
|:-:|

<!--
> #### todo::搭建4位寄存器
> 尝试在Logisim中通过D触发器搭建一个4位的寄存器, 具备复位功能.
> 搭建后, 尝试从拨码开关向寄存器写入4位数据, 并将寄存器的输出接到七段数码管进行显示.
-->
> #### todo::Build a 4-bit register
> Try to build a 4-bit register with reset function in Logisim using D flip-flops.
> After building it, try to write 4-bit data to the register from the DIP switch and connect the register output to a seven-segment display for display.

<!--
> #### todo::搭建4位计数器
> 通过上述4位寄存器和之前搭建的加法器, 实现一个4位计数器,
> 每次时钟到来时, 寄存器中的值加1, 加到最大值时重新从`0`开始.
> 在Logisim中, 你可以通过元件库中的`Wiring(线路)`类别下的`Constant(常数)`元件实例化一个常数,
> 具体使用方式请RTFM.
-->
> #### todo::Build a 4-bit counter
> Using the above four registers and the previously constructed adder, implement a four-bit counter.
> Each time a clock signal arrives, the value in the register is incremented by one. When the maximum value is reached, the counter resets to `0`.
> In Logisim, you can instantiate a constant using the `Constant` component under the `Wiring` category in the component library.
> For specific usage instructions,please RTFM.

<!--
> #### todo::设计数列求和电路
> 尝试通过寄存器和加法器, 计算出`1+2+...+10`的结果.
> 为了容纳计算结果, 你可以考虑实现8位的寄存器和加法器.
-->
> #### todo::Design a circuit for summing sequences
> Try to calculate the result of `1+2+...+10` using registers and adders.
> To accommodate the calculation results, you may consider implementing 8-bit registers and adders.

> #### todo::Implement an electronic clock
> Using registers and seven-segment display, implementing an electronic clock with "minutes" and "seconds" functions.
>
> Hint: The `Clock` component can automatically generate clock signals without the need for manual clicks like buttons.
> You can find it in the `Wiring` category of the Logisim component library. For specific usage instructions, please RTFM.
