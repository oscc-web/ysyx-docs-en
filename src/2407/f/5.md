<!-- # F5 支持数列求和的简单处理器 -->
# F5 Simple Processor Supporting Sequence Summation

<!-- 通过ISA和状态机模型, 我们已经了解程序如何执行.
此外, 我们也已经学习了数字逻辑电路的基础知识.
现在是时候用数字电路实现一个CPU了! -->
Through ISA and state machine models, we have learned how programs are executed. In addition, we have also learned the basics of digital logic circuits.
Now it's time to implement a CPU using digital circuits!


<!-- 在此之前, 我们需要再次明确需要实现的指令集sISA的细节.
和上一小节相比, 此处还约定了一些寄存器的位宽: -->
Before that, we need to clarify the details of the instruction set sISA that we need to implement. Compared with the previous subsection, some register bit widths are also specified here:
<!-- * PC位宽为4位, 初值为`0`
* GPR有4个, 位宽均为8位
* 支持如下3条指令 -->
* PC bit width is 4 bits, initial value is `0`
* There are 4 GPRs, each with a bit width of 8 bits
* Supports the following 3 instructions
  ```
   7  6 5  4 3   2 1   0
  +----+----+-----+-----+
  | 00 | rd | rs1 | rs2 | R[rd]=R[rs1]+R[rs2]      ADD instruction for register addition
  +----+----+-----+-----+
  | 10 | rd |    imm    | R[rd]=imm               LI instruction (Load Immediate with zero-extension)
  +----+----+-----+-----+
  | 11 |   addr   | rs2 | if (R[0]!=R[rs2]) PC=addr BNER0 instruction (Branch if Not Equal to Register 0)
  +----+----------+-----+
  ```

<!-- 我们将这个用数字电路实现的sISA指令集的CPU称为sCPU.
要实现sCPU, 我们需要用数字电路实现sISA中的每一个概念.
为了简单起见, 我们先从最简单的`li`指令开始考虑,
也即, 先实现一个只支持`li`指令的sCPU. -->
We refer to this CPU, which implements the sISA instruction set using digital circuits, as sCPU.
To implement sCPU, we need to implement every concept in sISA using digital circuits. For simplicity, let's start with the simplest `li` instruction,that is, let's first implement an sCPU that only supports the `li` instruction.

<!-- ## 只有一条指令的sCPU -->
## sCPU with only one instruction

<!-- 我们先从ISA的状态机模型回顾执行一条`li`指令的具体过程.
事实上, 无论是执行什么指令, 其步骤都是类似的,
有一个叫"指令周期"(instruction cycle)的概念专门描述这些步骤:
1. 取指(fetch): 根据当前PC, 在存储器中找到一条指令
1. 译码(decode): 看这条指令具体是什么指令, 操作数是哪些
   * 以`li`指令为例, 操作数需要看立即数是多少, 需要写入哪个目的寄存器
1. 执行(execute): 对操作数进行处理, 必要时更新指定的目的寄存器
1. 更新PC: 让PC指向下一条指令 

因此, 我们的目标就是用数字电路实现上述过程的每一个步骤.  -->
Let's first review the specific process of executing a `li` instruction using the ISA state machine model.  
In fact, regardless of the instruction being executed, the steps are similar.  
There is a concept called the ‘instruction cycle’ that specifically describes these steps:  
1. Fetch: Based on the current PC, locate an instruction in memory.
1. Decode: Determine the specific type of instruction and its operands  
   * For example, with the `li` instruction, the operand requires checking the immediate value and determining which destination register to write to
1. Execute: Process the operands and update the specified destination register if necessary
1. Update PC: Set the PC to point to the next instruction

Therefore, our goal is to implement each of these steps using digital circuits.

### Fetch

<!-- 首先需要一个PC寄存器, 你之前已经用数字电路实现过寄存器了, 因此PC寄存器并不难实现.
然后需要根据PC在存储器中找到一条指令, 因此我们还需要实现存储器. -->
First, you need a PC register. You have already implemented registers using digital circuits, so the PC register is not difficult to implement.
Then, you need to find an instruction in the memory based on the PC, so you also need to implement the memory.

<!-- 存储器和寄存器都可以存储信息, 但存储器还支持寻址(addressing),
也即, 存储器中的内容按顺序进行排布的, 给出一个地址, 存储器可以读出该地址对应的内容.
我们可以将存储器看成一个由比特构成的矩阵, 矩阵的每一行称为一个存储字(word),
地址就是行的编号, 行的数量也称为存储器的深度(depth).
通常一个存储字包含多位数据, 其位宽称为存储器的宽度(width).
通常用`深度x宽度`表示一个存储器的规格.
例如, 一个`2x3`的存储器排布如下,
其中$b_{(x, y)}$表示第$x$行第$y$列所存储的比特: -->

 Both memory and registers can store information, but memory also supports addressing. That is, the contents of memory are arranged in order; given an address, memory can read out the content corresponding to that address. We can regard memory as a matrix composed of bits, where each row of the matrix is called a memory word, the address is the row number, and the number of rows is called the memory depth. Typically, a memory word contains multiple bits of data, and its bit-width is called the memory width. Memory specifications are usually expressed as `depth x width`. For example, a `2x3` memory is arranged as follows, where $b_{(x, y)}$represents the bit stored in the $x$ row and $y$ column

| ​Address | ​Memory Word |
|:----:|:------:|
|  0   | $b_{(0, 2)}b_{(0, 1)}b_{(0, 0)}$ |
|  1   | $b_{(1, 2)}b_{(1, 1)}b_{(1, 0)}$ |

<!-- 从功能上划分, 存储器可以分别只读存储器(Read-Only Memory, ROM)
和随机访问存储器(Random Access Memory, RAM), 前者不支持写入, 而后者支持.
对于sISA来说, 因为3条指令都不会访问存储器,
只有取指操作需要从存储器中读出指令, 因此这里可以采用ROM. -->

Functionally, memory can be categorized into Read-Only Memory (ROM) and Random Access Memory (RAM). The former does not support write operations, while the latter does. For sISA, since none of its three instructions access memory (only instruction fetch requires reading instructions from memory), ROM can be implemented here.

<!-- 一个`2x3`的ROM的结构如下图所示.
左上方的译码器又称"地址译码器", 和地址译码器输出相连的导线称为"字线"(word line);
字线会与相应存储字中的存储单元进行与操作, 再对同一列与门的结果进行或操作,
和或门输出相连的导线称为"位线"(bit line). -->

The structure of a `2x3` ROM is shown in the figure below. The decoder at the upper left is called the 'address decoder', and the wires connected to the address decoder outputs are called 'word lines'. Each word line performs an AND operation with the memory cells in the corresponding memory word, then the results of the AND gates in the same column undergo an OR operation. The wires connected to the OR gate outputs are called 'bit lines'.



| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/3e4761728feb60e13a5683df85b3960461e008fb.png) |
|:-:|

<!-- 给定地址`addr`, 可以读出ROM中的相应存储字, 其工作过程如下.
地址译码器将输入的地址转换成一组独热码, 由于独热码中只有一位有效,
故所有字线中, 只有地址`addr`对应的字线有效, 使得该行中存放的信息可以通过与门.
其余行因字线无效, 存放的信息均被与门过滤为`0`.
被选中的存储字的每一位经过或门传输到位线, 向存储器外部输出. -->

Given an address `addr`, the corresponding memory word can be read from the ROM through the following process: The address decoder converts the input address into a one-hot code. Since only one bit is active in the one-hot encoding, among all word lines, only the word line corresponding to `addr` becomes active. This enables the stored information in that row to pass through the AND gates. Information in other rows is filtered to `0` by the AND gates due to their inactive word lines. Each bit of the selected memory word is then transmitted through the OR gates to the bit lines, outputting the data externally from the memory.


<!-- 实际上, 图中的地址译码器, 与门和或门, 在功能上共同构成了一个3位的2选1多路选择器.
因此ROM的读操作也可以看作是从多个存储字中选择一个,
地址`addr`就是多路选择器的选择端, 所有存储字分别作为多路选择器的数据端.
特别地, ROM中存储的信息是直接通过高低电平编码的,
因此ROM从功能上也可以看作是数据端为常数的多路选择器. -->

Functionally, the address decoder, AND gates, and OR gates in the diagram collectively form a 3-bit 2-to-1 multiplexer. Consequently, reading from ROM can be viewed as selecting one memory word from multiple stored words, where the address `addr` acts as the multiplexer's selection input, and all memory words serve as its data inputs. Notably, information stored in ROM is directly encoded using voltage levels (high/low), making the ROM functionally equivalent to a multiplexer with constant data inputs.


<!-- > #### todo::实现取指功能
> 通过多路选择器实现一个ROM, 并在其中存放数列求和的指令序列, 然后通过PC寄存器取出指令.
> 你需要根据你的理解来确定ROM的规格. -->
> #### todo::Implement Instruction Fetch Function  
> Implement a ROM using multiplexers to store the summation sequence instructions, then retrieve instructions via the PC Register.
> You need to determine the ROM specifications  based on your understanding.

### Decode

<!-- 我们在ISA的状态机上执行指令时,
是通过指令的汇编表示直接识别其功能(如`li r0, 10`),
或者给出指令的二进制表示(如`10001010`), 然后查阅指令的功能说明来了解其功能,
本质上来说都是属于人工进行译码操作.
但现在我们需要用电路来实现这一操作,
注意电路中存放的指令是其二进制表示, 因此我们需要在二进制层面对指令进行译码. -->

When executing instructions on the ISA state machine, we identify functionality either directly through assembler representations (e.g., `li r0, 10`) or by decoding binary instruction formats (e.g., `10001010`) using functional specifications - both being manual decoding approaches. Now we must implement this process in hardware circuits. Crucially, since instructions are stored in binary within circuits, we need to perform instruction decoding at the binary level.

<!-- 不过目前只需要实现一条`li`指令, 因此我们可以认为取到的指令就是`li`, 不存在其他情况.
这时, 我们只需要解析出`li`指令中的`rd`和`imm`字段即可.
从电路的角度上看, 这只是一些位抽取操作, 并不难实现. -->

However, since only the `li` instruction needs implementation currently, we can assume all fetched instructions are `li` with no other cases. At this stage, we simply need to extract the `rd` and `imm` fields from the `li` instruction. From a circuit perspective, this requires only bit-field extraction operations, which are straightforward to implement.

<!-- ### 执行 -->
### Execute

<!-- `li`指令的功能是将立即数`imm`写入`rd`寄存器中, 因此我们需要考虑如何实现ISA的GPR. -->

The `li` instruction loads the immediate value `imm` into the `rd` register. Consequently, we must address the implementation of the ISA's General-Purpose Registers.

<!-- 通常GPR包含多个寄存器, 一次访问通常只访问其中的几个寄存器, 因此GPR也应该支持寻址.
可以看到, GPR的电路本质也是一个存储器.
不过GPR需要作为目标寄存器被指令写入, 因此GPR是一个支持写入的存储器, 即RAM. -->

Typically, a GPR set contains multiple registers, with each access targeting only specific registers. Thus, the GPR must support addressing. This reveals that the GPR circuit is fundamentally a memory device. However, since GPRs serve as destination registers for instruction writes, they require writable memory functionality—making them RAM.

<!-- 考虑一个`2x3`的RAM, 其读操作涉及的结构如下图所示.
可以看到, 除了存储单元采用了D触发器之外, 其余结构与ROM基本一致,
因此RAM的读出操作的工作过程可参考上文ROM相关的部分. -->

Consider a `2×3` RAM whose read operation structure is shown in the figure below. Observe that except for the storage cells being implemented with D flip-flops, the remaining structure mirrors that of a ROM. Consequently, the read operation workflow of RAM can reference the description in the aforementioned ROM section.


| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/dd11d5756391fdd050b2d709d8c44398c90b30e3.png) |
|:-:|

<!-- 至于RAM的写操作, 涉及的结构如下图所示.
进行写操作除了需要提供地址外, 还需要提供待写入数据`D`.
对于RAM来说, 并非所有时刻都需要进行写入操作, 例如,
在执行`bner0`指令时, 就不需要写入GPR,
因此还需要一个写使能信号`EN`, 指示当前是否需要写入. -->

For RAM write operations, the involved structure is shown in the figure below. Performing a write requires not only an address but also the data to be written `D`. Since RAM doesn't require writing at all times (e.g., during `bner0`instruction execution, GPR writes are unnecessary), a write enable signal `EN` is essential to indicate whether writing should occur.

|![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/324171040aac2f903bef57d8bb9b981960a51d7f.png) |
|:-:|

<!-- 给定地址`addr`和待写入数据`D`, 在写使能`EN`有效时,
可以将数据`D`写入RAM中的相应存储字, 其工作过程如下.
待写入数据`D`通过位线将每一位分别连接到每一个存储字中相应位的`D`端,
写使能`EN`通过与门对地址译码器输出的独热码进行过滤, 并与字线连接,
因此在`EN`有效的情况下, 只有地址`addr`对应的字线有效, 其余行因字线无效.
将每一行的字线分别连接到对应存储器中相应的`EN`端,
被选中的存储字将更新为待写入数据`D`, 从而完成写入操作. -->
Given an address `addr` and write data `D`, when write enable `EN` is active, data `D` can be written to the corresponding memory word in RAM. The process operates as follows: Write data `D` connects each bit to the `D`-inputs of all memory cells in corresponding bit positions via bit lines. The enable signal `EN` filters the one-hot code output from the address decoder through an AND gate and connects to the word line. Consequently when `EN` is active, only the word line for `addr `asserts while others remain deasserted. Each row's word line connects to the enable (`EN`) input of its memory cells, causing the selected memory word to latch write data`D` at the next clock edge, completing the write operation.



<!-- 将读操作和写操作的结构合并, 得到RAM的结构如下图所示.
这种RAM在同一时刻只能通过一个地址访问其中的一个存储字, 称为"单端口RAM"(single port RAM).
相应地, 有的RAM在同一时刻可以通过多个地址访问其中的多个存储字, 称为"多端口RAM"(multi-port RAM).
可见, 增加RAM的"端口", 需要添加额外的电路逻辑, 从而使得多个端口的电路逻辑可以同时工作. -->

The structure of RAM shown in the following figure is obtained by combining the read and write operation structures. This type of RAM can only access one memory word via one address at any given time, thus being referred to as "single-port RAM". Correspondingly, some RAMs can access multiple memory words through multiple addresses simultaneously, which are called "multi-port RAMs". It is evident that increasing the number of "ports" in RAM requires adding extra circuit logic to enable the circuit logic of multiple ports to operate concurrently.

| ![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/d107e8cb3df932af02cbf3bd4fc0758129ad24d9.png) |
|:-:|

<!-- 和ROM类似, 图中的地址译码器, 读操作通路上的与门和或门, 在功能上共同构成了一个3位的2选1多路选择器.
因此对于RAM的读取功能, 也可以看作是数据端为寄存器的多路选择器,
但写入功能需要在寄存器的基础上额外实现. -->
Similar to ROM, the address decoder, the AND gates and OR gates in the read operation path in the diagram collectively form a 3-bit 2-to-1 multiplexer in terms of functionality. Therefore, the read function of RAM can also be regarded as a multiplexer with registers as its data terminals, while the write function needs to be additionally implemented on the basis of registers.

<!-- > #### todo::实现GPR及其写入功能
> 在寄存器的基础上搭建一个RAM, 从而实现GPR的写入功能.
> 你需要根据你的理解来确定RAM的规格. -->

> #### todo::Implement GPR and its write function
> Build a RAM based on registers to realize the write function of GPR.
> You need to determine the specifications of RAM according to your understanding.


<!-- ### 更新PC

更新PC的操作十分简单, 对PC寄存器加1即可, 这可以通过数字电路中的计数器来实现. -->

### Update PC

Updating the PC is a very simple operation, which only requires incrementing the PC register by 1. This can be achieved using a counter in digital circuits.


<!-- > #### todo::实现仅支持li指令的sCPU
> 根据上文, 用数字电路实现`li`的指令周期涉及的各个部件, 并将它们连接起来.
> 实现后, 尝试让sCPU执行数列求和程序中的前几条`li`指令,
> 并观察电路中GPR的状态是否与ISA的状态一致. -->

> #### todo::Implement an sCPU that only supports the li instruction
> Based on the above, implement each component involved in the instruction cycle of `li` using digital circuits and connect them together.
> After implementation, try to make the sCPU execute the first few `li` instructions in the sequence summation program,and observe whether the state of GPR in the circuit is consistent with the state specified by the ISA. 



<!-- 
## 实现完整的sCPU

接下来考虑如何实现`add`指令.
由于对所有指令来说, 取指和更新PC这两个步骤的行为都一样, 因此可以直接复用之前实现的取指逻辑. -->

## Implementing a Complete sCPU
Next, consider how to implement the `add` instruction.
Since for all instructions, the two steps of instruction fetch and PC update behave the same way, we can directly reuse the previously implemented instruction fetch logic.



<!-- 对于译码, 由于`add`指令的行为和`li`指令不同, 因此有必要识别当前取出的是什么指令.
为了实现这一点, 需要检查指令的`opcode`字段,
如果是`00`, 则是`add`指令, 如果是`10`, 则是`li`指令.
要识别输入的取值, 最适合的电路就是译码器!
由于`opcode`只有2位, 我们可以使用一个2-4译码器,
它输出的独热码可以指示当前指令属于何种指令, 这样的译码器称为指令译码器.
这组独热码通常作为控制信号, 用于控制部分电路如何工作, 从而支持不同指令的功能. -->

For decoding, since the behavior of the `add `instruction differs from that of the `li` instruction, it is necessary to identify which instruction is currently fetched. To achieve this, we need to check the `opcode` field of the instruction: if it is `00`, it is an `add` instruction; if it is `10`, it is an `li` instruction. The most suitable circuit for identifying the value of an input is a decoder! Since the `opcode` is only 2 bits, we can use a 2-4 decoder. The one-hot code it outputs can indicate the type of the current instruction, and such a decoder is called an instruction decoder. This set of one-hot codes usually serves as control signals to control how part of the circuit works, thereby supporting the functions of different instructions.


<!-- 考虑完操作码之后, 还需要考虑操作数.
和`li`指令相比, `add`指令除了需要写入`rd`, 还需要读出`rs1`和`rs2`作为源操作数,
需要同时通过两个读端口和一个写端口访问GPR.
因此, 我们还需要为GPR添加两个读口, 添加后, GPR模块应至少包含如下端口信号:
* 第1个读端口: `raddr1`(读地址), `rdata1`(读数据)
* 第2个读端口: `raddr2`, `rdata2`
* 写端口: `waddr`(写地址), `wdata`(写数据), `wen`(写使能), `clk`(时钟) -->

After considering the operation code, we also need to take the operands into account.
Compared with the `li` instruction, the `add` instruction not only needs to write to `rd`, but also needs to read `rs1` and `rs2` as source operands, requiring simultaneous access to GPR through two read ports and one write port.
Therefore, we also need to add two read ports to GPR. After adding, the GPR module should contain at least the following port signals:
* 1st read port: `raddr1` (read address), `rdata1` (read data)
* 2nd read port: `raddr2`, `rdata2`
* Write port: `waddr` (write address), `wdata` (write data), `wen` (write enable), `clk` (clock)



<!-- 读出源操作数后, `add`指令的行为是将两数相加, 然后将加法结果写入`rd`寄存器.
前者可以通过加法器实现, 但后者写入GPR时, GPR的`wdata`端口已经被`li`指令的结果占用.
考虑到指令`opcode`编码的唯一性, 一条指令不可能既是`li`指令又是`add`指令,
因此可以根据指令的类别对写入GPR的数据进行选择:
如果当前指令是加法指令, 就选择加法器的结果, 否则选择`li`指令的立即数.
可以通过多路选择器实现这样的选择功能, 将写入GPR的两个数据来源作为多路选择器的数据端,
然后让译码时独热码中合适的信号连接到多路选择器的选择端,
来控制多路选择器按照指令类型选出正确的数据, 即可实现上述功能. -->

After reading out the source operands, the behavior of the `add` instruction is to add the two numbers and then write the addition result to the `rd` register. The former can be implemented via an adder, but when the latter writes to GPR, the `wdata` port of GPR is already occupied by the result of the `li` instruction. Considering the uniqueness of instruction opcode encoding, an instruction cannot be both an `li` instruction and an `add` instruction. Therefore, the data to be written to GPR can be selected based on the instruction type: if the current instruction is an add instruction, the result of the adder is selected; otherwise, the immediate value of the `li` instruction is selected. Such a selection function can be implemented through a multiplexer: take the two data sources to be written to GPR as the data terminals of the multiplexer, and then connect the appropriate signal from the one-hot code during decoding to the select terminal of the multiplexer. This allows the multiplexer to select the correct data according to the instruction type, thereby realizing the aforementioned function.



<!-- > #### todo::添加add指令
> 根据上文, 在sCPU中添加`add`指令.
> 实现后, 尝试让sCPU继续执行数列求和程序中的几条`add`指令,
> 并观察电路中GPR的状态是否与ISA的状态一致. -->

> #### todo::Add the add instruction
> Based on the above, add the `add` instruction to the sCPU.
> After implementation, try to make the sCPU continue executing several `add` instructions in the sequence summation program, and observe whether the state of GPR in the circuit is consistent with the state specified by the ISA.

<!-- 最后是`bner0`指令.
为了识别`bner0`指令, 我们可以复用指令译码器的功能.
至于操作数, 除了指令中的`rs2`和`addr`, 还有一个隐含的`R[0]`.
由于`bner0`指令中`rs2`字段的位置和`add`指令中`rs2`字段的位置一样,
因此可以复用`add`指令中读出`rs2`寄存器的逻辑.
但`bner0`还需要读出`R[0]`, 因此可以把`0`作为GPR的`raddr1`端口的输入.
不过这个端口已经被`add`指令的`rs1`占用, 但也同样可以通过多路选择器的解决问题. -->

Finally, there is the `bner0` instruction.
To identify the `bner0` instruction, we can reuse the functionality of the instruction decoder.
As for operands, in addition to `rs2` and `addr` in the instruction, there is also an implicit `R[0]`. Since the position of the `rs2` field in the `bner0` instruction is the same as that in the `add` instruction, we can reuse the logic for reading the `rs2` register from the `add` instruction. However, `bner0` also needs to read out `R[0]`, so `0` can be used as the input to the `raddr1` port of GPR. This port is already occupied by `rs1` of the `add` instruction, but this issue can similarly be resolved using a multiplexer.


<!-- 读出源操作数后, `bner0`指令需要比较两数是否相等, 这可以通过比较器来实现.
若比较结果不相等, 需要将PC更新为`addr`字段.
换句话说, 只有当前指令为`bner0`指令, 且比较结果不相等,
才将PC更新为`addr`字段, 其余情况应将PC更新为PC加1.
同样地, 我们可以借助多路选择器对PC寄存器的输入端进行选择.

最后, `bner0`指令不会写入GPR, 因此需要将GPR的`wen`置为无效. -->

After reading out the source operands, the `bner0` instruction needs to compare whether the two numbers are equal, which can be implemented by a comparator. If the comparison result is not equal, the PC needs to be updated to the `addr` field. In other words, only when the current instruction is a `bner0` instruction and the comparison result is not equal, the PC is updated to the `addr` field; in all other cases, the PC should be updated to PC plus 1. Similarly, we can use a multiplexer to select the input of the PC register.
Finally, the `bner0` instruction does not write to GPR, so the `wen` of GPR needs to be set to invalid.


<!-- > #### todo::添加bner0指令
> 根据上文, 在sCPU中添加`bner0`指令.
> 实现后, 尝试让sCPU执行完整的数列求和程序,
> 如果你的实现正确, 你应该能看到PC最终为`7`, 且在某GPR中存放求和结果`55`. -->

> #### todo::Add the bner0 instruction
> Based on the above, add the `bner0` instruction to the sCPU.
> After implementation, try to make the sCPU execute the complete sequence summation program.
> If your implementation is correct, you should see that the PC is finally `7` and the summation result `55` is stored in a certain GPR



<!-- > #### todo::和数列求和电路进行对比
> 在学习数字电路时, 有一道必做题要求你通过寄存器和加法器, 计算出`1+2+...+10`的结果.
> 现在你用sCPU完成了同样的计算, 尝试对比两个方案各有什么优点和缺点. -->

> #### todo::Compare with the sequence summation circuit
> When studying digital circuits, there is a mandatory problem that requires you to calculate the result of `1+2+...+10` using registers and adders.
> Now that you have completed the same calculation with the sCPU, try to compare the advantages and disadvantages of the two schemes.



<!-- ## 重新审视CPU

恭喜! 这可能是你实现的第一个CPU!
尽管这个sCPU非常简单, 但也能从中窥探出一些可以帮助我们理解CPU的性质.

上文讨论如何添加指令时, 都是先分析指令的预期行为,
然后根据指令的行为在数据流动的方向上依次添加所需的部件.
数据在CPU中流动的路径和路径上的相关部件, 称为CPU的数据通路(data path),
在上文的讨论中, 属于数据通路的部件有GPR, 加法器, 存储器, 比较器等.

当多条指令的数据通路出现冲突时, 通常需要引入一些额外的电路,
来控制数据如何流动, 使得每条指令都能完成符合ISA规范的操作.
这些额外的电路属于CPU中的控制逻辑, 其中决定控制逻辑行为的信号称为控制信号.
事实上, 设计数据通路和控制信号, 正是CPU设计中最关键的两个步骤.

我们将前文涉及到的控制逻辑及其在不同指令执行时的预期行为整理如下: -->

## Re-examining the CPU

Congratulations! This is probably the first CPU you've implemented!
Although this sCPU is very simple, it allows us to glimpse some properties that help us understand CPUs.
When discussing how to add instructions earlier, we first analyzed the intended behavior of each instruction, then sequentially added the required components along the direction of data flow based on the instruction's behavior.
The paths through which data flows in the CPU, along with the related components on these paths, are called the CPU's data path. In the previous discussion, components belonging to the data path include GPRs, adders, memory, comparators, etc.
When data path conflicts occur among multiple instructions, it is usually necessary to introduce additional circuits to control the flow of data, ensuring that each instruction can perform operations compliant with the ISA specifications.
These additional circuits belong to the control logic within the CPU, and the signals that determine the behavior of the control logic are called control signals.
In fact, designing the data path and control signals are precisely the two most critical steps in CPU design.
We have summarized the control logic involved earlier and their intended behaviors when executing different instructions as follows:







| Instruction   | `wdata` Selection	 | `wen` | `raddr2` Selection | PC Update Selection |
|:-------:|:-------------:|:-----:|:--------------:|:------------:|
| `add`   | Adder output	  |  `1`  |   Instruction's `rs2`  |   `PC + 1`   |
| `li`    | Immediate value        |  `1`  |    `X`         |   `PC + 1`   |
| `bner0` |  `X`          |  `0`  |    `0`         | 指令的`addr` |

<!-- 其中, `X`表示无关项(don't care), 选择什么都可以.
例如`bner0`指令不会写入GPR, 因此无论`wdata`选择什么, 都不影响sCPU的正确性.
注意到这些选择与指令的类型相关, 也即, 指令的类型决定了控制逻辑的行为,
从而决定了数据通路中数据的流向, 最终完成指令约定的功能.

观察你在Logisim中设计的sCPU, 如果把取出的指令作为边界, 将sCPU划分为左右两侧,
你应该能发现, 左侧向右侧传递的信息只有指令.
同时, 右侧电路的控制逻辑最终都是由指令译码器所输出的独热码控制的,
而指令译码器的输入端就是指令的操作码,
因此可以说, 右侧的电路完全受到指令的控制.
这恰恰印证了上一节所说的, `在CPU上执行程序 = 用程序编译出的指令序列控制CPU电路进行状态转移`.

最后, 我们通过一些必做题来加深对指令的理解. -->

Among them, `X` denotes a don't care, meaning any selection is acceptable. For example, the `bner0` instruction does not write to GPR, so regardless of what is selected for `wdata`, it does not affect the correctness of the sCPU.
It should be noted that these selections are related to the type of instruction; that is, the type of instruction determines the behavior of the control logic, which in turn determines the direction of data flow in the data path, and ultimately accomplishes the function specified by the instruction.
Looking at the sCPU you designed in Logisim, if you take the fetched instruction as a boundary and divide the sCPU into left and right sides, you should find that the only information transmitted from the left side to the right side is the instruction. At the same time, the control logic of the right-side circuit is ultimately controlled by the one-hot code output by the instruction decoder, and the input terminal of the instruction decoder is the opcode of the instruction. Therefore, it can be said that the right-side circuit is completely controlled by the instruction. This exactly confirms what was stated in the previous section: `"Executing a program on the CPU = using the instruction sequence compiled from the program to control the CPU circuit to perform state transitions."`
Finally, we will deepen our understanding of instructions through some mandatory exercises.





<!-- > #### todo::计算10以内的奇数之和
> 编写一段指令序列, 计算10以内的奇数之和, 即`1+3+5+7+9`.
> 然后尝试用你设计的sCPU指令这段指令序列, 检查运行结果是否符合预期.
>
> 完成后, 你对计算机的"存储程序"思想有什么认识? -->

> #### todo::Calculate the sum of odd numbers within 10
> Write a sequence of instructions to calculate the sum of odd numbers within 10, i.e.,`1+3+5+7+9`.
> Then try to execute this instruction sequence with the sCPU you designed and check if the running result meets the expectations.
> After completion, what understanding do you have of the computer's "stored program" idea?


<!-- > #### todo::添加新指令
> 尝试为sISA添加一条新指令`out rs`, 执行该指令后,
> 会将`R[rs]`以十六进制的形式输出到七段数码管.
> 你可以自行决定这条指令的编码.
>
> 然后, 在sCPU中实现`out`指令, 并修改数列求和程序,
> 使得在计算出结果后, 能在七段数码管中显示计算结果. -->

> #### todo::Add a new instruction
> Try to add a new instruction `out rs` to sISA. When this instruction is executed, it will output `R[rs]` in hexadecimal form to the seven-segment display.
> You can determine the encoding of this instruction by yourself.
> Then, implement the`out`instruction in the sCPU and modify the sequence summation program so that the calculation result can be displayed on the seven-segment display after it is calculated.



<!-- > #### question::能设计一条让10个数相加的指令吗?
> 上述数列求和的程序需要执行数十条指令才能计算出结果.
> 有同学建议, 为了提升sCPU的计算效率, 应该设计一条让10个数相加的指令,
> 这样就可以通过一条指令直接计算`1+2+...+10`.
> 该建议是否合理? 尝试从程序, ISA和CPU电路设计的角度给出你的理由. -->


> #### question::Is it possible to design an instruction that adds 10 numbers?
> The sequence summation program mentioned above requires dozens of instructions to compute the result.
> A classmate suggested that, in order to improve the computing efficiency of the sCPU, an instruction that adds 10 numbers should be designed, so that `1+2+...+10` can be directly computed with a single instruction.
> Is this suggestion reasonable? Try to provide your reasons from the perspectives of programs, ISA, and CPU circuit design.
