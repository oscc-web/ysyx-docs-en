# C5 Exception Handling and RT-Thread

After implementing IOE, we will next implement CTE on NEMU and NPC. Once implemented, we will be able to run more complex operating systems!

## Running RT-Thread on NEMU

> #### todo::Implement Trap Operations in NEMU
> Complete Phase 1 of PA3 according to the PA lecture notes until you see the following prompt box:
> > #### flag::Friendly Reminder
> > Phase 1 of PA3 ends here.

<!-- -->
> #### todo::Run RT-Thread on NEMU
> Complete Phase 1 of PA4 according to the PA lecture notes until RT-Thread boots. You don't need to complete the Nanos-lite related content for now.

## Running RT-Thread on NPC

With the help of AM, we can run RT-Thread at a very low cost.
In terms of hardware, we only need to implement a few CSRs, several CSR instructions, the `ecall` and `mret` instructions, and the corresponding exception response mechanism.
You already learned about these when implementing NEMU. Here we briefly discuss how to implement them through RTL.
* The CSR register address space in RISC-V is 12 bits, i.e., 4096 registers, but RISC-V has only defined over 300 CSRs;
  if we exclude performance counters and PMP (Physical Memory Protection) related CSRs, there are only 78 left;
  if we further only count M-mode CSRs, there are only 28;
  if we only consider the few CSRs necessary for running RT-Thread that were implemented in NEMU, there are less than 5 left.
  Therefore, there is no need for us to instantiate hundreds or even 4096 CSRs.
  Although this would only take up some memory for NEMU, it would result in significant area overhead for NPC.
  Specifically, we only need to instantiate the CSRs we need, then read and write them according to their addresses.
* The CSRs that need to be implemented currently do not have any special side effects. Although the RISC-V manual describes various functions for mstatus,
  we don't need to use them at present. We just need to initialize them correctly to pass DiffTest.
* Only a few CSR instructions will be used currently, but unlike general instructions, CSR instructions atomically read and write the same CSR register.
  Additionally, we can ignore the read and write attributes of each field in the CSRs for now
  (if you haven't heard of them, you need to carefully RTFM), including WPRI, WLRL, and WARL,
  which define the behavior when illegal values are written to CSR fields.
  The programs we are running currently do not depend on these behaviors, so we can temporarily skip implementing these read and write attributes.
* Both `ecall` and `mret` will cause NPC to jump, which can be easily implemented by reusing the data path of the next address logic.
* Currently, we only need to implement the `ecall` exception, which is a trap exception that NPC must respond to unconditionally.
  We just need to set mcause and mepc simultaneously, then jump to the exception entry stored in mtvec.

> #### todo::Run RT-Thread on NPC
> Implement a simple exception handling mechanism in NPC and run RT-Thread.

<!-- -->
> #### option::Fix the Issue Where RT-Thread Doesn't Output the Final Command Prompt
> You will notice that, unlike in NEMU, when running RT-Thread on NPC, the final `msh />` is not output.
> If you are interested in this issue, you can think about how to solve it now.
> You can also choose to ignore this issue, as you will encounter similar problems when connecting to the SoC later.

The complete exception handling mechanism in RISC-V is much more complex than what we are implementing now,
and commercial RISC-V processors must accurately implement every detail described in the manual, regardless of whether customers will use them.
Implementing all CSRs and carefully handling each bit is actually a rather engineering-oriented task that requires a lot of effort from the engineering team.
However, "One Student One Chip" is ultimately an educational project, and its goal is not to design a RISC-V processor that meets commercial delivery requirements.
Therefore, we can simplify various complex mechanisms on the premise that the demonstration programs run correctly,
allowing everyone to focus on learning key principles and developing core functions.
As we run more programs in the A phase in the future, we will gradually add various CSRs and their core functions.

