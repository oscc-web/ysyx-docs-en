<!-- # E5 从RTL代码到可流片版图 -->
# E5 From RTL Code to Tapeout-Ready Layout

<!-- 你已经通过在线学习网站HDLbits学习了Verilog的使用,
同样地, 为了设计自己的处理器, 我们需要使用Linux作为开发环境.

有了Linux开发环境后, 我们就可以开展更多芯片设计流程中的工作了.
具体地, 使用Verilog等语言进行RTL开发只是属于整个流程中逻辑设计的步骤,
后续还涉及验证和评估的工作, 具体包括:
* 功能验证 - 通过RTL仿真检查RTL代码所描述的电路功能是否符合预期
* 电路评估 - 通过综合器将RTL代码逻辑元件转变为物理标准单元的网表
* 物理设计 - 将标准单元的网表转变为可流片的版图 -->
You have already learned how to use Verilog through the online learning platform HDLBits. Similarly, to design your own processor, you will need to use Linux as the development environment.

With a Linux development environment in place, you can carry out more steps in the chip design process. Specifically, writing RTL code using Verilog is just one part of the overall flow - the logic design stage. Following that, additional tasks such as verification and evaluation are involved, including:
* Functional Verification - Simulating the RTL to check whether the described circuit behaves as expected
* Circuit Evaluation - Converting the RTL code into a gate-level netlist using standard logic cells
* Physical Design - Transforming the netlist into a tapeout-ready layout for fabrication

## RTL Simulation - Functional Verification

<!-- 在Linux中进行RTL代码的开发并不困难, 只需要一款编辑器即可.
但在完成RTL代码的开发工作后, 我们还需要一款仿真器来验证RTL代码所描述的电路是否符合预期. -->

It is not hard to develop RTL code in Linux, as long as we have a text editor. However, we also need a simulator to check if our circuit from the RTL code functions as what we expected after we finish our RTL code development.

<!-- ### RTL仿真的基本原理 -->
### Basic Principles of RTL Simulations

<!-- RTL仿真的本质是通过软件程序来模拟硬件电路的行为.
因此, 要实现RTL仿真, 就是要考虑如何用C程序的状态机实现ISA的状态机.
为此, 我们先回顾状态机视角下的C程序和: -->
The essence of RTL simulation is to use a software program to mimic the behavior of a hardware circuit.
Therefore, to implement RTL simulation, we need to consider how to use a state machine in a C program to implement the state machine defined by the ISA.
To do this, let’s first review how a C program looks from the perspective of a state machine:
<!-- |              | C程序       | 数字电路       |
|:------------:|:-----------:|:--------------:|
| 状态         | $\{PC, V\}$ | 时序逻辑电路   |
| 激励事件     | 执行语句    | 处理组合逻辑   |
| 状态转移规则 | 语句的语义  | 组合逻辑电路的逻辑 | -->

|              | C Program       | Digital Circuit       |
|:------------:|:-----------:|:--------------:|
| State         | $\{PC, V\}$ | Sequential Logic Circuit   |
| Stimulus Event     | Executing Statements    | Processing Combinational Logic   |
| State Transition Rule | Semantics of Statements  |Combinational Logic |

<!-- 要用C程序的状态机实现数字电路的状态机, 我们需要开发一个包含如下功能的C程序:
* 用C程序的状态实现数字电路的状态, 也即, 用C程序的变量实现时序逻辑电路
* 用C程序的状态转移规则实现数字电路的状态转移规则, 也即, 用C语言语句实现组合逻辑电路的逻辑 -->
To implement a digital circuit state machine using a C program state machine, we need to develop a C program with the following functionalities:
* Implement the states of the digital circuit using the states of the C program, that is, implement the sequential logic circuit using variables in the C program.
* Implement the state transition rules of the digital circuit using the state transition rules of the C program, that is, implement the logic of the combinational logic circuit using C language statements.

<!-- 我们来看一个流水灯的例子.
流水灯是按照顺序依次亮起和熄灭的一组灯, 以下是一个流水灯模块的Verilog代码: -->
Let's examine an example of a running light. A running light is a group of lights that turn on and off in sequence. The following is the Verilog code for a running light module:
```verilog
module light(
  input clk,
  input rst,
  output reg [15:0] led
);
  reg [31:0] count;
  always @(posedge clk) begin
    if (rst) begin led <= 1; count <= 0; end
    else begin
      if (count == 0) led <= {led[14:0], led[15]};
      count <= (count >= 5000000 ? 32'b0 : count + 1);
    end
  end
endmodule
```

<!-- 根据上述Verilog代码所描述的电路, 我们可以设计一个C程序,
来对这个电路进行RTL层次的仿真: -->
We can write a C program to simulate this circuit in the RTL level according to the above Verilog code.

```c
#include <stdio.h>
#include <stdint.h>

#define _CONCAT(x, y) x ## y
#define CONCAT(x, y)  _CONCAT(x, y)
#define BITMASK(bits) ((1ull << (bits)) - 1)
// similar to x[hi:lo] in verilog
#define BITS(x, hi, lo) (((x) >> (lo)) & BITMASK((hi) - (lo) + 1))
#define DEF_WIRE(name, w) uint64_t name : w
#define DEF_REG(name, w)  uint64_t name : w; \
                          uint64_t CONCAT(name, _next) : w; \
                          uint64_t CONCAT(name, _update) : 1
#define EVAL(c, name, val) do { \
                             c->CONCAT(name, _next) = (val); \
                             c->CONCAT(name, _update) = 1; \
                           } while (0)
#define UPDATE(c, name)    do { \
                             if (c->CONCAT(name, _update)) { \
                               c->name = c->CONCAT(name, _next); \
                             } \
                           } while (0)

typedef struct {
  DEF_WIRE(clk, 1);
  DEF_WIRE(rst, 1);
  DEF_REG (led, 16);
  DEF_REG (count, 32);
} Circuit;
static Circuit circuit;

static void cycle(Circuit *c) {
  c->led_update = 0;
  c->count_update = 0;
  if (c->rst) {
    EVAL(c, led, 1);
    EVAL(c, count, 0);
  } else {
    if (c->count == 0) {
      EVAL(c, led, (BITS(c->led, 14, 0) << 1) | BITS(c->led, 15, 15));
    }
    EVAL(c, count, c->count >= 5000000 ? 0 : c->count + 1);
  }
  UPDATE(c, led);
  UPDATE(c, count);
}

static void reset(Circuit *c) {
  c->rst = 1;
  cycle(c);
  c->rst = 0;
}

static void display(Circuit *c) {
  static uint16_t last_led = 0;
  if (last_led != c->led) { // only update display when c->led changes
    for (int i = 0; i < 16; i ++) {
      putchar(BITS(c->led, i, i) ? 'o' : '.');
    }
    putchar('\r');
    fflush(stdout);
    last_led = c->led;
  }
}

int main() {
  reset(&circuit);
  while (1) {
    cycle(&circuit);
    display(&circuit);
  }
  return 0;
}
```

<!-- 程序通过`circuit`这个结构体变量来实现时序逻辑电路, 包括`led`和`count`.
虽然`clk`和`rst`不属于时序逻辑电路,
但它们作为电路的输入, 也是电路状态的一部分, 因此也出现在结构体中.
此外, 程序通过C语言的语句来实现组合逻辑电路的逻辑.
可以看到, 上述`cycle()`函数的内容基本上是相应Verilog代码的直接翻译,
除了引入一些后缀为`next`的中间变量和后缀为`update`的更新标志.
这些中间变量的引入是为了实现Verilog非阻塞赋值的语义,
也即, 相应信号的更新需要等到周期结束时才发生.
因此, 仿真过程需要先把组合逻辑的计算结果暂存到这些中间变量中, 并设置更新标志,
在一个周期结束时, 才依据更新标志, 把计算结果真正写入到时序逻辑元件相关的变量中. -->
The program implements sequential logic circuits through the structure variable `circuit`, which includes `led` and `count`.
Although `clk` and `rst` do not belong to sequential logic circuits,
they are included in the structure as inputs to the circuit and also part of the circuit state.
In addition, the program implements the logic of combinational logic circuits through C language statements.
It can be seen that the content of the above `cycle()` function is basically a direct translation of the corresponding Verilog code,
except for the introduction of some intermediate variables with the suffix `next` and update flags with the suffix `update`.
These intermediate variables are introduced to implement the semantics of Verilog non-blocking assignments,
that is, the update of the corresponding signals needs to wait until the end of the cycle.
Therefore, during the simulation process, it is necessary to first temporarily store the calculation results of the combinational logic in these intermediate variables and set the update flags.
Only at the end of a cycle, according to the update flags, the calculation results are truly written into the variables related to the sequential logic elements.

<!-- `main()`函数的`while`循环揭示了RTL仿真的主要过程:
通过不断执行`cycle()`函数, 从而实现"根据输入和当前状态计算出新状态并更新"的功能.
这一功能其实也是数字电路工作的本质.
不过在进入`while`循环之前, 还需要通过`reset()`函数对电路进行复位.
此外, 虽然`display()`函数并不属于电路本身的功能, 但为了呈现电路的功能,
`diplay()`函数将根据`led`信号每一位的状态来输出相应的字符, 从而在终端展示出流水灯的效果. -->
The `while` loop in the `main()` function reveals the main process of RTL simulation:
By continuously executing the `cycle()` function, it realizes the function of "calculating and updating the new state based on inputs and the current state".
This function is actually the essence of how digital circuits work.
However, before entering the `while` loop, it is necessary to reset the circuit through the `reset()` function.
In addition, although the `display()` function does not belong to the circuit itself, it is used to demonstrate the circuit's functionality.
The `display()` function outputs corresponding characters according to the state of each bit of the `led` signal, thereby showing the running light effect on the terminal.

<!-- 上面的仿真程序是手工编写的,
但如果针对每个电路设计都要手工编写对应的仿真程序才能开展功能验证工作,
这会给开发者带来很多麻烦.
为此, 开发者一般通过一个RTL仿真器的软件, 将RTL代码自动转换为用于模拟电路行为的C程序,
这个C程序就是RTL代码对应的电路仿真程序. -->
The above simulation program is written manually.
However, if developers have to manually write corresponding simulation programs for each circuit design to carry out functional verification,
it will bring a lot of troubles to developers.
For this reason, developers generally use an RTL simulator software to automatically convert RTL code into a C program for simulating circuit behavior.
This C program is the circuit simulation program corresponding to the RTL code.

<!-- ### STFW + RTFM搭建Verilator仿真环境 -->
### STFW + RTFM to Build The Verilator Simulation Environment

<!-- Verilator是一款开源的Verilog仿真器, 你将会使用它来进行RTL功能仿真.

框架代码默认提供了一个`npc`目录,
这里的`npc`是`New Processor Core`的含义, 你将来会在这个目录下设计自己的处理器.
我们将大家设计的处理器统称为NPC, 当然大家可以给自己的处理器起一个更个性化的名字.
不过为了设置一个环境变量``NPC_HOME``, 你需要运行如下命令: -->
Verilator is an open-source Verilog simulator that you will use for RTL functional simulation.
The framework code provides an `npc` directory by default, where "npc" stands for "New Processor Core". You will design your own processor in this directory in the future. The processors designed by everyone will be collectively referred to as NPC, but you can certainly give your processor a more personalized name.
However, to set an environment variable ``NPC_HOME``, you need to run the following command:
```bash
cd ysyx-workbench
bash init.sh npc
```
<!-- 这个环境变量会在将来使用.
`npc`目录下有一些简单的文件: -->
This environment variable will be used in the future. There are some simple files in the `npc` directory:
```
ysyx-workbench/npc
├── csrc
│   └── main.cpp
├── Makefile
└── vsrc
    └── example.v
```
<!-- 目前这三个文件几乎都是空文件, 我们将会引导大家搭建Verilator仿真环境,
并编写两个简单的数字电路模块来进行仿真. -->
Currently, these three files are almost empty. We will guide you through setting up the Verilator simulation environment and writing two simple digital circuit modules for simulation. 

<!-- > #### caution::竟然连仿真框架都没有, 真寒酸 -->
> #### caution::There isn't even a simulation framework? Lame!
<!-- > 我们之所以设置这部分的实验内容, 是为了让大家知道,
> <font color=red>项目里面的所有细节都是和大家有关系的</font>.
>
> 在以前的课程实验当中, 大家不多不少都会觉得,
> 框架理所应当是由助教来提供的, 做实验就是在指定的地方写上相应的代码,
> 其它都是无关的代码/文件, 大家不需要关心.
> 事实上, 这样的实验方案是<font color=red>很危险</font>的, 这不仅不能将你训练成真正的专业人士,
> 反而会使得你无法在真正的项目中存活下来:
> 1. 遇到系统性的bug, 肯定调不出来, 因为连调用你代码的模块你都觉得跟你没关系,
> 更别说可以清晰地认识到整个项目的架构和其中的每一处细节了
> 1. 离开了讲义, 就什么都做不了, 因为你总是在等别人像这些讲义一样清楚地告诉你接下来应该做什么怎么做,
> 而不是站在项目的角度去切实分析现在应该做什么 -->
> The reason why we have included this part of the experiment is to let everyone understand that <font color=red>all details in the project are relevant to you</font>.
In previous course experiments, more or less, everyone would feel that the framework should naturally be provided by the teaching assistants. Doing the experiment just meant writing the corresponding code in the designated places, and all other codes/files were irrelevant and didn't require attention. In fact, such an experimental approach is <font color=red>very dangerous</font>. It not only fails to train you into a truly professional person but also makes it impossible for you to survive in real projects:
> 1. When encountering systematic bugs, you will definitely not be able to fix them. Because even the modules that call your code are considered irrelevant to you, let alone having a clear understanding of the entire project's architecture and every detail within it.
> 1. Without lecture notes, you can't do anything. Because you are always waiting for others to clearly tell you what to do next and how to do it, just like these lecture notes do, instead of practically analyzing what should be done from the project's perspective.
>
> A very realistic scenario is that when you join a company or a research group in the future, there will no longer be lecture notes or framework codes to assist you. If your boss says "Come and try Verilator", you have to get Verilator up and running by yourself, write a usage report, and present your work to the boss at the group meeting next week.
Therefore, we hope to provide you with more realistic training: set a goal, and let you learn to break down the goal and achieve it step by step with your own skills. Building a Verilator simulation framework is actually a goal that can be easily achieved, so it is also very suitable as a small training to test your abilities.
<!-- > 一个很现实的场景是, 以后你到了企业或者进入课题组, 不会再有讲义和框架代码照顾你,
> 你的老板说一句"来试试Verilator", 你就要自己把Verilator跑起来,
> 写一份使用报告, 在下周的组会上给老板汇报工作.
>
> 因此, 我们希望给大家提供更真实的训练: 给出一个目标,
> 让大家学会对目标进行分解, 并通过自身的技能一步步达成这个目标.
> 搭建Verilator仿真框架其实是一个很容易实现的目标, 因此作为一项小试牛刀的训练, 也是非常合适的. -->


<!-- > #### hint::如果你想使用Chisel
> Chisel可以生成功能等价的Verilog代码, 并通过Verilator进行仿真.
> 目前我们先关注Verilator的使用方法, 如果你想使用Chisel,
> 我们也建议你先按照讲义内容搭建好Verilog的工作流程, 完后再切换到Chisel. -->
> #### hint:: If you want to use Chisel
> Chisel can generate functionally equivalent Verilog code, which can then be simulated using Verilator.
For now, we will focus on the usage of Verilator. If you wish to use Chisel,
we also recommend that you first set up the Verilog workflow as described in the lecture notes, and then switch

<!-- 事不宜迟, 我们马上开始. -->
Let's begin.

<!-- > #### todo::认识Verilator
> 你很可能是第一次听说过Verilator这个工具, 这是很正常的.
> 然后你就会想进一步了解Verilator的各种信息, 这也是很正常的.
> 但如果你的第一反应是去问人, 这就不恰当了.
> 事实上, Verilator这个工具在仿真领域已经非常有名, 以至于你可以很容易在互联网上搜索到它的相关信息.
> 你需要通过STFW找到它的官方网站, 然后阅读一下相关的介绍. -->
> #### todo::Familiarize with Verilator
> This is probably the first time you hear about Verilator, and that's quite normal. Then, it is also normal that you would want to learn more about various aspects of Verilator. However, it is inappropriate if your first reaction is to ask others. In fact, the Verilator tool is so well - known in the simulation field that you can easily find relevant information about it on the Internet. You need to find its official website through STFW and then read the relevant introduction.

<!-- 找到官网并且阅读过相关介绍之后, 接下来就是通过运行来体会一下了.
不过在这之前, 我们还需要安装它. -->
After finding and reading the relavent informations, it is time to try running it. But before that we need to install it first.

<!-- > #### todo::安装Verilator
> 在官网中找到安装Verilator的步骤, 然后按照从git安装的相应步骤进行操作.
> 我们之所以不采用`apt-get`安装, 是因为其版本较老.
> 此外, 为了统一版本, 你需要通过git安装`5.008`的版本.
> 为此, 你还需要进行一些简单的git操作, 如果你对此感到生疏, 你可能需要寻找一些git教程来学习.
> 另外, 你最好在`ysyx-workbench/`之外的目录进行这一操作,
> 否则git将会追踪到Verilator的源代码, 从而占用不必要的磁盘空间.
>
> 安装成功后, 运行以下命令来检查安装是否成功, 以及版本是否正确. -->
> #### todo::Installing Verilator
> Find the steps to install Verilator on the official website and follow the corresponding steps for installation via git.
The reason we don't use `apt-get` for installation is that the version it provides is relatively old.
In addition, to unify the version, you need to install version `5.008` via git.
For this purpose, you also need to perform some simple git operations. If you are not familiar with this, you may need to look for some git tutorials to learn.
Moreover, it's better for you to carry out this operation in a directory outside `ysyx-workbench/`.
Otherwise, git will track the source code of Verilator, thereby occupying unnecessary disk space.
After successful installation, run the following command to check if the installation is successful and if the version is correct.
> ```bash
> verilator --version
> ```
<!-- Verilator会编译出C++文件, 然后将C++文件编译成可执行文件,
通过执行这个可执行文件来进行仿真. -->
Verilator compiles code into C++ files, which are then compiled into executable files. Simulation is carried out by running these executable files.

<!-- > #### todo::运行示例
> Verilator手册中包含一个C++的示例, 你需要在手册中找到这个示例, 然后按照示例的步骤进行操作.
>
> 你已经学习过C语言, 为了使用Verilator, 你并不需要了解复杂的C++语法,
> 你只需要了解一些类(class)的基本使用方法就可以了.
> 单从这一点来看, 网上的很多资料都可以满足你的需求. -->
> #### todo::Running An Example
> The Verilator manual contains a C++ example. You need to find this example in the manual and follow the steps of the example to operate.
You have already learned C language. To use Verilator, you don't need to understand complex C++ syntax.
You just need to know some basic usage methods of classes.
From this point of view, many materials on the Internet can meet your needs.

<!-- ### 示例: 双控开关(组合逻辑电路)

手册中的示例非常简单, 甚至算不上是一个真正的电路模块.
接下来我们编写一个真正的电路模块, 双控开关, 来进行测试.
编写如下的Verilog代码: -->
### Example: Two-way Switch (Combinational Logic Circuit)
The example in the manual is very simple and doesn't even qualify as a real circuit module.
Next, we'll write a real circuit module, a two-way switch, for testing.
Write the following Verilog code:
```verilog
module top(
  input a,
  input b,
  output f
);
  assign f = a ^ b;
endmodule
```
<!-- 双控开关的一个应用是通过两个开关(`a`和`b`)联合控制同一盏灯的亮灭(`f`).
和手册中的示例不同, 这个模块有输入输出端口.
为了驱动输入端口, 并从输出端口获得结果,
我们需要对C++文件中的`while`循环进行修改: -->
One application of a two-way switch is to jointly control the on/off state (`f`) of the same lamp through two switches (`a` and `b`).
Unlike the example in the manual, this module has input and output ports.
To drive the input ports and obtain results from the output ports,
we need to modify the `while` loop in the C++ file:
```c
// 以下为伪代码

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

while (???) {
  int a = rand() & 1;
  int b = rand() & 1;
  top->a = a;
  top->b = b;
  top->eval();
  printf("a = %d, b = %d, f = %d\n", a, b, top->f);
  assert(top->f == (a ^ b));
}
```
<!-- 在一次循环中, 代码将会随机生成两个1比特信号, 用来驱动两个输入端口,
然后通过`eval()`函数更新电路的状态, 这样我们就可以读取输出端口的值并打印.
为了自动检查结果是否正确, 我们通过`assert()`语句对输出结果进行检查. -->
In one loop iteration, the code will randomly generate two 1-bit signals to drive the two input ports. Then, it will update the circuit state using the `eval()` function, allowing us to read and print the values from the output port. To automatically verify the correctness of the results, we will check the output using `assert()` statements.

<!-- > #### todo::对双控开关模块进行仿真
> 尝试在Verilator中对双控开关模块进行仿真.
> 由于顶层模块名与手册中的示例有所不同, 你还需要对C++文件进行一些相应的修改.
> 此外, 这个项目没有指示仿真结束的语句, 为了退出仿真, 你需要键入`Ctrl+C`.

> #### hint::上述代码是什么意思?
> 如果你不知道应该如何修改, 说明你还不太熟悉C程序的编写,
> 你应该先回到上一小节复习C语言. -->
> #### todo::Simulate the two-way switch module
> Try to simulate the two-way switch module in Verilator.
Since the top-level module name is different from the example in the manual, you need to make some corresponding modifications to the C++ file.
In addition, this project has no statement to indicate the end of the simulation. To exit the simulation, you need to type `Ctrl+C`.

> #### hint::What does the above code mean?
> If you don't know how to modify it, it means you are not very familiar with writing C programs.
You should go back to the previous section to review C language.

<!-- ### 打印并查看波形

查看波形文件是RTL调试的常用手段之一.
Verilator支持波形的生成, 你可以通过开源的波形查看工具GTKWave来查看波形.

> #### todo::生成波形并查看
> Verilator手册中已经介绍了波形生成的方法, 你需要阅读手册找到相关内容,
> 然后按照手册中的步骤生成波形文件, 并通过
> ```bash
> apt-get install gtkwave
> ```
> 安装GTKWave来查看波形.

> #### hint::手册这么多内容, 怎么找?
> 尝试一下键入`Ctrl+F`.

> #### danger::不要长时间生成波形
> 波形文件一般会占用较多的磁盘空间, 长时间生成波形可能会导致磁盘空间耗尽, 从而导致系统崩溃.

> #### hint::生成FST格式的波形
> FST格式的波形文件的大小大致是VCD格式的1/50, 但它仅能被GTKWave支持.
> 尽管如此, 我们还是推荐你使用它.
> 具体地, 你可以查阅Verilator手册, 了解如何生成FST格式的波形. -->
### Printing and Viewing Waveforms
Viewing waveform files is one of the common methods for RTL debugging.
Verilator supports waveform generation, and you can view waveforms using the open-source waveform viewer GTKWave.
> #### todo::Generate and View Waveforms
> The Verilator manual has already introduced the method for generating waveforms. You need to read the manual to find the relevant content,
then follow the steps in the manual to generate the waveform file, and install GTKWave using
```bash
apt-get install gtkwave
```
> to view the waveforms.

> #### hint::With so much content in the manual, how to find it?
> Try pressing `Ctrl+F`.

> #### danger::Do not generate waveforms for a long time
> Waveform files generally occupy a lot of disk space. Generating waveforms for a long time may lead to disk space exhaustion, which can cause the system to crash.

> #### hint::Generate FST format waveforms
> The size of FST format waveform files is roughly 1/50 of that of VCD format, but it is only supported by GTKWave.
Nevertheless, we still recommend you to use it.
Specifically, you can refer to the Verilator manual to learn how to generate FST format waveforms.


<!-- ### 编写Makefile

> #### todo::一键仿真
> 反复键入编译运行的命令是很不方便的, 尝试为`npc/Makefile`编写规则`sim`,
> 实现一键仿真, 如键入`make sim`即可进行上述仿真.

> #### danger::注意保留git追踪的命令
> 框架代码已经在`npc/Makefile`中提供了一条默认的`sim`规则,
> 它已经包含用于git追踪的命令``$(call git_commit, "sim RTL")``,
> 在编写Makefile的时候注意不要修改这一命令, 否则会影响开发跟踪的功能,
> 而这是记录"一生一芯"成果原创性的重要依据.
> 因此在编写Makefile并运行之后, 你也需要确认git是否已经正确追踪了仿真的记录. -->
### Writing Makefile

> #### todo::One-click Simulation
> Repeatedly typing compile and run commands is inconvenient. Try to write a `sim` rule for `npc/Makefile` to implement one-click simulation, such that typing `make sim` will execute the above simulation.

> #### danger::Note to Preserve Git Tracking Commands
> The framework code has already provided a default `sim` rule in `npc/Makefile`, which includes the command for git tracking: ``$(call git_commit, "sim RTL")``. When writing the Makefile, be careful not to modify this command, as it will affect the development tracking function, which is an important basis for recording the originality of the "One Student One Chip" results. Therefore, after writing the Makefile and running it, you also need to confirm whether git has correctly tracked the simulation records.

<!-- ### 接入NVBoard

[NVBoard][nvboard](NJU Virtual Board)是南京大学开发的, 用于教学的虚拟FPGA板卡项目,
可以在RTL仿真环境中提供一个虚拟板卡的界面, 支持拨码开关, LED灯, VGA显示等功能,
在速度要求不高的场景下可完全替代真实的FPGA板卡(毕竟不是每人身边都有一块FPGA).
通过以下命令获取NVBoard的代码: -->
### Integrating NVBoard
[NVBoard][nvboard] (NJU Virtual Board) is a virtual FPGA board project developed by Nanjing University for teaching purposes. It can provide a virtual board interface in an RTL simulation environment, supporting functions such as DIP switches, LED lights, VGA displays, etc. In scenarios where speed requirements are not high, it can completely replace a real FPGA board (after all, not everyone has an FPGA at hand). Obtain the NVBoard code using the following command:
```bash
cd ysyx-workbench
bash init.sh nvboard
```

[nvboard]: https://github.com/NJU-ProjectN/nvboard.git

<!-- > #### todo::运行NVBoard示例
> 阅读NVBoard项目的介绍, 尝试运行NVBoard项目中提供的示例. -->
>#### todo::Running The NVBoard Example
> Read the README.md of NVBoard, and try to run the provided example.

<!-- > #### hint::不知道NVBoard如何工作?
> 试试从`make`命令开始, 看看一切是如何发生的.
> 通过前面的学习, 你已经掌握了足够的知识背景去理解NVBoard如何工作了:
> 包括Makefile的使用, C语言和C++中类的基本用法.
> 现在就试试阅读代码(Makefile也是代码), 看看示例中的Verilog顶层端口,
> 约束文件, 以及NVBoard是如何建立联系的.

> #### todo::在NVBoard上实现双控开关
> 阅读NVBoard项目的说明, 然后仿照该示例下的C++文件和Makefile, 修改你的C++文件,
> 为双控开关的输入输出分配引脚, 并修改`npc/Makefile`, 使其连接到NVBoard上的开关和LED灯.

> #### comment::NVBoard的故事
> NVBoard虽然是南京大学的教学项目, 但它却与参加"一生一芯"的各位有着一种特殊的联系:
> 在第三期"一生一芯"的流片名单当中有两位特殊的同学, 他们报名的时候还只是大一,
> 而其中一位同学sjr就是NVBoard的第一作者.
>
> 事实上, 也正是sjr同学在参加"一生一芯"时锻炼出的独立解决问题的能力和自信,
> 帮助他成功开发NVBoard项目.
> 如今NVBoard项目又反过来帮助"一生一芯"改进学习效果,
> NVBoard承载的除了虚拟FPGA板卡的功能之外, 还有"一生一芯"秉承的独立解决问题的理念.
>
> 这些离你其实并不遥远, 当你愿意自主学习而不再等着别人给你答案的时候, 你的将来来也会充满无限可能. -->
> #### hint::Not sure how NVBoard works?
>Try starting with the `make` command to see how everything happens.
With the knowledge you've gained from previous studies, you already have a sufficient background to understand how NVBoard operates:
This includes the use of Makefiles, and the basic usage of classes in C and C++.
Now, try reading the code (Makefiles are also code) to see how the Verilog top-level ports, constraint files, and NVBoard are connected.

> #### todo::Implement the two-way switch on NVBoard
> Read the instructions of the NVBoard project, then try to mimic the C++ files and Makefile in the example to modify your C++ file,
assign pins to the input and output of the two-way switch, and modify `npc/Makefile` to connect it to the switches and LED lights on NVBoard.

> #### comment::The story of NVBoard
> Although NVBoard is a teaching project of Nanjing University, it has a special connection with all those participating in "One Student One Chip":
Among the list of students who fabricated chips in the third phase of "One Student One Chip", there were two special ones. They were only freshmen when they signed up. And one of them, sjr, is the first author of NVBoard.
In fact, it was the ability to solve problems independently and the confidence that sjr developed while participating in "One Student One Chip" that helped him successfully develop the NVBoard project.
Now, the NVBoard project in turn helps "One Student One Chip" improve the learning effect.
Beyond its function as a virtual FPGA board, NVBoard also carries the concept of independently solving problems that "One Student One Chip" upholds.
All of this is not far from you. When you are willing to learn independently instead of waiting for others to give you answers, your future will also be full of infinite possibilities.


<!-- ### 示例: 流水灯(时序逻辑电路)

回顾上文的流水灯模块, 其输出信号`led`的每一位对应虚拟板卡的一个LED灯.
由于代码中包含需要进行复位的时序逻辑部件, 我们需要对Verilator的仿真代码进行修改: -->
### Example: Running Lights (Sequential Logic Circuit)
Recall the running lights module mentioned earlier. Each bit of its output signal `led` corresponds to an LED light on the virtual board.
Since the code contains sequential logic components that require reset, we need to modify the simulation code of Verilator:
```c
// Below is the pseudocode

void single_cycle() {
  top->clk = 0; top->eval();
  top->clk = 1; top->eval();
}

void reset(int n) {
  top->rst = 1;
  while (n -- > 0) single_cycle();
  top->rst = 0;
}

...
reset(10);  // reset for 10 cycles
while(???) {
  ...
  single_cycle();
  ...
}
```

<!-- > #### todo:: 将流水灯接入NVBoard
> 编写流水灯模块, 然后接入NVBoard并分配引脚.
> 如果你的实现正确, 你将看到灯从右端往左端依次亮起并熄灭.

### 静态代码检查

Verilator还可以作为一个lint工具来对代码进行静态检查.
在命令行中给`verilator`传递`--lint-only`参数,
Verilator将仅开展代码检查工作,
并以警告信息的方式指出可能存在问题的代码, 而不生成C++文件.
特别地, 你还可以添加`-Wall`选项, 来让Verilator开启所有类型的检查,
让它帮助你找到更多的潜在问题.

Verilator手册中的`Errors and Warnings`章节列出了所有警告的说明,
通过阅读它们, 你将了解这些警告是如何产生的, 从而得知应该如何修复它们.
对于代码逻辑相关的警告, 你应该通过修改代码来移除它们;
但对于一些代码风格类型的警告, 如果确定不影响代码逻辑,
可以通过额外的`-Wno-xxx`选项来关闭`xxx`警告, 例如`-Wno-DECLFILENAME`. -->
> #### todo:: Connect the running lights to NVBoard
> Write the running lights module, then connect it to NVBoard and assign pins.
If your implementation is correct, you will see the lights light up and turn off sequentially from the right end to the left end.

### Static Code Checking
Verilator can also function as a lint tool for static code checking.
By passing the `--lint-only` parameter to `verilator` in the command line,
Verilator will only perform code checking,
and point out potentially problematic code in the form of warning messages without generating C++ files.
In particular, you can also add the `-Wall` option to enable all types of checks in Verilator,
allowing it to help you find more potential issues.
The `Errors and Warnings` chapter in the Verilator manual lists explanations for all warnings.
By reading them, you will understand how these warnings are generated and thus know how to fix them.
For warnings related to code logic, you should remove them by modifying the code;
but for some warnings related to code style, if you are sure they do not affect the code logic,
you can turn off the `xxx` warning with an additional `-Wno-xxx` option, such as `-Wno-DECLFILENAME`.

<!-- > #### todo::通过Verilator进行静态代码检查
> 尝试使用Verilator检查你的代码, 并尽最大可能修复所有警告.
>
> 我们建议你将来总是开启Verilator的静态代码检查功能.
> 一方面, 这有助于你养成良好的编码习惯, 从而编写出更高质量的代码.
> 另一方面, 尽早发现代码中潜在问题, 也有利于节省不必要的调试工作:
> 随着代码规模的增加, 将来你很可能因为某个信号的位宽错误而调试好几天,
> 而Verilator的警告可以让你马上注意到这个问题, 从而轻松地排除相应的错误. -->
> #### todo::Perform Static Code Checking with Verilator
> Try using Verilator to check your code and fix all warnings as much as possible.
We recommend that you always enable Verilator's static code checking function in the future.
On one hand, this helps you develop good coding habits, thereby writing higher-quality code.
On the other hand, finding potential problems in the code as early as possible is also beneficial for saving unnecessary debugging work:
As the code scale increases, you may well spend several days debugging due to a bit-width error of a certain signal in the future,
but Verilator's warnings can make you notice this problem immediately, thus easily eliminating the corresponding error.

<!-- > #### info::Verilator进阶学习
> [请点击这里](https://www.itsembedded.com/) -->
> #### info::Advanced Study in Verilator
> [please click here](https://www.itsembedded.com/)

<!-- ## Verilog的仿真行为和编码风格

和C语言标准类似, Verilog语言在仿真过程中的语义是由[Verilog标准手册][verilog manual]定义的.
手册的第11章揭示了Verilog语言的本质.
这一章并不长, 只有5页, 但其中包含着巨大的信息量(yzh觉得这部分非常重要, 以至于应该提前放到手册的第3章).
不过, 这些本质在传统的教材和大部分Verilog资料中都没被提及,
以至于绝大多数Verilog的开发者, 甚至是Verilog经验丰富的从业者, 都不知道这部分语义的存在,
从而无法精确理解Verilog在仿真和综合这两种使用场景下的差异. -->
## The Simulation Behavior and Coding Style of Verilog

Similar to the C language standard, the semantics of the Verilog language during simulation are defined by the [Verilog Standard Manual][verilog manual].
Chapter 11 of the manual reveals the essence of the Verilog language.
This chapter is not lengthy, merely 5 pages, yet it contains a wealth of information (yzh believes this part is so crucial that it should be moved earlier to Chapter 3 of the manual).
However, these essential aspects are not covered in traditional textbooks and most Verilog materials.
As a consequence, the vast majority of Verilog developers, even those with extensive experience in Verilog, are unaware of the existence of these semantics.
Therefore, they are unable to accurately comprehend the differences between Verilog in the two application scenarios of simulation and synthesis.

[verilog manual]: http://staff.ustc.edu.cn/~songch/download/IEEE.1364-2005.pdf

<!-- > #### caution::我会写Verilog不就行了吗? 为什么要知道这些?
> 事实上, 很多Verilog开发者也确实不知道Verilog的本质,
> 但他们也能通过遵循一定的Verilog编码建议, 来设计出行为大概率符合预期的电路.
> 不过, 他们并不知道这些编码建议背后的本质, 也无法判断一条编码建议是否正确,
> 在仿真时遇到不符合预期的情况, 也没有能力去分析问题的原因,
> 只能抓瞎随便改改, 万一改不对, 心里可能还抱怨是仿真器有bug...
>
> 作为一个小小的测试, 下面有若干条Verilog的编码建议或描述,
> 但其中有一些是不正确的, 请尝试找出它们:
> 1. 使用`#0`可以将赋值操作强制延迟到当前仿真时刻的末尾.
> 1. 在同一个`begin`-`end`语句块中对同一个变量进行多次非阻塞赋值, 结果是未定义的.
> 1. 用`always`块描述组合逻辑元件时, 不能使用非阻塞赋值.
> 1. 不能在多个`always`块中对同一个变量进行赋值.
> 1. 不建议使用`$display`系统任务, 因为有时候它无法正确输出变量的值.
> 1. `$display`无法输出非阻塞赋值语句的结果.
>
> 如果你打算在后续开发中使用Verilog语言, 而又无法判断上述描述是否正确,
> 我们强烈建议你认真理解这一部分的内容. -->

> #### caution::I can write Verilog, isn't that enough? Why do I need to know these things?
> In fact, many Verilog developers really don't understand the essence of Verilog,
but they can still design circuits whose behavior is mostly as expected by following certain Verilog coding guidelines.
However, they don't know the underlying principles behind these coding guidelines, nor can they judge whether a coding guideline is correct.
When encountering unexpected situations during simulation, they lack the ability to analyze the root causes of problems.
They can only make random modifications blindly, and if they can't get it right, they might even complain that there's a bug in the simulator...
As a small test, here are several Verilog coding suggestions or descriptions,
but some of them are incorrect. Please try to identify them:
> 1. Using `#0` can force an assignment to be delayed until the end of the current simulation time step.
> 1. In the same `begin`-`end` block, performing multiple non-blocking assignments to the same variable results in undefined behavior.
> 1. When describing combinational logic elements with `always` blocks, non-blocking assignments must not be used.
> 1. A variable must not be assigned in multiple `always` blocks.
> 1. It's not recommended to use the `$display` system task because sometimes it can't correctly output variable values.
> 1. `$display` cannot output the results of non-blocking assignment statements.
>
> If you plan to use Verilog in future development and cannot judge the correctness of the above statements,
we strongly recommend that you carefully understand this part of the content.

<!-- ### Verilog代码的执行

我们知道, C语言的执行是指通过符合标准规范的某种求值过程的顺序来修改对象的状态.
那么在Verilog中, "执行"的含义又是什么呢?
为了得到一个清晰的回答, 我们需要查阅Verilog标准手册.
手册的第11.1节定义了什么叫"执行Verilog代码": -->
### Execution of Verilog Code
We know that the execution of C language refers to modifying the state of objects through a sequence of evaluation processes that conform to standard specifications.
Then, in Verilog, what is the meaning of "execution"?
To get a clear answer, we need to refer to the Verilog standard manual.
Section 11.1 of the manual defines what "executing Verilog code" means:

```
The elements that make up the Verilog HDL can be used to describe the behavior, at
varying levels of abstraction, of electronic hardware. An HDL has to be a parallel
programming language. The execution of certain language constructs is defined by
parallel execution of blocks or processes. It is important to understand what
execution order is guaranteed to the user and what execution order is indeterminate.

Although the Verilog HDL is used for more than simulation, the semantics of the
language are defined for simulation, and everything else is abstracted from this
base definition.
```

<!-- 也即, Verilog语言是用来从各个抽象层次来描述硬件的行为.
HDL是一门并行编程语言, 部分语言成分的执行被定义为代码块或过程的并行执行.
理解什么样的执行顺序是由标准手册保证的, 什么样的执行顺序是不确定的,
对Verilog的用户来说是至关重要的.
尽管Verilog的使用场景并不仅限于仿真, Verilog的语义是为了仿真而定义的,
其他场景的语义都是基于这一基础定义抽象得到的. -->
That is to say, the Verilog language is used to describe hardware behavior at various abstraction levels.
HDL is a parallel programming language, and the execution of some language components is defined as the parallel execution of code blocks or processes.
It is crucial for Verilog users to understand which execution sequences are guaranteed by the standard manual and which are uncertain.
Although the application scenarios of Verilog are not limited to simulation, the semantics of Verilog are defined for simulation purposes,
and the semantics for other scenarios are abstracted based on this fundamental definition.

<!-- > #### caution:: 有没有感到对Verilog的认知被颠覆了?
> Verilog的本质竟然是一门并行编程语言!
> 而且Verilog的语言标准是为了仿真而定义的, 而不是RTL设计!
> 更进一步地, Verilog的语义在一些场景下是存在不确定性的!
> 这和C语言的未指定行为或未定义行为有一些相似之处:
> 理解什么样的编码风格会引入不确定性,
> 然后在使用Verilog的过程中避免这些编码风格,
> 从而保证Verilog的行为是确定的.
>
> 这意味着, 有一些Verilog代码的语义可能不符合你的直觉,
> 或者是仿真行为和综合行为存在差异.
> 如果你以前使用过Verilog, 并且有类似"仿真行为通过但FPGA上运行不正确"的经历,
> 在排除FPGA相关的细节问题后, 如果你仍然不理解其中的原因,
> 很大概率是因为你没有理解Verilog语言的上述本质.
> 现在是时候进一步深入理解它了! -->
> #### caution:: Have you felt that your understanding of Verilog has been subverted?
> The essence of Verilog is actually a parallel programming language!
Moreover, the language standard of Verilog is defined for simulation, not for RTL design!
Furthermore, the semantics of Verilog are uncertain in some scenarios!
This is somewhat similar to the unspecified or undefined behaviors in C language:
Understand what kind of coding styles will introduce uncertainty,
and then avoid these coding styles when using Verilog,
thereby ensuring that the behavior of Verilog is deterministic.
>
> This means that the semantics of some Verilog code may not conform to your intuition,
or there may be differences between simulation behavior and synthesis behavior.
If you have used Verilog before and had experiences like "simulation passed but didn't work correctly on FPGA",
after ruling out FPGA-related detailed issues, if you still don't understand the reasons,
it's very likely because you didn't understand the above essence of the Verilog language.
Now it's time to further deepen your understanding of it!


<!-- ### 基于事件的仿真

Verilog标准手册的第11.2节介绍了仿真的过程: -->
### Event-Based Simulation
Section 11.2 of the Verilog standard manual describes the simulation process:


```
The Verilog HDL is defined in terms of a discrete event execution model.
```

<!-- Verilog语言的定义就是基于离散事件的执行模型.
我们挑选一些关键的内容继续说明: -->
The definition of the Verilog language is based on a discrete event execution model.
We have selected some key points to elaborate further:

```
Processes are objects that can be evaluated, that may have state, and that can
respond to changes on their inputs to produce outputs. Processes include primitives,
modules, initial and always procedural blocks, continuous assignments, asynchronous
tasks, and procedural assignment statements.
```

<!-- 在Verilog中, "过程"是一些可以被求值的对象, 它们拥有自己的状态,
当输入产生变化时, 它们可以响应这些变化, 并产生输出.
过程包括原语, 模块, `initial`和`always`过程块, 连续赋值, 异步任务和过程赋值语句. -->
In Verilog, "processes" are objects that can be evaluated. They have their own states, can respond to changes when inputs vary, and produce outputs. Processes include primitives, modules, `initial` and `always` procedural blocks, continuous assignments, asynchronous tasks, and procedural assignment statements.

```
Every change in value of a net or variable in the circuit being simulated, as well
as the named event, is considered an update event.

Processes are sensitive to update events. When an update event is executed, all the
processes that are sensitive to that event are evaluated in an arbitrary order. The
evaluation of a process is also an event, known as an evaluation event.
```

<!-- 在被仿真电路中, 线网或变量的值的变化, 以及命名事件, 都被视为一个"更新事件".
过程是对更新事件敏感的. 执行一个更新事件后,
对该事件敏感的所有过程将会被求值, 求值顺序是任意的.
一个过程的求值也是一个事件, 称为"求值事件". -->
In a circuit being simulated, changes in the values of nets or variables, as well as named events, are all regarded as "update events".
Processes are sensitive to update events. After an update event is executed, all processes sensitive to that event will be evaluated, and the order of evaluation is arbitrary.
The evaluation of a process is also an event, referred to as an "evaluation event".

```
Events can occur at different times. In order to keep track of the events and to
make sure they are processed in the correct order, the events are kept on an event
queue, ordered by simulation time. Putting an event on the queue is called
scheduling an event.
```

<!-- 不同的仿真时刻都会发生事件. 为了保证按正确顺序处理事件,
需要将它们按仿真时刻的顺序存储在一个事件队列中.
将一个事件放入队列中称为"事件的调度".

可以看到, Verilog语言成分的语义都和事件有关联.
仿真的过程就是按某种正确的顺序处理这些事件的过程.
在处理事件的过程中, 电路中对象的状态会发生改变,
我们期望这种改变符合电路的预期行为, 从而实现对电路行为的仿真. -->
Events occur at different simulation times. To ensure that events are processed in the correct order, they need to be stored in an event queue sorted by simulation time. Placing an event into the queue is called "scheduling of the event".
It can be seen that the semantics of Verilog language components are all associated with events. The simulation process is the process of handling these events in a certain correct order. During the processing of events, the state of objects in the circuit will change, and we expect such changes to conform to the expected behavior of the circuit, thereby realizing the simulation of the circuit's behavior.

<!-- ### 层次化事件队列

根据Verilog标准手册, 事件队列在逻辑上包含以下5个区域, 分别用于处理对应种类的事件:
1. 激活事件(active event)区域, 记为$R_1$, 存放发生在当前仿真时刻, 且能被处理的事件.
1. 未激活事件(inactive event)区域, 记为$R_2$,
   存放发生在当前仿真时刻, 但不能立即处理的事件,
   需要在$R_1$为空时, 才能处理这类事件.
1. 非阻塞赋值更新事件(nonblocking assign update event)区域, 记为$R_3$,
   存放在之前的仿真时刻已经完成求值, 但需要在当前仿真时刻结束时才能进行赋值的事件,
   需要在$R_1$和$R_2$均为空时, 才能处理这类事件.
1. 监控事件(monitor event)区域, 记为$R_4$, 存放监控操作相关的事件,
   需要在$R_1$, $R_2$和$R_3$均为空时, 才能处理这类事件.
1. 未来事件(future event)区域, 记为$R_5$, 存放在未来仿真时刻才处理的事件.

一个事件会按其类别添加到不同区域, 并按照一定的规则转移到$R_1$,
被处理后从事件队列中移除. 一些事件生成的规则如下:
* 显式零延迟(`#0`)可以使对应的过程挂起, 将产生一个$R_2$事件.
* 非阻塞赋值将产生一个$R_3$事件.
* 系统任务`$monitor`和`strobe`会在每个仿真时刻都将产生一个$R_4$事件.
* PLI过程的求值将产生一个$R_2$事件.

根据上述不同事件处理顺序, Verilog标准手册提供了事件处理引擎的一个参考实现,
它是Verilog仿真器的核心循环: -->
### Hierarchical Event Queue
According to the Verilog standard manual, the event queue logically contains the following 5 regions, each used to handle corresponding types of events:
1. Active event region, denoted as $R_1$, which stores events that occur at the current simulation time and can be processed.
1. Inactive event region, denoted as $R_2$,
which stores events that occur at the current simulation time but cannot be processed immediately.
These events can only be processed when 
$R_1$ is empty.
1. Nonblocking assign update event region, denoted as $R_3$, which stores events that have completed evaluation at previous simulation times but need to be assigned at the end of the current simulation time.
These events can only be processed when both $R_1$ and $R_2$ are empty.
1. Monitor event region, denoted as $R_4$, which stores events related to monitoring operations.
These events can only be processed when 
$R_1$, $R_2$, and $R_3$ are all empty.
1. Future event region, denoted as $R_5$, which stores events to be processed at future simulation times.

An event is added to different regions according to its type and transferred to $R_1$ according to certain rules.
Once processed, it is removed from the event queue. Some rules for event generation are as follows:
* Explicit zero delay (`#0`) can suspend the corresponding process and generate an $R_2$ event.
* Nonblocking assignments generate an $R_3$ event.
* The system tasks `$monitor` and `strobe` generate an $R_4$ event at each simulation time.
* Evaluation of PLI processes generates an $R_2$ event.

Based on the above processing order of different events, the Verilog standard manual provides a reference implementation of the event processing engine,
which is the core loop of the Verilog simulator:
```c
while (there are events) {
  if (no active events) {
    if (there are inactive events) {
      activate all inactive events;
    } else if (there are nonblocking assign update events) {
      activate all nonblocking assign update events;
    } else if (there are monitor events) {
      activate all monitor events;
    } else {
      advance T to the next event time;
      activate all inactive events for time T;
    }
  }
  E = any active event;
  if (E is an update event) {
    update the modified object;
    add evaluation events for sensitive processes to event queue;
  } else { /* shall be an evaluation event */
    evaluate the process;
    add update events to the event queue;
  }
}
```
<!-- 事件处理引擎将不断重复如下操作:
* 如果$R_1$中存在事件, 则取出一个事件`E`
  * 如果`E`是一个更新事件, 则
    * 更新相应的对象
    * 并将对该事件敏感的过程的求值作为求值事件添加到事件队列中
  * 否则, `E`是一个求值事件, 则
    * 对过程进行求值
    * 并将赋值行为作为更新事件添加到事件队列中
* 否则(即$R_1$为空)
  * 如果$R_2$不为空, 则将$R_2$中的所有事件转移到$R_1$
  * 否则, 如果$R_3$不为空, 则将$R_3$中的所有事件转移到$R_1$
  * 否则, 如果$R_4$不为空, 则将$R_4$中的所有事件转移到$R_1$
  * 否则
    * 将仿真时刻前进一个单位
    * 并将$R_5$中所有当前仿真时刻的事件按类型转移到$R_1$或$R_3$ -->
The event processing engine will repeatedly perform the following operations:
* If there are events in $R_1$, take out an event `E`:
  * If E is an update event:
    * Update the corresponding object.
    * Add the evaluation of the processes sensitive to this event to the event queue as evaluation events.
  * Otherwise, if `E` is an evaluation event:
    * Evaluate the process.
    * Add the assignment behavior to the event queue as an update event.
* If $R_1$ is empty:
  * If $R_2$ is not empty, transfer all events in $R_2$ to $R_1$.
  * Else, if $R_3$ is not empty, transfer all events in $R_3$ to $R_1$.
  * Else, if $R_4$ is not empty, transfer all events in $R_4$ to $R_1$.
  * Else:
    * Advance the simulation time by one unit.
    * Transfer all events in $R_5$ that belong to the current simulation time to $R_1$ or $R_3$ according to their types.

<!-- > #### caution::Verilog代码 != C代码
> 对数字电路课程的老师来说, 最头疼的事情, 莫过于学生学习Verilog的时候,
> 很容易按照C语言的程序设计思维来编写Verilog代码.
> 尽管老师已经多次强调"不能把Verilog当作C语言来写",
> 大部分同学仍然无法深刻认识这句话的含义:
> 如果不能当作C语言来写, 那Verilog究竟是什么?
>
> 我们之所以在这里介绍Verilog标准手册中的内容,
> 就是希望给大家呈现这个问题的答案.
> 上述的事件处理循环已经很直接地呈现出了Verilog代码和C代码的区别:
> 以`i = i + 1`为例, 在C程序中, 在编译器的作用下,
> 这行代码最终被编译成一条类似`addi a0, a0, 1`的指令, 最后在处理器上直接执行;
> 而在Verilog中, 这行代码会被转化成一个求值事件和一个更新事件,
> 在事件处理引擎的处理下完成加法操作和赋值操作, 并产生对其敏感的新事件.
>
> 事实上, 你写的Verilog代码, 最终都会按照标准手册的约定转变成一个个事件.
> 仿真器按照符合标准手册约定的某种顺序来处理这些事件,
> 通过这些事件的行为呈现出硬件电路的整体行为, 从而实现硬件电路的建模. -->
> #### caution::Verilog Code != C Code
> For teachers of digital circuit courses, one of the most frustrating things is that when students learn Verilog, they easily write Verilog code using C language programming thinking.
Even though teachers have repeatedly emphasized that "you can't treat Verilog as C language", most students still can't deeply understand the meaning of this sentence: if it can't be written like C language, then what exactly is Verilog?
>
> The reason why we introduce the content of the Verilog standard manual here is to present the answer to this question.
The above event processing loop has directly shown the difference between Verilog code and C code:
Take `i = i + 1` as an example. In a C program, under the action of the compiler, this line of code is finally compiled into an instruction similar to `addi a0, a0, 1`, which is directly executed on the processor;
In Verilog, however, this line of code will be converted into an evaluation event and an update event. Under the processing of the event processing engine, the addition operation and assignment operation are completed, and new events sensitive to it are generated.
>
> In fact, the Verilog code you write will eventually be transformed into events in accordance with the conventions of the standard manual.
The simulator processes these events in a certain order that conforms to the conventions of the standard manual, and presents the overall behavior of the hardware circuit through the behavior of these events, thereby realizing the modeling of the hardware circuit.

<!-- ### 赋值操作的事件调度

根据Verilog标准手册的第11.6节, 赋值操作会转换成行为等价的过程,
从而产生相应的事件, 来被仿真器所处理.
我们选取一些常见的赋值操作进行说明,
为了简单起见, 我们先考虑没有指定延迟信息(`#`)的情况.
* 连续赋值(即`assign`语句) -
  对应一个对表达式的源操作数都敏感的过程.
  当表达式的值变化时, 将产生一个更新事件添加到$R_1$.
  特别地, 连续赋值过程会产生一个`0`时刻的求值事件, 用来实现常量的传播.
* 过程中的阻塞赋值 -
  先使用对象的当前值计算赋值表达式右侧的值,
  然后马上计算赋值表达式左侧的赋值目标对象,
  对其进行更新, 并产生由此更新导致的事件.
  执行过程可以继续按顺序执行下一条语句, 也可以处理其他激活事件.
* 过程中的非阻塞赋值 -
  先使用对象的当前值计算赋值表达式右侧的值和左侧的赋值目标对象,
  产生一个当前仿真时刻的$R_3$事件. -->
### Event Scheduling for Assignment Operations

According to Section 11.6 of the Verilog standard manual, assignment operations are converted into behaviorally equivalent processes, which generate corresponding events to be processed by the simulator.We have selected some common assignment operations for explanation. For simplicity, we first consider cases where no delay information (`#`) is specified.
* Continuous assignment (i.e., `assign statement`) -
Corresponds to a process sensitive to all source operands of the expression.
When the value of the expression changes, an update event is generated and added to $R_1$.
In particular, the continuous assignment process generates a `0`-time evaluation event to implement constant propagation.
* Blocking assignment within a process -
First, calculate the value of the right-hand side of the assignment expression using the current value of the object.
Then immediately calculate the target object on the left-hand side of the assignment expression,
update it, and generate events resulting from this update.
The execution process can continue to execute the next statement in sequence or process other active events.
* Non-blocking assignment within a process -
First, calculate the value of the right-hand side of the assignment expression and the target object on the left-hand side using the current values of the objects.
A $R_3$ event for the current simulation time is generated.

<!-- > #### caution::重新认识阻塞赋值和非阻塞赋值
> 对数字电路课程的老师来说, 第二头疼的事情,
> 就是学生很难理解阻塞赋值和非阻塞赋值的区别.
> C语言的赋值只有一种, 但Verilog中的赋值却有好几种,
> 而要深入理解不同赋值方式的区别, 还是要回到Verilog的本质, 也就是事件模型.
>
> 和大家的直觉不同, 在Verilog的事件模型中,
> 赋值表达式的具体操作需要从两个子操作来考虑:
> 首先是求值操作, 用于完成赋值表达式右侧的求值过程;
> 然后才是更新操作, 用于将求值结果写入到赋值表达式左侧所指示的对象中.
>
> 根据上文提到的事件调度行为, 阻塞赋值和非阻塞赋值最大的不同,
> 就是两者对更新操作的处理不同.
> 具体地, 阻塞赋值的更新操作是紧跟在求值操作后一同进行的, 没有产生新的更新事件;
> 而对非阻塞赋值来说, 求值操作和更新操作是分开的,
> 完成求值操作后, 会生成一个属于$R_3$的更新事件,
> 这个更新事件需要等到$R_1$和$R_2$均为空时才能处理.
> 正是这一不同之处, 使得两者开展具体赋值操作的时机有所不同,
> 进一步使得能看到赋值结果的事件集合并不相同,
> 从而影响这些事件的行为, 最终影响电路的整体行为. -->
> #### caution:: A New Understanding of Blocking and Non-blocking Assignments
> For teachers of digital circuit courses, the second most frustrating thing is that students struggle to understand the difference between blocking and non-blocking assignments.
C language has only one type of assignment, but Verilog has several types of assignments.
To deeply understand the differences between different assignment methods, we must return to the essence of Verilog, which is the event model.
>
> Contrary to intuition, in Verilog's event model,
the specific operation of an assignment expression needs to be considered in terms of two sub-operations:
First is the evaluation operation, which completes the evaluation process of the right-hand side of the assignment expression;
Then comes the update operation, which writes the evaluation result to the object indicated by the left-hand side of the assignment expression.
>
> According to the event scheduling behavior mentioned above, the biggest difference between blocking and non-blocking assignments
lies in how they handle the update operation.
Specifically, the update operation of a blocking assignment is performed immediately after the evaluation operation without generating a new update event;
For non-blocking assignments, however, the evaluation and update operations are separate.
After completing the evaluation operation, an update event belonging to $R_3$ is generated.
This update event can only be processed when both $R_1$ and $R_2$ are empty.
It is this difference that causes the timing of specific assignment operations to differ between the two,
further resulting in different sets of events that can see the assignment results,
thereby affecting the behavior of these events and ultimately influencing the overall behavior of the circuit.

<!-- > #### todo::用事件模型分析Verilog代码的行为
> 考虑以下代码, 假设在`t`时刻有`a = 1`, `b = 2`, `c = 3`, `d = 4`, `e = 5`.
> 尝试利用事件模型分析在`t+1`时刻, 变量的值各为多少. -->
#### todo::Using Event Model to Analyze the Behavior of Verilog Code
> Consider the code `a = 1`, `b = 2`, `c = 3`, `d = 4`, `e = 5` at `t`-time.
> Try to analyze the value of all the variables at time `t+1`.
> ```verilog
> always @(posedge clk) begin
>   b  = a;
>   c <= b;
>   d  = c;
>   e <= d;
>   a  = e;
> end
> ```

<!-- * 端口连接 -
  对于输入端口的连接`.a(expr)`, 将视为连续赋值语句`assign a = expr;`来处理;
  对于输出端口的连接`.b(net)`, 将视为连续赋值语句`assign net = b;`来处理.
* 函数和任务 -
  调用时参数按值传递. 返回时, "用返回值替换调用处"的行为按阻塞赋值来处理. -->
* Port connections -
For the input port connection `.a(expr)`, it is treated as the continuous assignment statement `assign a = expr;`.
For the output port connection `.b(net)`, it is treated as the continuous assignment statement `assign net = b;`.
* Functions and tasks -
Parameters are passed by value when called. When returning, the behavior of "replacing the call site with the return value" is handled as a blocking assignment.

<!-- Verilog手册中还定义了如何将更多情况转换成事件来处理,
包括指定延迟信息, 使用过程连续赋值语句, 处理晶体管层次行为等,
需要了解时可以查阅手册中的相关内容. -->
The Verilog manual also defines how to convert more scenarios into events for processing, including specifying delay information, using procedural continuous assignment statements, handling transistor - level behaviors, and so on. When you need to understand these, you can refer to the relevant content in the manual.

<!-- ### 事件处理顺序

事实上, 事件处理的顺序并非100%确定的.
根据Verilog标准手册的定义, 不确定性主要有两个来源:
* 事件队列中有多个激活事件时, 处理顺序是任意的.
* 在行为模块中, 不带时间控制(即`#`表达式和`@`表达式)的语句不必作为一整个事件来处理.
  在对行为模块中的一条语句进行求值时, 仿真器可以随时挂起这条语句的执行,
  并将剩下的执行操作作为事件队列中的一个激活事件.
  这样可以允许不同的过程交织执行, 但交织的顺序是不确定的, 而且不受用户的控制.

为什么Verilog需要引入这些不确定性呢?
要回答这个问题, 我们需要回顾硬件电路的工作方式.
事实上, 硬件电路的行为本身就具有并行性, 多个组件之间天然就是并行工作的.
* 从电路行为模型和真实电路的一致性来看, 并不存在规定这些组件之间工作先后顺序的理由.
  如果强行规定这些先后顺序, 就会导致建模结果无法全面地反映真实电路的工作情况.
  特别地, 如果真实电路存在问题, 但无法通过建模反映出来并及时修复, 建模就失去意义.
* 从仿真器的软件本质来看, 仿真器只能以串行的处理不同的事件.
  而Verilog标准定义的上述不确定性, 其实是对事件处理顺序的一种"放松":
  如果两个事件之间不存在依赖关系, 也不必要求它们按一定的先后顺序来处理.
  进一步地, 仿真器甚至可以使用一些并行优化技术来处理这些没有依赖关系的事件,
  从而更好地模拟电路组件之间的并行性. -->
### Event Processing Order
In fact, the order of event processing is not 100% deterministic.
According to the definition in the Verilog standard manual, there are two main sources of uncertainty:
* When there are multiple active events in the event queue, the processing order is arbitrary.
* In behavioral modules, statements without time controls (i.e., `#` expressions and `@` expressions) do not have to be processed as a single entire event.
When evaluating a statement in a behavioral module, the simulator can suspend the execution of this statement at any time,
and treat the remaining execution operations as an active event in the event queue.
This allows different processes to interleave their execution, but the order of interleaving is uncertain and not under the user's control.
Why does Verilog need to introduce such uncertainties?
To answer this question, we need to review how hardware circuits work.
In fact, the behavior of hardware circuits itself is parallel, and multiple components naturally work in parallel.
* From the perspective of consistency between the circuit behavior model and the real circuit, there is no reason to specify the order in which these components work.
If we forcibly specify these sequences, it will cause the modeling results to fail to fully reflect the working conditions of the real circuit.
In particular, if there is a problem in the real circuit but it cannot be reflected through modeling and repaired in time, the modeling will lose its meaning.
* From the perspective of the software nature of the simulator, the simulator can only process different events serially.
The above-mentioned uncertainties defined by the Verilog standard are actually a kind of "relaxation" of the event processing order:
If there is no dependency between two events, there is no need to require them to be processed in a certain order.
Furthermore, the simulator can even use some parallel optimization techniques to handle these events without dependencies,
thereby better simulating the parallelism between circuit components.

<!-- 为了全面地理解Verilog代码的行为, 我们还要考虑事件处理顺序的确定性.
为了方便表示, 我们引入一种顺序关系, 标记为$\to$,
$A \to B$表示事件$A$先于事件$B$被处理.
上文的事件处理引擎其实隐含了一些顺序要求:
* `顺序规则1` - 如果在处理$A$的过程中生成了$B$, 则$A \to B$.
  这是因为, 要处理$B$, 必须先完成$A$的处理.
* `顺序规则2` - 如果在仿真过程中的某一时刻, 有$A\in R_i$,
  $B\in R_j$, 且$i < j$, 则$A \to B$.
  这是因为, 事件处理引擎会在$R_i$中的事件都处理完后, 才会处理$R_j$中的事件.

除了这些隐含的顺序, Verilog标准手册还显式定义了如下两条顺序规则:
* `顺序规则3` - `begin`-`end`语句块中的语句需要按语句顺序执行,
  也即, 对于同一个`begin`-`end`语句块中的两个语句$S_i$和$S_j$,
  若$i < j$, 则$S_i$比$S_j$先执行.
* `顺序规则4` -  非阻塞赋值操作需要按语句的执行顺序来进行.
  也即, 若$A, B \in R_3$, 相应的赋值表达式求值操作分别为$A^\prime$和$B^\prime$,
  且有$A^\prime \to B^\prime$, 则$A \to B$. -->
To fully understand the behavior of Verilog code, we also need to consider the determinism of event processing order.
For convenience of expression, we introduce a sequential relationship, denoted as $\to$, where $A \to B$ means that event A is processed before event B.
The event processing engine mentioned above actually implies some order requirements:
* `Order Rule 1` - If $B$ is generated during the processing of $A$, then $A \to B$.
This is because processing $B$ must be preceded by the completion of processing $A$.
* `Order Rule 2` - If at a certain moment during the simulation,$A\in R_i$, $B\in R_j$, and $i < j$, then $A \to B$.
This is because the event processing engine will process all events in $R_i$ before processing events in $R_j$.

In addition to these implicit orders, the Verilog standard manual explicitly defines the following two order rules:
* `Order Rule 3` - Statements within a `begin`-`end` block need to be executed in the order of the statements.
That is, for two statements $S_i$ and $S_j$ in the same `begin`-`end` block, if $i < j$, then $S_i$ is executed before $S_j$.
* `Order Rule 4` - Non-blocking assignment operations need to be performed in the order of statement execution.
That is, if $A, B \in R_3$, and the corresponding evaluation operations of the assignment expressions are $A^\prime$ and $B^\prime$ respectively, with $A^\prime \to B^\prime$, then $A \to B$.

<!-- 例如, 在Verilog标准手册中有如下例子: -->
The following example is in the Verilog standard manual:
```verilog
initial begin
  a <= 0; // (1)
  a <= 1; // (2)
end
```
<!-- 我们用$\mathrm{eval(expr)}$表示"表达式$\mathrm{expr}$的求值事件",
用$\mathrm{update(obj)}$表示"对象$\mathrm{obj}$的更新事件".
因此, 上例中标注`(1)`的语句可分解为$E_1: \mathrm{eval(0)}$和$E_2: \mathrm{update(a)}$两个事件.
同理, 标注`(2)`的语句可分解为$E_3: \mathrm{eval(1)}$和$E_4: \mathrm{update(a)}$两个事件.
应用上文的顺序规则, 可以得到如下结论:
* 考虑`顺序规则1`, 应有$E_1 \to E_2$, $E_3 \to E_4$
* 考虑`顺序规则2`, 应有$E_3 \to E_2$, $E_1 \to E_4$
* 考虑`顺序规则3`, 应有$E_1 \to E_3$
* 考虑`顺序规则4`, 应有$E_2 \to E_4$

综合这些结论, 有且仅有$E_1 \to E_3 \to E_2 \to E_4$.
也即, 在这个例子中, 仿真器只能按这种顺序处理事件.
因此, 在仿真过程中, 对象`a`将先被赋`0`, 然后被赋`1`. -->

We use $\mathrm{eval(expr)}$ to represent "the evaluation event of expression $\mathrm{expr}$" and $\mathrm{update(obj)}$ to represent "the update event of object $\mathrm{obj}$".
Therefore, the statement marked `(1)` in the above example can be decomposed into two events: $E_1: \mathrm{eval(0)}$ and $E_2: \mathrm{update(a)}$.
Similarly, the statement marked `(2)` can be decomposed into two events: $E_3: \mathrm{eval(1)}$ and $E_4: \mathrm{update(a)}$.
Applying the order rules mentioned above, we can draw the following conclusions:
* Considering `Order Rule 1`, it should be that $E_1 \to E_2$ and $E_3 \to E_4$.
* Considering `Order Rule 2`, it should be that $E_3 \to E_2$ and $E_1 \to E_4$.
* Considering `Order Rule 3`, it should be that $E_1 \to E_3$.
* Considering `Order Rule 4`, it should be that $E_2 \to E_4$.

Synthesizing these conclusions, there is only one possible order: $E_1 \to E_3 \to E_2 \to E_4$.
That is, in this example, the simulator can only process events in this order.
Therefore, during the simulation, the object `a` will first be assigned `0` and then `1`.

<!-- ### 仿真器和仿真程序

回顾流水灯的例子, 我们来分析其中的事件处理顺序. -->
### Simulators and Simulation Programs

Looking back at the example of the running light, let's analyze the event processing order within it.
```verilog
module light(
  input clk,
  input rst,
  output reg [15:0] led
);
  reg [31:0] count;
  always @(posedge clk) begin
    if (rst) begin led <= 1; count <= 0; end
    else begin
      if (count == 0) led <= {led[14:0], led[15]};
      count <= (count >= 5000000 ? 32'b0 : count + 1);
    end
  end
endmodule
```
<!-- 假设`clk`上升沿到来, 在这个仿真时刻中, 可能会发生以下事件: -->
When a rising edge of `clk` arrives, the following events may occur at this simulation time:
* $E_1: \mathrm{eval(1)}$
* $E_2: \mathrm{update(led)}$
* $E_3: \mathrm{eval(0)}$
* $E_4: \mathrm{update(count)}$
* $E_5: \mathrm{eval(\{led[14:0], led[15]\})}$
* $E_6: \mathrm{update(led)}$
* $E_7: \mathrm{eval(count >= 5000000 ? 32'b0 : count + 1)}$
* $E_8: \mathrm{update(count)}$

<!-- 应用上文的顺序规则, 可以得到如下结论: -->
Applying the above rule, we can get the following conclusion:
<!-- * 当`rst = 1`时, 应有$E_1 \to E_3 \to E_2 \to E_4$
* 当`rst = 0`, `count = 0`时, 应有$E_5 \to E_7 \to E_6 \to E_8$
* 当`rst = 0`, `count != 0`时, 应有$E_7 \to E_8$ -->
* When `rst = 1`, it should be that $E_1 \to E_3 \to E_2 \to E_4$.
* When `rst = 0` and `count = 0`, it should be that $E_5 \to E_7 \to E_6 \to E_8$.
* When `rst = 0` and `count != 0`, it should be that $E_7 \to E_8$.

<!-- 得到上述的事件处理顺序后, 我们可以用C代码直接实现这个顺序,
其中定义的两个宏`EVAL()`和`UPDATE()`,
分别实现了求值事件`eval(expr)`和更新事件`update(obj)`的语义: -->
After obtaining the above event processing order, we can directly implement this order using C code. Here, two macros `EVAL()` and `UPDATE()` are defined, which respectively implement the semantics of the evaluation event `eval(expr)` and the update event `update(obj)`:

```c
#define EVAL(c, name, val) do { \
                             c->CONCAT(name, _next) = (val); \
                             c->CONCAT(name, _update) = 1; \
                           } while (0)
#define UPDATE(c, name)    do { \
                             if (c->CONCAT(name, _update)) { \
                               c->name = c->CONCAT(name, _next); \
                             } \
                           } while (0)

static void cycle(Circuit *c) {
  c->led_update = 0;
  c->count_update = 0;
  if (c->rst) {
    EVAL(c, led, 1);
    EVAL(c, count, 0);
  } else {
    if (c->count == 0) {
      EVAL(c, led, (BITS(c->led, 14, 0) << 1) | BITS(c->led, 15, 15));
    }
    EVAL(c, count, c->count >= 5000000 ? 0 : c->count + 1);
  }
  UPDATE(c, led);
  UPDATE(c, count);
}
```

<!-- 这份C代码虽然实现了流水灯电路仿真的功能, 但其中并没有"事件队列"的概念:
Verilog标准手册中定义的事件, 在这份C代码中并非从一个队列中取出的,
而是按照一定的顺序直接"平铺"在C代码中, 但这种顺序又符合Verilog标准手册的约定.
事实上, Verilog标准手册对事件队列的定义是逻辑上的:
```
The Verilog event queue is logically segmented into five different regions.
```
因此, 仿真程序并非必须显式地通过队列的数据结构来维护事件之间的顺序,
只要事件处理顺序符合Verilog标准手册的约定, 仿真程序的行为就是符合手册规范的.

上面这种将事件按照一定的顺序"平铺"的仿真方式, 称为"周期仿真"(cycle simulation),
这种仿真方式以周期为粒度进行, 在每个仿真周期中对电路中的所有组件进行求值.
在周期方式中, 电路的求值顺序是在仿真过程开始之前决定好的,
属于事件的静态调度(static scheduing).
Verilator采用这一仿真方式.
相对地, 上文提到的Verilog标准手册提供的事件处理引擎参考实现,
则称为"事件仿真"(event simulation), 电路的求值顺序是在仿真过程中决定的,
属于事件的动态调度(dynamic scheduing).
商业仿真器VCS采用这一仿真方式.

> #### todo::理解Verilator生成的仿真程序的行为
> 用Verilator编译流水灯电路, 尝试理解生成的C++代码的行为. -->
Although this piece of C code implements the function of simulating a running light circuit, it does not include the concept of an "event queue":
The events defined in the Verilog standard manual are not fetched from a queue in this C code. Instead, they are directly "flattened" in the C code in a specific order, and this order conforms to the conventions of the Verilog standard manual.
In fact, the definition of the event queue in the Verilog standard manual is logical:
```
The Verilog event queue is logically segmented into five different regions.
```
Therefore, a simulation program does not necessarily need to explicitly maintain the order of events through a queue data structure. As long as the event processing order complies with the conventions of the Verilog standard manual, the behavior of the simulation program is in line with the manual's specifications.

The above simulation method, which "flattens" events in a specific order, is called "cycle simulation". This simulation method operates at the granularity of cycles, evaluating all components in the circuit within each simulation cycle. In the cycle-based approach, the evaluation order of the circuit is determined before the simulation starts, which belongs to the static scheduling of events. Verilator adopts this simulation method.
In contrast, the reference implementation of the event processing engine provided in the Verilog standard manual mentioned earlier is called "event simulation". In this approach, the evaluation order of the circuit is determined during the simulation process, which belongs to the dynamic scheduling of events. The commercial simulator VCS adopts this simulation method.

> #### todo::Understand the behavior of the simulation program generated by Verilator
> Compile the running light circuit with Verilator and try to understand the behavior of the generated C++ code.

<!-- ### 数据竞争

一个有效的真实电路在各个组件并行工作的情况下, 都应该得到一致的输出.
因此, 这也要求电路模型在上述不确定性的情况下,
不管这些事件按何种顺序处理, 都应该得到一致的结果.
相反, 如果存在两种不同的事件处理顺序, 使得仿真结果不一致,
则称为存在数据竞争(data race).
Verilog标准手册将其称为"竞争条件"(race condition), 其含义与数据竞争相同.
通常, 如果仿真过程中存在数据竞争,
这个电路模型所描述的就不是一个有效的真实电路. -->
### Data Races

A valid real-world circuit should produce consistent outputs even when its various components operate in parallel.
Therefore, this also requires that the circuit model, under the aforementioned uncertainties, should yield consistent results regardless of the order in which these events are processed.
Conversely, if there exist two different event processing orders that lead to inconsistent simulation results, this is referred to as a data race.
The Verilog standard manual terms this a "race condition," which has the same meaning as a data race.
In general, if a data race exists during simulation, the circuit model described is not a valid representation of a real-world circuit.

<!-- 考虑如下例子: -->
Consider the following example:
```verilog
always @(posedge clk or negedge rstn) begin
  if (!rstn) a = 1'b0;
  else a = b; // (1)
end

always @(posedge clk or negedge rstn) begin
  if (!rstn) b = 1'b1;
  else b = a; // (2)
end
```
<!-- 代码中存在两个`always`块, 也即存在两个过程.
假设在`t`时刻有`a = 0`, `b = 1`, `rstn = 1`, 且`clk`的上升沿到来.
考虑到阻塞赋值的求值操作和更新操作是一同完成的,
我们用一个新操作$\mathrm{evalAndUpdate(expr)}$来表示它.
因此, 标注`(1)`和`(2)的语句可分解为如下事件: -->
There are two `always` blocks in the code, meaning there are two processes. Assume that at time `t`, `a = 0`, `b = 1`, `rstn = 1`, and a rising edge of `clk` arrives. Considering that the evaluation and update operations of a blocking assignment are completed together, we use a new operation $\mathrm{evalAndUpdate(expr)}$ to represent this combined process. Therefore, the statements marked `(1)` and `(2)` can be decomposed into the following events:
* $E_1: \mathrm{evalAndUpdate(a = b)}$
* $E_2: \mathrm{evalAndUpdate(b = a)}$

<!-- 根据Verilog标准手册的定义, 多个激活事件的处理顺序是任意的, 因此其他顺序规则无法适用.
我们可以列出所有可能的事件处理顺序: -->
According to the definition in the Verilog standard manual, the processing order of multiple active events is arbitrary, so other order rules cannot be applied.
We can list all possible event processing sequences:
<!-- * $E_1 \to E_2$, 结果为`a = 1`, `b = 1`
* $E_2 \to E_1$, 结果为`a = 0`, `b = 0` -->
* $E_1 \to E_2$, resulting in `a = 1`, `b = 1`
* $E_2 \to E_1$, resulting in `a = 0`, `b = 0`

<!-- 可以看到, 上述代码中存在数据竞争,
当仿真器选择不同的事件处理顺序时, 会导致不同的仿真结果.
这有点类似C语言中的未指定行为,
不同仿真结果可能出现在不同的仿真器中,
也可能会出现在同一款仿真器的不同版本中,
还可能会出现在同一款仿真器, 同一个版本的多次运行中,
甚至可能会出现在同一款仿真器, 同一个版本, 单次运行的不同仿真时刻中.
这些情况都符合Verilog标准手册的约定.
可以看到, 如果Verilog代码中存在数据竞争, 仿真结果可能是难以预测的. -->

It can be seen that there is a data race in the above code. When the simulator chooses different event processing orders, it will lead to different simulation results. This is somewhat similar to the unspecified behavior in the C language. Different simulation results may appear in different simulators, different versions of the same simulator, multiple runs of the same version of the same simulator, and even different simulation moments in a single run of the same version of the same simulator. All these situations are in line with the conventions of the Verilog standard manual. It can be seen that if there is a data race in the Verilog code, the simulation results may be unpredictable.

<!-- > #### todo::用事件模型分析Verilog代码的行为(2)
> 将上述代码中的阻塞赋值改成非阻塞赋值, 尝试重新分析可能的事件处理顺序及其结果.
> 修改后的代码还存在数据竞争吗? 为什么? -->
> #### todo::Analyze the behavior of Verilog code using the event model (2)
> Change the blocking assignments in the above code to non-blocking assignments, and try to re-analyze the possible event processing sequences and their results.
Does the modified code still have data races? Why?
> ```verilog
> always @(posedge clk or negedge rstn) begin
>   if (!rstn) a <= 1'b0;
>   else a <= b;
> end
>
> always @(posedge clk or negedge rstn) begin
>   if (!rstn) b <= 1'b1;
>   else b <= a;
> end
> ```

<!-- 考虑如下例子: -->
Consider the following example:
```verilog
always @(posedge clk or negedge rstn) begin
  if (!rstn) a = 1'b0;
  else a = 1;
end

always @(posedge clk) begin
  $display("a = %d", a);
end
```
<!-- 假设在`t`时刻有`a = 0`, `rstn = 1`, 且`clk`的上升沿到来.
根据类似的分析过程, 我们可以得到`t`时刻仿真过程中的2个事件: -->
Assume that at time `t`, `a = 0`, `rstn = 1`, and a rising edge of `clk` arrives.
Through a similar analysis process, we can obtain 2 events during the simulation at time `t`:
* $E_1: \mathrm{evalAndUpdate(a = 1)}$
* $E_2: \mathrm{display(a)}$

<!-- 注意到`$display`系统任务的处理事件$E_2 \in R_1$.
我们可以列出所有可能的事件处理顺序: -->
It should be noted that the processing event of the `$display` system task, $E_2 \in R_1$. We can list all possible event processing sequences:
<!-- * $E_1 \to E_2$, 输出`a = 1`
* $E_2 \to E_1$, 输出`a = 0` -->
* $E_1 \to E_2$, outputs `a = 1`
* $E_2 \to E_1$, outputs `a = 0`

<!-- 可以看到, 上述代码中存在数据竞争, 虽然和电路本身的行为无关,
但当仿真器选择不同的事件处理顺序时, 仍然会导致不同的仿真结果.
这可能会给开发者的调试带来混乱. -->
It can be seen that there is a data race in the above code. Although it has nothing to do with the behavior of the circuit itself, different simulation results may still occur when the simulator chooses different event processing orders. This may cause confusion for developers during debugging.

<!-- > #### todo::用事件模型分析Verilog代码的行为(3)
> 将上述代码中的`$display`改成`$strobe`, 尝试重新分析可能的事件处理顺序及其结果.
> 修改后的代码还存在数据竞争吗? 为什么? -->
> #### todo::Analyze the behavior of Verilog code using the event model (3)
> Change `$display` in the above code to `$strobe`, and try to re-analyze the possible event processing sequences and their results.
Does the modified code still have data races? Why?
> ```verilog
> always @(posedge clk or negedge rstn) begin
>   if (!rstn) a = 1'b0;
>   else a = 1;
> end
>
> always @(posedge clk) begin
>   $strobe("a = %d", a);
> end
> ```

<!-- 事实上, 我们可以从上面的例子中总结出存在数据竞争的充分必要条件.
Verilog代码中存在数据竞争,
当且仅当存在和同一个对象$\mathrm{obj}$相关的两个事件$E_1$和$E_2$, 同时满足:
* $E_1$和$E_2$之间的处理顺序不确定
* 在$E_1$和$E_2$中, 至少一个事件会更新$\mathrm{obj}$ -->

In fact, we can summarize the sufficient and necessary conditions for the existence of data races from the above examples.
A data race exists in Verilog code if and only if there are two events $E_1$ and $E_2$ related to the same object $\mathrm{obj}$, which simultaneously satisfy:
* The processing order between $E_1$ and $E_2$ is uncertain.
* At least one of $E_1$ and 
$E_2$ updates $\mathrm{obj}$.

<!-- ### 良好的Verilog编码风格

要消除数据竞争, 就需要消除满足上述条件的事件.
不过当项目规模变得复杂, 要人工判断代码中是否存在数据竞争, 是很困难的.
为了应对这个挑战, 很多Verilog书籍和相关资料都会推荐一些良好的编码规范,
如果开发者遵循这些编码规范, 就可以消除代码中的绝大部分数据竞争,
从而更有可能设计出行为符合预期的电路.

例如, ["Nonblocking Assignments in Verilog Synthesis, Coding Styles That Kill!"][verilog paper]
这篇文章中提出了如下的Verilog编码建议,
并提到, 采用这些建议可以消除90%以上的数据竞争:
1. 时序电路建模时, 用非阻塞赋值.
2. 锁存器电路建模时, 用非阻塞赋值.
3. 用`always`块建立组合逻辑模型时, 用阻塞赋值.
4. 在同一个`always`块中建立时序和组合逻辑电路时, 用非阻塞赋值.
5. 在同一个`always`块中不要既用非阻塞赋值又用阻塞赋值.
6. 不要在一个以上的`always`块中为同一个变量赋值.
7. 用`$strobe`系统任务来显示用非阻塞赋值的变量值.
8. 在赋值时不要使用`#0`延迟. -->
### Good Verilog Coding Styles

To eliminate data races, it is necessary to remove events that meet the above conditions. However, as the project scale becomes complex, manually judging whether there are data races in the code is very difficult. To address this challenge, many Verilog books and related materials recommend some good coding standards. If developers follow these coding standards, they can eliminate most data races in the code, making it more likely to design circuits with behaviors that meet expectations.

For example, the article ["Nonblocking Assignments in Verilog Synthesis, Coding Styles That Kill!"][verilog paper] puts forward the following Verilog coding suggestions, and mentions that adopting these suggestions can eliminate more than 90% of data races:
1. Use non-blocking assignments when modeling sequential circuits.
2. Use non-blocking assignments when modeling latch circuits.
3. Use blocking assignments when building combinational logic models with `always` blocks.
4. Use non-blocking assignments when building both sequential and combinational logic circuits in the same `always` block.
5. Do not use both non-blocking and blocking assignments in the same `always` block.
6. Do not assign values to the same variable in more than one `always` block.
7. Use the `$strobe` system task to display the values of variables assigned with non-blocking assignments.
8. Do not use `#0` delays in assignments.

[verilog paper]: http://www.sunburst-design.com/papers/CummingsSNUG2000SJ_NBA.pdf

<!-- 理解事件模型之后, 我们可以来分析这些建议背后的原理:
1. 之所以采用非阻塞赋值来描述时序逻辑元件,
   是因为非阻塞赋值的更新事件在$R_1$和$R_2$中的事件处理结束后才处理,
   这一特点与"时序逻辑元件在下一个时钟到来时才进行写入"的属性是匹配的.
2. 在同步电路中锁存器使用并不多, 此处不展开讨论.
3. 之所以采用阻塞赋值来描述组合元件,
   是因为阻塞赋值的更新事件是在$R_1$中马上被处理的,
   其他事件可以马上看到阻塞赋值的更新结果,
   从而可以使用更新后的结果进行后续的求值,
   这一特点与"组合逻辑元件的输出在输入改变时马上改变"的属性是匹配的.
4. 和Verilog的可综合语义相关, 下文会进一步讨论.
5. 和Verilog的可综合语义相关, 下文会进一步讨论.
6. 不同的`always`块属于不同的过程, 而不同过程之间的求值顺序是不确定的,
   加上对变量赋值会产生更新事件, 正好满足数据竞争的充分必要条件,
   因此必定会造成数据竞争.
7. 非阻塞赋值的更新事件属于$R_3$, 而`$strobe`系统任务的事件属于$R_4$,
   因此`$strobe`系统任务可以输出非阻塞赋值更新后的变量值.
8. `#0`产生的事件属于$R_2$, 其处理时机位于$R_1$和$R_3$之间,
   若不理解事件处理顺序, 可能会写出行为与预期不符的代码. -->
After understanding the event model, we can analyze the principles behind these recommendations:
1. The reason for using non-blocking assignments to describe sequential logic elements is that the update events of non-blocking assignments are processed only after the events in $R_1$ and $R_2$ have been handled. This characteristic matches the property of "sequential logic elements performing writes only when the next clock arrives."
2. Latches are not commonly used in synchronous circuits, so we will not elaborate on this here.
3. The reason for using blocking assignments to describe combinational elements is that the update events of blocking assignments are processed immediately in $R_1$. Other events can immediately see the updated results of blocking assignments, allowing subsequent evaluations to use the updated values. This characteristic matches the property of "combinational logic elements' outputs changing immediately when inputs change."
4. This is related to Verilog's synthesizable semantics, which will be discussed further below.
5. This is related to Verilog's synthesizable semantics, which will be discussed further below.
6. Different `always` blocks belong to different processes, and the evaluation order between different processes is uncertain. Additionally, assigning values to variables generates update events. This exactly satisfies the sufficient and necessary conditions for data races, so data races are inevitable.
7. The update events of non-blocking assignments belong to $R_3$, while the events of the `$strobe` system task belong to $R_4$. Therefore, the `$strobe` system task can output the values of variables after they have been updated by non-blocking assignments.
8. Events generated by `#0` belong to $R_2$, and their processing timing is between $R_1$ and $R_3$. If the event processing order is not understood, one may write code whose behavior does not match expectations.

<!-- > #### todo::我会写Verilog不就行了吗? 为什么要知道这些?
> 在这一小节的最开始提到了若干条Verilog的编码建议或描述, 但其中有一些是不正确的.
> 请尝试找出它们, 并分析它们为什么不正确:
> 1. 使用`#0`可以将赋值操作强制延迟到当前仿真时刻的末尾.
> 1. 在同一个`begin`-`end`语句块中对同一个变量进行多次非阻塞赋值, 结果是未定义的.
> 1. 用`always`块描述组合逻辑元件时, 不能使用非阻塞赋值.
> 1. 不能在多个`always`块中对同一个变量进行赋值.
> 1. 不建议使用`$display`系统任务, 因为有时候它无法正确输出变量的值.
> 1. `$display`无法输出非阻塞赋值语句的结果. -->
> #### todo::I can write Verilog, so why do I need to know this?
> At the very beginning of this section, several Verilog coding suggestions or descriptions were mentioned, but some of them are incorrect.
Please try to identify them and analyze why they are incorrect:
> 1. sing `#0` can force the assignment operation to be delayed until the end of the current simulation time.
> 1. In the same `begin`-`end` statement block, performing multiple non-blocking assignments to the same variable will result in an undefined outcome.
> 1. When describing combinational logic elements with an `always` block, non-blocking assignments cannot be used.
> 1. It is not allowed to assign values to the same variable in multiple `always` blocks.
> 1. It is not recommended to use the `$display` system task because it sometimes fails to output the value of a variable correctly.
> 1. `$display` cannot output the result of a non-blocking assignment statement.


<!-- > #### comment::更多的例子和分析 -->
#### comment::More Examples and Analyses
> ["Nonblocking Assignments in Verilog Synthesis, Coding Styles That Kill!"][verilog paper]
<!-- > 这篇文章中还列举了很多例子和分析.
> 如果你打算使用Verilog, 我们强烈建议你阅读它. -->
> This article also lists many examples and analyses.
If you plan to use Verilog, we strongly recommend that you read it.

<!-- > #### caution::我会写Verilog不就行了吗? 为什么要知道这些?(2)
> 当然, 就算遵循再多的建议, 也总会有那10%的概率不小心编写出了存在数据竞争的代码.
> 当你理解了事件模型的细节, 你也就具备了独立分析和解决代码中数据竞争的能力.
>
> 况且, 要理解这些内容, 你只需要投入大约1小时.
> 和你将来花在调试中的时间相比, 这1小时是微不足道的.
> 光从"可能帮助你避免好几天不知所以然的调试"这一点来说, 这1小时的付出绝对是值得的. -->
> #### caution::I can write Verilog, so why do I need to know this? (2)
> Of course, no matter how many suggestions you follow, there will always be a 10% chance of accidentally writing code with data races.
When you understand the details of the event model, you will have the ability to independently analyze and resolve data races in your code.
>
> Moreover, it only takes about 1 hour to understand this content.
Compared with the time you will spend on debugging in the future, this 1 hour is negligible.
Just from the perspective that "it may help you avoid days of debugging without knowing why", this 1 hour of investment is definitely worthwhile.

<!-- ## 逻辑综合(Logic Synthesis) - 从RTL代码到网表

RTL代码只是电路的描述, 而仿真也只是用程序来模拟电路的行为.
如果需要把这个电路制造出来, 晶圆厂还需要更多详细的信息.
具体地, 晶圆厂需要的是一个GDSII(Graphic Design System II)格式的版图文件,
它描述了电路中每个元素的物理位置, 例如, 在坐标`(3, 4)`的位置有一个与门,
在坐标`(4, 2)`和`(0, 2)`之间有一根走线.
要将RTL代码转变成类似的GDS版图, 则需要一系列EDA工具进行多个阶段的处理.
例如, 需要通过"布局"阶段确定每一个门电路的坐标,
需要通过"布线"阶段确定如何通过线网将门电路之间连接起来.

通常, 晶圆厂会提供一个[工艺设计套件][pdk wikipedia](Process Design Kit, 简称PDK),
其中包含了特定工艺节点下的器件模型, 设计规则,
工艺约束, 验证文件和标准单元库等一系列资源,
物理设计工程师通常使用PDK来设计出符合晶圆厂制造规范的电路.
PDK中的标准单元库(standard cell library)包含了该工艺所支持的逻辑单元,
称为标准单元(standard cell).
标准单元是上文提到的GDS版图文件中描述的一部分对象,
它也是EDA工具进行处理的最小单元. -->
## Logic Synthesis - From RTL Code to Netlist

RTL code is just a description of a circuit, and simulation is only a program to simulate the behavior of the circuit. If you need to manufacture this circuit, the foundry also needs more detailed information. Specifically, what the foundry needs is a layout file in GDSII (Graphic Design System II) format, which describes the physical position of each element in the circuit. For example, there is an AND gate at coordinate (3, 4), and a wire between coordinates (4, 2) and (0, 2). To convert RTL code into a similar GDS layout, a series of EDA tools are required for processing in multiple stages. For instance, the "placement" stage is needed to determine the coordinates of each gate circuit, and the "routing" stage is needed to determine how to connect the gate circuits through nets.

Generally, the foundry will provide a [Process Design Kit (PDK)][pdk wikipedia], which contains a series of resources such as device models, design rules, process constraints, verification files, and standard cell libraries under a specific process node. Physical design engineers usually use PDK to design circuits that comply with the foundry's manufacturing specifications. The standard cell library in PDK contains the logic units supported by the process, called standard cells. Standard cells are part of the objects described in the GDS layout file mentioned above, and they are also the smallest units processed by EDA tools.

[pdk wikipedia]: https://en.wikipedia.org/wiki/Process_design_kit

<!-- 逻辑综合(也简称"综合")是指将RTL描述转换成标准单元的过程.
此外, GDS版图文件中还通过走线记录了标准单元之间的连接关系(也即拓扑结构),
这种连接关系最早是在RTL代码中描述的(也即电路和模块之间的连接关系),
因此综合器也需要在综合结果中包含它们, 以供后续阶段使用, 最终传递到GDS版图文件中.
综上所述, 综合器的输出是标准单元的网表(netlist),
它不仅记录了转换之后的标准单元, 还记录了它们之间的连接关系.

为了让大家进一步了解这个过程, 我们提供了一个基于开源EDA的综合和评估项目.
你可以通过以下命令克隆该项目: -->
Logic synthesis (also simply referred to as "synthesis") refers to the process of converting RTL descriptions into standard cells. In addition, the GDS layout file also records the connection relationships (i.e., topological structures) between standard cells through wiring. These connection relationships are first described in the RTL code (i.e., the connection relationships between circuits and modules). Therefore, the synthesizer also needs to include them in the synthesis results for use in subsequent stages, and ultimately pass them to the GDS layout file. To sum up, the output of the synthesizer is a netlist of standard cells, which not only records the converted standard cells but also their interconnection relationships.
To help you further understand this process, we provide a synthesis and evaluation project based on open-source EDA. You can clone the project using the following command:
```bash
git clone git@github.com:OSCPU/yosys-sta.git
```
<!-- 这个项目通过[开源RTL综合器yosys][yosys]对RTL代码进行综合,
并将综合结果映射到一个45nm的[开源PDK nangate45][nangate45]. -->
This project synthesizes RTL code using the open-source RTL synthesizer [yosys][yosys] and maps the synthesis results to an open-source 45nm PDK, [nangate45][nangate45].

[yosys]: https://yosyshq.net/yosys
[nangate45]: https://mflowgen.readthedocs.io/en/latest/stdlib-freepdk45.html

<!-- > #### todo::尝试使用综合器
> 克隆上述项目后, 尝试对上文的流水灯项目作为示例进行综合.
> 你可以在上述项目中通过`make syn`命令进行综合,
> 但你需要修改一些配置或参数, 具体操作方式请阅读项目中的README.

通过一个示例体验综合过程后, 我们可以来看看综合的网表文件.
在`result`目录下找到综合结果, 打开其中的`.netlist.v`文件.
可以看到, 网表文件中以bit为单位定义了很多信号,
同时还实例化了很多名称类似``NOR2_X1``, ``OAI22_X1``的子模块,
这些子模块就是nangate45这个PDK提供的标准单元.

那么, 综合器是如何将RTL代码转变成网表的呢?
我们以下面的计数器为例, 向大家介绍综合器yosys的综合过程.
此处提供[yosys的官方手册][yosys manual], 供大家需要时查阅. -->
> #### todo::Try using the synthesizer
> After cloning the above project, try to synthesize the running light project mentioned earlier as an example.
You can perform synthesis using the `make syn` command in the above project,
but you need to modify some configurations or parameters. Please refer to the README in the project for specific operation methods.

After experiencing the synthesis process through an example, we can take a look at the synthesized netlist file.
Find the synthesis results in the `result` directory and open the `.netlist.v` file.
You can see that many signals are defined in bit units in the netlist file,
and many submodules with names similar to `NOR2_X1` and `OAI22_X1` are instantiated.
These submodules are the standard cells provided by the nangate45 PDK.

So, how does the synthesizer convert RTL code into a netlist?
We will introduce the synthesis process of the synthesizer yosys to you using the following counter as an example.
The [yosys official manual][yosys manual] is provided here for your reference when needed.

[yosys manual]: https://yosyshq.readthedocs.io/projects/yosys/en/latest/

```verilog
// counter.v
module counter(
  input clk,
  input rst,
  input en,
  output reg [1:0] count
);
  always @(posedge clk) begin
    if (rst) count <= 2'd0;
    else if (en) count <= count + 2'd1;
  end
endmodule
```

<!-- ### 解析文件(Parsing)

可以通过如下命令让yosys读入源文件并解析: -->
### Parsing

You can use the following command to make yosys read and parse the source files:
```
$ yosys counter.v

-- Parsing `counter.v' using frontend ` -vlog2k' --

1. Executing Verilog-2005 frontend: counter.v
Parsing Verilog input from `counter.v' to AST representation.
Storing AST representation for module `$abstract\counter'.
Successfully finished Verilog frontend.

yosys>
```
<!-- 可以看到, yosys对`counter.v`进行了解析, 并将其转换为抽象语法树(AST),
然后输出命令提示符`yosys>`.
如果希望退出yosys, 可以在命令提示符后键入`exit`.

解析源文件的过程和编译C语言是非常类似的, 包含词法分析和语法分析.
如果去掉源文件中的其中一个分号`;`, 重新运行命令,
你会发现yosys报告如下错误: -->
As you can see, yosys parses `counter.v` and converts it into an Abstract Syntax Tree (AST), then outputs the command prompt `yosys>`. If you wish to exit yosys, you can type `exit` after the command prompt.

The process of parsing source files is very similar to compiling C language, involving lexical analysis and syntax analysis. If you remove one of the semicolons `;` from the source file and rerun the command, you'll find that yosys reports the following error:
```
counter.v:10: ERROR: syntax error, unexpected TOK_ELSE
```

<!-- ### 细化(Elaboration)

细化阶段的工作包括解析模块间的实例化关系, 计算模块实例的参数,
完成模块实例化的实例名和端口绑定等工作.

可以通过如下命令让yosys开展细化工作: -->
### Elaboration

The work in the elaboration phase includes parsing the instantiation relationships between modules, calculating parameters of module instances, and completing tasks such as instance names and port bindings for module instantiations.
You can use the following command to make yosys perform elaboration:
```
yosys> hierarchy -check -top counter

2. Executing HIERARCHY pass (managing design hierarchy).

3. Executing AST frontend in derive mode using pre-parsed AST for module `\counter'.
Generating RTLIL representation for module `\counter'.

3.1. Analyzing design hierarchy..
Top module:  \counter

3.2. Analyzing design hierarchy..
Top module:  \counter
Removing unused module `$abstract\counter'.
Removed 1 unused modules.
```
<!-- 可以看到, `hierarchy`命令还需要指定一个顶层模块,
yosys将通过这个顶层模块为起点并依次展开所有实例化的子模块,
从而确定整个设计的边界, 未被实例化的模块将被删除.
同时, 细化阶段还将整个设计的AST转变成yosys的一种中间语言RTLIL,
这和C语言编译中的中间代码生成阶段非常相似. -->
As you can see, the `hierarchy` command also needs to specify a top-level module. Yosys will start from this top-level module and sequentially expand all instantiated sub-modules, thereby determining the boundaries of the entire design. Modules that are not instantiated will be removed. At the same time, the elaboration phase will also convert the AST of the entire design into RTLIL, an intermediate language of yosys, which is very similar to the intermediate code generation phase in C language compilation.

<!-- #### 语义分析

我们可以猜想, 在yosys的细化阶段中还进行了类似C语言编译中语义分析的工作.
例如, 如果将`counter.v`中的`posedge clk`改为`posedge counter`,
yosys将在执行上述`hierarchy`命令时报告如下错误: -->
#### Semantic Analysis

We can assume that during the elaboration phase of yosys, work similar to semantic analysis in C language compilation is also performed. For example, if we change `posedge clk` in `counter.v` to `posedge counter`, yosys will report the following error when executing the above `hierarchy` command:
```
counter.v:8: ERROR: Found posedge/negedge event on a signal that is not 1 bit wide!
```
<!-- 如果在`counter.v`中添加一条模块实例化语句`mymodule abc(clk, rst);`,
yosys将在执行上述`hierarchy`命令时报告如下错误: -->
If you add a module instantiation statement `mymodule abc(clk, rst);` to counter.v, yosys will report the following error when executing the above `hierarchy` command:
```
ERROR: Module `\mymodule' referenced in module `\counter' in cell `\abc' is not part of the design.
```
<!-- 可以看到, 这两种错误都符合Verilog的语法, 因此无法在解析文件阶段发现. -->
It can be seen that both types of errors conform to Verilog syntax, so they cannot be detected during the file parsing phase.

<!-- #### 中间代码生成

`hierarchy`命令成功执行后, 我们就可以来查看整个设计的RTLIL了.
通过执行`dump`命令, yosys会将当前设计的RTLIL以文本形式输出到终端: -->
#### Intermediate Code Generation

After the `hierarchy` command is executed successfully, we can view the RTLIL of the entire design.
By executing the `dump` command, yosys will output the RTLIL of the current design to the terminal in text form:
```
yosys> dump
```
<!-- 或者通过``write_rtlil``命令将RTLIL输出到文件: -->
Or output the RTLIL to a file using the `write_rtlil` command:
```
yosys> write_rtlil counter.rtlil
```
<!-- 以`counter.rtlil`文件为例, 其内容如下: -->
Taking the `counter.rtlil` file as an example, its content is as follows:
```
autoidx 3
attribute \hdlname "counter"
attribute \top 1
attribute \src "counter.v:2.1-12.10"
module \counter
  attribute \src "counter.v:8.3-11.6"
  wire width 2 $0\count[1:0]
  attribute \src "counter.v:10.27-10.39"
  wire width 2 $add$counter.v:10$2_Y
  attribute \src "counter.v:3.9-3.12"
  wire input 1 \clk
  attribute \src "counter.v:6.20-6.25"
  wire width 2 output 4 \count
  attribute \src "counter.v:5.9-5.11"
  wire input 3 \en
  attribute \src "counter.v:4.9-4.12"
  wire input 2 \rst
  attribute \src "counter.v:10.27-10.39"
  cell $add $add$counter.v:10$2
    parameter \A_SIGNED 0
    parameter \A_WIDTH 2
    parameter \B_SIGNED 0
    parameter \B_WIDTH 2
    parameter \Y_WIDTH 2
    connect \A \count
    connect \B 2'01
    connect \Y $add$counter.v:10$2_Y
  end
  attribute \src "counter.v:8.3-11.6"
  process $proc$counter.v:8$1
    assign $0\count[1:0] \count
    attribute \src "counter.v:9.5-10.40"
    switch \rst
      attribute \src "counter.v:9.9-9.12"
      case 1'1
        assign $0\count[1:0] 2'00
      attribute \src "counter.v:10.5-10.9"
      case
        attribute \src "counter.v:10.10-10.40"
        switch \en
          attribute \src "counter.v:10.14-10.16"
          case 1'1
            assign $0\count[1:0] $add$counter.v:10$2_Y
          case
        end
    end
    sync posedge \clk
      update \count $0\count[1:0]
  end
end
```

<!-- 我们对输出的RTLIL进行一些说明,
关于RTLIL的更多内容, 可以查阅[yosys的相关手册][yosys rtlil]:
* `attribute`用于标识一些属性, 例如,
  `attribute \src "counter.v:10.27-10.39"`用于标识相应的元素在源文件中的位置,
  即`counter.v`中的第10行第27列至第10行第39列.
* `wire width 2 $0\count[1:0]`表示定义一个位宽为`2`的信号,
  其名称为`$0\count[1:0]`(注意, `$`, ``\``, `[`, `:`和`]`这些字符都是名称的一部分).
* `cell $add $add$counter.v:10$2`表示实例化一个类型为`$add`的单元,
  其名称为`$add$counter.v:10$2`. 单元的具体参数用`parameter`表示,
  例如, ``parameter \A_WIDTH 2``表示单元的端口`A`的位宽为`2`,
  ``parameter \A_SIGNED 0``表示单元的端口`A`是无符号的.
  端口的连接关系用`connect`表示,
  例如, ``connect \Y $add$counter.v:10$2_Y``表示单元的端口`Y`与信号``$add$counter.v:10$2_Y``相连.
* `process`表示一个行为描述过程, 其中`assign`表示信号的赋值,
  `switch`-`case`表示根据信号的值进行条件性赋值,
  `sync`表示当条件满足时对信号进行更新. -->
We will provide some explanations for the output RTLIL. For more information about RTLIL, you can refer to the [relevant yosys manual][yosys rtlil]:
* `attribute` is used to identify some attributes. For example, `attribute \src "counter.v:10.27-10.39"` is used to indicate the position of the corresponding element in the source file, that is, from column 27 to column 39 of line 10 in `counter.v`.
* The `wire width 2 $0\count[1:0]` indicates defining a signal with a bit width of `2`, and its name is `$0\count[1:0]` (note that characters such as `$`, ``\``, `[`, `:`, and `]` are all part of the name).
The `cell $add $add$counter.v:10$2` indicates instantiating a cell of type `$add`, with the name `$add$counter.v:10$2`. The specific parameters of the cell are represented by `parameter`. For example, ``parameter \A_WIDTH 2`` means that the bit width of port `A` of the cell is `2`, and ``parameter \A_SIGNED 0`` means that port `A` of the cell is unsigned. The connection relationship of the ports is represented by `connect`. For example, ``connect \Y $add$counter.v:10$2_Y`` means that port `Y` of the cell is connected to the signal `$add$counter.v:10$2_Y`.
* The `process` represents a behavioral description process, where `assign` indicates the assignment of signals, `switch`-`case` indicates conditional assignment based on the value of a signal, and `sync` indicates updating the signal when the condition is met.

[yosys rtlil]: https://yosyshq.readthedocs.io/projects/yosys/en/latest/yosys_internals/formats/rtlil_rep.html#

<!-- 可以看到, RTLIL的语法虽然和Verilog不同,
但我们仍然能感觉到, RTLIL也是在描述硬件,
甚至能感觉到`process`和Verilog代码中的`always`存在对应关系.
不过, 一些运算符被单元(cell)取代了, 例如`+`被`$add`取代,
因此和原始的Verilog代码相比, 当前的RTLIL更接近网表.
类似`$add`这些单元, 属于[yosys的内部单元库(internal cell library)][yosys cell lib]. -->
As can be seen, although the syntax of RTLIL is different from that of Verilog, we can still feel that RTLIL is also describing hardware, and even sense that `process` corresponds to `always` in Verilog code. However, some operators have been replaced by cells. For example, `+` is replaced by `$add`. Therefore, compared with the original Verilog code, the current RTLIL is closer to the netlist. Such cells as `$add` belong to [yosys's internal cell library][yosys cell lib].

[yosys cell lib]: https://yosyshq.readthedocs.io/projects/yosys/en/latest/cell_index.html

<!-- 我们还可以将RTLIL中的拓扑关系通过结构图的方式进行可视化.
不过在这之前, 你可能需要安装一个`Graphviz dot`类型文件的查看工具: -->
We can also visualize the topological relationships in RTLIL through structure diagrams. However, before doing this, you may need to install a viewing tool called `Graphviz dot` for files with such format :
```bash
apt-get install xdot
```
<!-- 然后, 你可以在yosys中执行`show`命令,
它会自动调用`xdot`等工具打开结构图: -->
Then, you can execute the `show` command in yosys, and it will automatically call tools like `xdot` to open the structure diagram:
```
yosys> show
```
<!-- `show`命令生成的结构图文件默认保存在``~/.yosys_show.dot``,
多次执行`show`命令会将其覆盖,
你可以将其手动拷贝到其他目录下, 并通过`xdot`工具打开它. -->
The structure diagram file generated by the `show` command is saved by default in ``~/.yosys_show.dot``. Executing the `show` command multiple times will overwrite it. You can manually copy it to another directory and open it with the `xdot` tool.

<!-- > #### todo::查看结构图
> 通过`show`命令查看当前的结构图, 从而认识RTLIL.

### 粗粒度综合(Coarse-grain synthesis)

粗粒度综合阶段负责基于设计的"粗粒度表示"进行处理.
在这里, 粗粒度表示是指采用运算符级别的单元来描述设计.
yosys的内部单元库中有一类[字级单元][yosys word level cells](word-level cells),
这些单元的所描述的功能处于相对较高的抽象层次, 支持多位的位宽和参数功能.
在命名风格上, 字级单元通常以`$`为前缀来命名.
上文提到的`$add`单元就属于字级单元,
其他的字级单元还包括`$shift`(移位运算), `$mux`(选择运算)等. -->
> #### todo::View Structure Diagram
> Use the `show` command to view the current structure diagram and thus understand RTLIL.

### Coarse-grain Synthesis

The coarse-grain synthesis stage is responsible for processing based on the "coarse-grain representation" of the design.
Here, the coarse-grain representation refers to describing the design using operator-level units.
Yosys's internal cell library includes a type of [word-level cells][yosys word level cells],
which describe functions at a relatively high level of abstraction and support multi-bit widths and parameter functions.
In terms of naming conventions, word-level cells are usually prefixed with $.
The `$add` cell mentioned above belongs to word-level cells.
Other word-level cells include `$shift` (shift operation), `$mux` (selection operation), etc.

[yosys word level cells]: https://yosyshq.readthedocs.io/projects/yosys/en/latest/cell/index_word.html

<!-- #### 将过程描述转换为粗粒度表示

不过, 目前的RTLIL还存在`process`这样的过程描述(在结构图中通过`PROC`节点表示),
它们还不属于粗粒度表示, 无法对其开展粗粒度表示相关的处理工作.
因此, yosys还需要先将所有过程描述转换为粗粒度表示,
这可以通过`proc`命令来实现: -->
#### Converting Procedural Descriptions to Coarse-grain Representations

However, the current RTLIL still contains procedural descriptions like `process` (represented by `PROC` nodes in the structure diagram), which do not belong to the coarse-grain representation and thus cannot be processed in relation to coarse-grain representation. Therefore, Yosys needs to first convert all procedural descriptions to coarse-grain representations, which can be achieved using the `proc` command:
```
yosys> proc
```
<!-- `proc`命令其实是一条宏命令(macro command),
它会依次调用一系列子命令来完成过程描述的转换: -->
The `proc` command is actually a macro command, which sequentially calls a series of subcommands to complete the conversion of procedural descriptions:

<!-- | 步骤 |   子命令             | 说明                  |
|:----:|:--------------------:|:---------------------:|
|   1  | ``proc_clean``       | 移除空分支和空的过程描述 |
|   2  | ``proc_rmdead``      | 移除不可达的`case`分支 |
|   3  | ``proc_prune``       | 移除冗余的赋值操作(被后续赋值操作所覆盖) |
|   4  | ``proc_init``        | 将过程描述中的`init`操作转换为相应信号上的`init`属性 |
|   5  | ``proc_arst``        | 识别异步复位 |
|   6  | ``proc_rom``         | 将过程描述中的`switch`操作在适合时转换为ROM |
|   7  | ``proc_mux``         | 将过程描述中的`switch`操作转换为`$mux`单元(多路选择器) |
|   8  | ``proc_dlatch``      | 将过程描述中的锁存器转换为D锁存器类型的单元 |
|   9  | ``proc_dff``         | 将过程描述中的触发器转换为D触发器类型的单元 |
|  10  | ``proc_memwr``       | 将过程描述中的存储器写操作转换为`$memwr`单元 |
|  11  | ``proc_clean``       | 移除空分支和空的过程描述 |
|  12  | ``opt_expr -keepdc`` | 进行表达式相关的优化 | -->
| Step |   Subcommand             | Description                 |
|:----:|:--------------------:|:---------------------:|
|   1  | ``proc_clean``       | Remove empty branches and empty procedural descriptions |
|   2  | ``proc_rmdead``      | Remove unreachable `case` branches |
|   3  | ``proc_prune``       | Remove redundant assignment operations (overwritten by subsequent assignments) |
|   4  | ``proc_init``        | Convert `init` operations in procedural descriptions to init attributes on corresponding signals |
|   5  | ``proc_arst``        | Identify asynchronous resets |
|   6  | ``proc_rom``         | Convert `switch` operations in procedural descriptions to ROM when appropriate |
|   7  | ``proc_mux``         | Convert `switch` operations in procedural descriptions to `$mux` cells (multiplexers) |
|   8  | ``proc_dlatch``      | Convert latches in procedural descriptions to D-latch type cells |
|   9  | ``proc_dff``         | 	Convert latches in procedural descriptions to D flip-flop type cells |
|  10  | ``proc_memwr``       | Convert memory write operations in procedural descriptions to `$memwr` cells |
|  11  | ``proc_clean``       | Remove empty branches and empty procedural descriptions |
|  12  | ``opt_expr -keepdc`` | Perform expression-related optimizations |

<!-- 有一些子命令和C语言的编译优化技术很类似, 它们对你来说应该不难理解.
从整体上看, `proc`命令主要将RTLIL中过程描述的`switch-case`部分转换为`$mux`单元,
将`sync`描述转换为D锁存器类型或D触发器类型的单元, 从而得到完整的粗粒度表示. -->
Some subcommands are quite similar to C language compilation optimization techniques, so they should be easy for you to understand.
Overall, the `proc` command mainly converts the `switch`-`case` parts of procedural descriptions in RTLIL into `$mux` cells, and converts `sync` descriptions into D-latch type or D-flip-flop type cells, thereby obtaining a complete coarse-grain representation.

<!-- > #### todo::查看结构图(2)
> 通过`show`命令查看当前的结构图, 对比执行`proc`命令前后的不同.

#### 优化

和编译优化类似, 综合器一般也提供优化的功能,
使得开发者可以将精力集中在架构设计和逻辑设计当中,
而不必在设计阶段过多考虑电路的性能表现, 综合器通常能提供一个还不错的性能下限.

得到完整的粗粒度表示后, 就可以应用一系列优化来生成更优的设计了.
这可以通过`opt`命令来实现: -->
> #### todo::View Structure Diagram (2)
> Use the `show` command to view the current structure diagram and compare the differences before and after executing the `proc` command.

#### Optimization

Similar to compilation optimization, synthesizers generally also provide optimization functions, allowing developers to focus on architecture design and logic design without having to overly consider the performance of the circuit during the design phase. Synthesizers can usually provide a fairly good minimum performance level.

After obtaining a complete coarse-grain representation, a series of optimizations can be applied to generate a better design. This can be achieved through the `opt` command:
```
yosys> opt
```
<!-- 和上文介绍的`proc`类似, `opt`也是一条宏命令,
它会依次调用一系列子命令来开展各种优化: -->
Similar to the `proc` command introduced earlier, `opt` is also a macro command, which sequentially calls a series of subcommands to perform various optimizations:

<!-- | 步骤 |   子命令             | 说明                  |
|:----:|:--------------------:|:---------------------:|
|   1  | ``opt_expr``         | 常量合并和简单表达式改写 |
|   2  | ``opt_merge -nomux`` | 合并相同的单元, 但不合并选择器类型的单元 |
|      | ``do``               | 开始循环 |
|   3  | ``opt_muxtree``      | 移除嵌套选择器中的不可达分支 |
|   4  | ``opt_reduce``       | 简化多输入的选择器, 与门和或门 |
|   5  | ``opt_merge``        | 合并相同的单元 |
|   6  | ``opt_share``        | 合并输入相同, 类型相同, 且不会同时激活的单元 |
|   7  | ``opt_dff``          | D触发器的常量优化和时钟复位信号合并 |
|   8  | ``opt_clean``        | 移除无用的单元和线网 |
|   9  | ``opt_expr``         | 常量合并和简单表达式改写 |
|      | ``while (changed)``  | 若设计发生变化, 则跳转到第3步继续循环 | -->
| Step |   Subcommand            | Description               |
|:----:|:--------------------:|:---------------------:|
|   1  | ``opt_expr``         | Constant folding and simple expression rewriting |
|   2  | ``opt_merge -nomux`` | Merge identical cells, but not selector-type cells |
|      | ``do``               | Start loop |
|   3  | ``opt_muxtree``      | Remove unreachable branches in nested selectors |
|   4  | ``opt_reduce``       | Simplify multi-input selectors, AND gates, and OR gates |
|   5  | ``opt_merge``        | 	Merge identical cells |
|   6  | ``opt_share``        | Merge cells with the same input, same type, and non-simultaneous activation |
|   7  | ``opt_dff``          | Constant optimization of D flip-flops and merging of clock/reset signals |
|   8  | ``opt_clean``        | Remove useless cells and nets |
|   9  | ``opt_expr``         | Constant folding and simple expression rewriting |
|      | ``while (changed)``  | If the design has changed, jump to step 3 to continue the loop | 

<!-- 下面列举一些常见的优化技术.
为了方便理解, 我们用Verilog代码来呈现优化前后的语义.

* 常量合并和简单表达式改写(``opt_expr``) - 在一些表达式中, 若某输入为特定的常量,
  或表达式符合某种特殊样式, 可对其进行简化. 以下示例中,
  表达式`a != a`的结果必定为`0`, 故可优化为`assign x = 1'b0`;
  进一步地, 应用常量传播优化技术后,
  表达式`b | x`的结果必定为`b`, 故可优化为`assign y = b;`;
  此外, 由于`c`的位宽为1, 表达式`c == 0`与`~c`等价, 故可优化为`assign z = ~c;`.
  综合器可以用计算结果替代这些单元, 从而简化相应的电路. -->
Here are some common optimization techniques. For easier understanding, we'll use Verilog code to illustrate the semantics before and after optimization.

* Constant folding and simple expression rewriting (``opt_expr``) - In some expressions, if an input is a specific constant or the expression follows a special pattern, it can be simplified. In the following example, the result of the expression `a != a` must be `0`, so it can be optimized to assign `x = 1'b0`; further, after applying constant propagation optimization, the result of the expression `b | x` must be `b`, so it can be optimized to `assign y = b;`; in addition, since the bit width of `c` is 1, the expression `c == 0` is equivalent to `~c`, so it can be optimized to `assign z = ~c;`. The synthesizer can replace these cells with calculation results, thereby simplifying the corresponding circuit.

```verilog
// before optimization         |   after optimization
  wire a, b, c, x, y, z;       |    wire a, b, c, x, y, z;
  // ......                    |    // ......
  assign x = a != a;           |    assign x = 1'0;
  assign y = b | x;            |    assign y = b;
  assign z = c == x;           |    assign z = ~c;
```

<!-- * 合并相同单元(``opt_merge``) - 对于多个功能和输入都相同的单元, 可将其合并成一个单元,
  让其输出驱动原来的各输出信号, 从而减少单元的数量.
  以下示例中, `a + b`和`b + a`这两个单元的功能和输入都相同,
  可直接让`x`驱动`y`, 从而减少一个加法单元. -->
* Merging identical cells (``opt_merge``) - For multiple cells with identical functions and inputs, they can be merged into a single cell, with its output driving all the original output signals, thereby reducing the number of cells. In the following example, the cells for `a + b` and `b + a` have identical functions and inputs, so `x` can directly drive `y`, eliminating one addition cell.

```verilog
// before optimization         |   after optimization
  wire a, b, x, y;             |    wire a, b, x, y;
  // ......                    |    // ......
  assign x = a + b;            |    assign x = a + b;
  assign y = b + a;            |    assign y = x;
```

<!-- > #### comment::面积和性能的权衡
> 需要注意的是, 这种优化虽然减少了单元的数量,
> 但却增加了单元的扇出(即与该单元输出相连的下游单元的数量).
> 在其他条件保持不变的情况下, 扇出增大会使得电路延迟上升.
>
> 用生活中的例子来比喻, 单元的输出就像是水龙头, 用于向下游的水池提供水流,
> 当水池充满水时, 才能推开闸门, 类似让下游的晶体管发生翻转.
> 优化前, 两个水龙头各自向下游的水池提供水流;
> 优化后, 水龙头数量节省了, 但它需要同时向下游的两个水池提供水流.
> 在水流速度不变的情况下, 要让两个水池达到充满状态,
> 则需要花费更长的时间, 这个时间就类似于电路的延迟.
>
> 在需要优化延迟的场合, 反而会采用"复制单元"的方法添加水龙头的数量.
> 因此, 是采用合并单元还是采用复制单元, 其实是面积和性能之间的权衡.

* 移除嵌套选择器中的不可达分支(``opt_muxtree``) - 在嵌套的选择器中,
  某些分支因条件冲突而不可达, 可将其移除.
  以下示例中, 内层选择器`a ? b : c`的结果不可能为`c`,
  因为这要求外层的选择信号`a = 1`, 同时要求内层的选择信号`a = 0`, 矛盾.
  因此可将内层的选择器单元替换为`b`, 从而简化相应的电路. -->
> #### comment::Trade-off Between Area and Performance
> It should be noted that although this optimization reduces the number of cells, it increases the fan-out of the cell (i.e., the number of downstream cells connected to the cell's output).
All other things being equal, an increase in fan-out will lead to an increase in circuit delay.
> 
> To use a real-life analogy, the output of a cell is like a faucet that supplies water to downstream pools. Only when a pool is full can the gate be opened, similar to the flipping of downstream transistors.
Before optimization, two faucets supply water to their respective downstream pools;
after optimization, the number of faucets is reduced, but it needs to supply water to two downstream pools at the same time.
With the water flow rate remaining unchanged, it will take longer to fill both pools, and this time is similar to the circuit delay.
>
> In situations where delay optimization is required, the method of "cell duplication" is used instead to increase the number of faucets.
Therefore, choosing between merging cells and duplicating cells is actually a trade-off between area and performance.

* Removing unreachable branches in nested selectors (``opt_muxtree``) - In nested selectors, some branches are unreachable due to conflicting conditions and can be removed.
In the following example, the result of the inner selector `a ? b : c` cannot be `c` because this would require the outer selection signal `a = 1` and the inner selection signal `a = 0` at the same time, which is a contradiction.
Therefore, the inner selector cell can be replaced with `b`, thereby simplifying the corresponding circuit.

```verilog
// before optimization            |   after optimization
  wire a, b, c, d, x;             |    wire a, b, c, d, x;
  // ......                       |    // ......
  assign x = a ? (a ? b : c) : d; |    assign x = a ? b : d;
```

<!-- * 简化多输入的选择器, 与门和或门(``opt_reduce``) -
  对于多输入的选择器, 与门和或门, 它们中有一些输入可能相同,
  可以对这些输入进行消除或合并.
  以下示例中, 优化前需要在两个32位的信号中进行选择, 得出`imm`, 但对于这两个信号来说,
  它们的第12到第31位都分别和第11位相同(一个是`0`, 另一个是`inst[31]`),
  因此可以对选择器的输入进行优化, 先选择第0到第11位的部分作为`imm[11:0]`,
  再将选出的第11位作为`imm[31:20]`. 优化后, 选择器的数据端位宽从32降低到12.
  类似地, 通过`&imm`进行归约与运算(reduce and)时,
  由于输入`imm`的第12到第31位都和第11位相同,
  故可直接移除输入的第12到第31位, 其结果与`&imm[11:0]`相同.
  优化后, 与门的输入端位宽从32降低到12. -->
* Simplifying multi-input selectors, AND gates, and OR gates (``opt_reduce``) -
For multi-input selectors, AND gates, and OR gates, some of their inputs may be the same,
allowing these inputs to be eliminated or merged.
In the following example, before optimization, a selection between two 32-bit signals is needed to derive `imm`. However, for these two signals,
their bits 12 to 31 are respectively the same as bit 11 (one is `0`, the other is `inst[31]`).
Therefore, the inputs of the selector can be optimized by first selecting bits 0 to 11 as `imm[11:0]`,
then using the selected bit 11 as `imm[31:20]`. After optimization, the bit width of the selector's data port is reduced from 32 to 12.
Similarly, when performing a reduce AND operation via `&imm`,
since bits 12 to 31 of the input `imm` are the same as bit 11,
bits 12 to 31 of the input can be directly removed, and the result is the same as `&imm[11:0]`.
After optimization, the bit width of the AND gate's input is reduced from 32 to 12.

```verilog
//          优化前              |            优化后
  wire [31:0] inst, imm;          |    wire [31:0] inst, imm;
  wire sel, x;                    |    wire sel, x;
  // ......                       |    // ......
  assign imm = !sel ? 32'b0 :     |    assign imm[11:0] = !sel ? 12'b0 : inst[31:20];
    {{20{inst[31]}}, inst[31:20]};|    assign imm[31:20] = {20{imm[11]}};
  assign x = &imm;                |    assign x = &imm[11:0];
```

<!-- * D触发器的常量优化(``opt_dff``) - 若D触发器的数据输入端为常量,
  则可将其替换为常量, 从而移除相应的D触发器单元.
  以下示例中, D触发器`r`的数据输入端为常量, 可直接将其优化成一个常量信号. -->
* Constant optimization of D flip-flops (``opt_dff``) - If the data input of a D flip-flop is a constant, the flip-flop can be replaced with that constant, thereby removing the corresponding D flip-flop cell. In the following example, the data input of the D flip-flop `r` is a constant, so it can be directly optimized into a constant signal.

```verilog
// before optimization            |   after optimization
  reg [31:0] r;                   |    wire [31:0] r;
  // ......                       |    // ......
  always @ (posedge clk)          |    assign r = 32'hdeadbeef;
    r <= 32'hdeadbeef;            |
```

<!-- * 移除无用的单元和线网(``opt_clean``) -
  如果某些单元和线网不影响模块的输出, 可将其移除.
  以下示例中, 线网`t`不影响模块的输出端口`x`, 故可将其与单元`a & b`一同移除. -->
* Removing useless cells and nets (``opt_clean``) -
If certain cells and nets do not affect the output of the module, they can be removed.
In the following example, the net `t` does not affect the output port `x` of the module, so it can be removed together with the cell `a & b`.

```verilog
// before optimization            |   after optimization
  module m(                       |    module m(
    input a, b;                   |      input a, b;
    output x;                     |      output x;
  );                              |    );
    wire t;                       |      assign x = a + b;
    assign x = a + b;             |    endmodule
    assign t = a & b;             |
  endmodule                       |
```

<!-- 除了上文介绍的技术, 综合过程中使用的优化技术还有很多, 例如位宽削减, 窥孔优化等,
此处我们不展开讨论, 感兴趣的同学可以查阅[yosys的文档][yosys opt]或相关资料. -->
In addition to the techniques introduced above, there are many other optimization techniques used in the synthesis process, such as bit-width reduction and peephole optimization. We will not elaborate on them here. For those who are interested, you can refer to the [yosys documentation][yosys opt] or related materials.

[yosys opt]: https://yosyshq.readthedocs.io/projects/yosys/en/latest/using_yosys/synthesis/opt.html

<!-- > #### todo::查看结构图(3)
> 通过`show`命令查看当前的结构图, 对比执行`opt`命令前后的不同.

#### 有限状态机的识别和处理

我们之前介绍过计算机系统的状态机模型,
其中说明过数字电路也可以看成一个状态机.
这里的有限状态机(Finite State Machine, FSM)更多是指设计中用数字逻辑实现的,
具有状态机特征的部分.

例如, 你应该在HDLBits上完成过类似"识别连续的3个`1`"的题目.
针对这个问题, 我们可以列出如下状态转移表(表项含义为"次态/输出"): -->
> #### todo::View Structure Diagram (3)
> Use the `show` command to view the current structure diagram and compare the differences before and after executing the `opt` command.

#### Identification and Processing of Finite State Machines

We have previously introduced the state machine model of computer systems, which explained that digital circuits can also be regarded as a state machine. The Finite State Machine (FSM) here mainly refers to the part in the design that is implemented with digital logic and has the characteristics of a state machine.

For example, you should have completed similar problems like "identifying three consecutive `1`s" on HDLBits. For this problem, we can list the following state transition table (where each entry means "next state/output"):

<!-- |      |   含义       |  输入`0` |  输入`1` |
|:----:|:------------:|:--------:|:--------:|
| `S0` | 初始状态     | `S0`/`0` | `S1`/`0` |
| `S1` | 识别了1个`1` | `S0`/`0` | `S2`/`0` |
| `S2` | 识别了2个`1` | `S0`/`0` | `S2`/`1` | -->
|      |  	Meaning    |  Input `0` | Input `1` |
|:----:|:------------:|:--------:|:--------:|
| `S0` |Initial state    | `S0`/`0` | `S1`/`0` |
| `S1` | Identified 1`1` | `S0`/`0` | `S2`/`0` |
| `S2` | Identified 2 consecutive `1`s| `S0`/`0` | `S2`/`1` |

<!-- 对于一些更复杂的FSM, 其中可能包含一些冗余状态或可合并的状态,
但这些情况在电路层次的语义上很难发现.
因此综合器一般先在电路层次上识别出FSM,
然后在FSM层次上对其进行分析和优化, 最后再将其映射回电路层次.

在yosys中, 这可以通过`fsm`命令来实现: -->
For some more complex FSMs, there may be redundant states or mergeable states, but these situations are difficult to detect at the circuit-level semantics. Therefore, synthesizers generally first identify FSMs at the circuit level, then analyze and optimize them at the FSM level, and finally map them back to the circuit level.
In yosys, this can be achieved through the `fsm` command:
```
yosys> fsm
```
<!-- `fsm`也是一条宏命令, 它会依次调用一系列子命令来开展FSM的处理,
主要的处理步骤包括:
1. FSM检测 - 根据一定的规则在RTLIL中识别出FSM,
   并用特殊属性标记相关单元
1. FSM抽取 - 将标记的相关单元用`$fsm`单元替代,
   并解析出状态转移表
1. FSM优化 - 根据状态转移表对FSM进行优化,
   包括移除无用的输出信号, 合并上游相同的输入信号,
   合并输出相同的状态, 根据常量输入简化状态等
1. FSM重编码 - 经过优化后, FSM的状态数量可能会减少,
   因此可通过重编码减少状态信号和状态寄存器的位宽
1. 单元映射 - 将处理后的`$fsm`单元映射回电路层次的单元 -->
`fsm` is also a macro command that sequentially invokes a series of subcommands to handle FSMs. The main processing steps include:
1. FSM detection - Identify FSMs in RTLIL according to certain rules and mark related cells with special attributes
1. FSM extraction - Replace the marked related cells with `$fsm` cells and parse out the state transition table
1. FSM optimization - Optimize the FSM based on the state transition table, including removing useless output signals, merging identical upstream input signals, merging states with the same output, simplifying states according to constant inputs, etc.
1. FSM recoding - After optimization, the number of FSM states may be reduced, so recoding can be used to reduce the bit width of state signals and state registers
1. Cell mapping - Map the processed `$fsm` cells back to circuit-level cells

<!-- 不过, 上述`counter.v`并不包含FSM, 因此执行上述`fsm`命令并没有效果.
理论上讲, 根据数字电路的状态机模型,
我们可以尝试将任意数字电路设计整体看作一个FSM来开展上述处理,
但这样解析出的状态转移表非常庞大(对于一个32位的寄存器,
就已经有$2^{32}$种状态), 这会带来两方面的问题:
一方面, 处理这样的状态空间需要的计算量, 已经远高于当前计算机的计算能力;
另一方面, 这样的状态在输入, 输出, 次态这些方面的相似性非常低,
几乎不可能找到可以优化的状态和信号.
因此, 数字电路的状态机模型只用于帮助我们理解基本原理,
实际中并不会将其用于FSM优化. -->
However, the aforementioned `counter.v` does not contain an FSM, so executing the above `fsm` command will have no effect. Theoretically, according to the state machine model of digital circuits, we can try to treat any digital circuit design as an FSM as a whole for the above processing. But the state transition table parsed in this way will be extremely large (for a 32-bit register, there are already $2^{32}$ states), which will cause two problems: On the one hand, the amount of computation required to process such a state space is far beyond the computing power of current computers; On the other hand, such states have very low similarity in terms of input, output, and next state, making it almost impossible to find states and signals that can be optimized. Therefore, the state machine model of digital circuits is only used to help us understand the basic principles, and in practice, it will not be used for FSM optimization.

<!-- #### 存储器的识别和处理

另一种需要特殊处理的单元是存储器.
在yosys中, 可以通过`memory`命令来对RTLIL进行存储器相关的处理: -->
#### Identification and Processing of Memories
Another type of unit that requires special handling is memory. In Yosys, memory-related processing on RTLIL can be performed using the `memory` command:
```
yosys> memory
```
<!-- `memory`也是一条宏命令, 它会依次调用一系列子命令,
相关处理包括将上下游的触发器合并到存储器的读写单元,
将存储器的多个读写单元合并成一个多端口的存储器单元等.

在FPGA流程中, 由于FPGA提供的存储器器件类型不多(如LUT RAM, Block RAM和FF),
FPGA综合器可以通过上文的方式自动在RTL代码中识别出存储器,
并根据识别出的存储器属性将其映射到物理上的存储器器件.
利用FPGA的可编程性, 综合器可以实现存储器器件的按需分配,
也即, 综合器可以根据RTL代码动态计算出需要多大的存储器, 并映射到它们.

但对于ASIC流程来说则并非如此.
为了提升存储器的性能, ASIC流程的存储器单元中并不包含可编程的功能,
而是由标准单元库提供若干种规格确定的存储器供RTL开发者选择.
这些存储器单元还有不同的性能, 面积和功耗属性,
例如, 要在RTL层次实现`64x64`的存储器功能,
RTL开发者可以选择1个`64x64`的存储器单元, 也可以选择2个`32x64`的存储器单元进行拼接.
前者具有较小的总面积, 但读延迟可能较高; 而后者的总面积较大, 但读延迟较优.
此外, 不同的存储器规格具有不同的形状, 也会对后续的布局布线产生影响.
这些互相制约的因素使得综合器难以自动进行存储器的识别和映射,
因此需要RTL开发者需要根据设计目标自行选择存储器规格,
并在RTL代码中手动以子模块的方式实例化存储器单元.

可以说, ASIC流程和FPGA流程在存储器使用方式的差异上,
体现的是性能和灵活性的权衡:
ASIC追求更高的性能, 但灵活性较弱, 难以实现按需分配, 需要开发者自行选择具体规格;
FPGA的灵活性较好, 但存储器器件的可编程功能使其性能表现不如ASIC.

不过, 上述`counter.v`并不包含存储器, 因此执行上述`memory`命令并没有效果.
在将来一段时间内, 我们都不会接触包含这种存储器的电路设计.
我们会在A阶段再讨论存储器的问题. -->
`memory` is also a macro command that sequentially invokes a series of subcommands. Its related processing includes merging flip-flops upstream and downstream into the read-write units of the memory, and merging multiple read-write units of the memory into a multi-port memory unit, etc.

In the FPGA flow, since FPGAs provide only a few types of memory devices (such as LUT RAM, Block RAM, and FF), FPGA synthesizers can automatically identify memories in the RTL code through the above-mentioned methods and map them to physical memory devices according to the identified memory attributes. Utilizing the programmability of FPGAs, synthesizers can realize on-demand allocation of memory devices. That is, synthesizers can dynamically calculate the required memory size based on the RTL code and map to them.

However, this is not the case for the ASIC flow. To improve memory performance, memory units in the ASIC flow do not have programmable functions. Instead, the standard cell library provides several types of memories with fixed specifications for RTL developers to choose from. These memory units also have different performance, area, and power consumption attributes. For example, to implement a `64x64` memory function at the RTL level, RTL developers can choose one `64x64` memory unit or splice two `32x64` memory units. The former has a smaller total area but may have higher read latency; the latter has a larger total area but better read latency. In addition, different memory specifications have different shapes, which will also affect the subsequent placement and routing. These mutually restrictive factors make it difficult for synthesizers to automatically identify and map memories. Therefore, RTL developers need to select memory specifications according to design goals and manually instantiate memory units as submodules in the RTL code.

It can be said that the difference in the way memories are used between the ASIC flow and the FPGA flow reflects the trade-off between performance and flexibility: ASIC pursues higher performance but has weaker flexibility, making it difficult to achieve on-demand allocation, requiring developers to choose specific specifications by themselves; FPGA has better flexibility, but the programmable functions of its memory devices make its performance not as good as that of ASIC.

However, the above-mentioned `counter.v` does not contain memory, so executing the above `memory` command will have no effect. For a period of time in the future, we will not come into contact with circuit designs containing such memories. We will discuss the issue of memory in A Stage.

<!-- ### 细粒度综合(Fine-grain synthesis)

细粒度综合阶段负责基于设计的"细粒度表示"进行处理.
如上文所述, 所谓细粒度表示, 是指采用门级的单元来描述设计.
yosys的内部单元库中有一类[门级单元][yosys gate level cells](gate-level cells),
和粗粒度表示中采用的单元相比, 这些门级单元的数据位宽都是1, 而且不提供参数功能.
在命名风格上, 门级单元通常以``$_XXX_``的形式命名,
其中`XXX`一般采用大写, 从而与字级单元区分开来. -->
### Fine-grain Synthesis

The fine-grain synthesis stage is responsible for processing based on the "fine-grain representation" of the design.
As mentioned above, the so-called fine-grain representation refers to describing the design using gate-level cells.
There is a category of [gate-level cells][yosys gate level cells] in Yosys's internal cell library.
Compared with the cells used in the coarse-grain representation, these gate-level cells all have a data bit width of 1 and do not provide parameter functions.
In terms of naming style, gate-level cells are usually named in the form of ``$_XXX_``, where `XXX` is generally in uppercase to distinguish it from word-level cells.


[yosys gate level cells]: https://yosyshq.readthedocs.io/projects/yosys/en/latest/cell/index_gate.html

<!-- 细粒度综合首先需要将设计的粗粒度表示转换为细粒度表示,
这可以通过`techmap`命令来实现: -->
Fine-grain synthesis first needs to convert the coarse-grain representation of the design into a fine-grain representation, which can be achieved through the `techmap` command:
```
yosys> techmap
```
<!-- `techmap`命令用于将当前设计的单元替换成指定单元库中的单元实现,
若不指定单元库, 命令将采用yosys内部的门级单元库.

替换为门级单元后, 还需要对一些多位的线网和端口进行拆分,
否则RTLIL中将会包含不必要的位抽取和位拼接操作.
这可以通过`splitnets`命令来实现: -->
The `techmap` command is used to replace the cells of the current design with cell implementations from a specified cell library. If no cell library is specified, the command will use Yosys's internal gate-level cell library.

After replacing with gate-level cells, it is also necessary to split some multi-bit nets and ports. Otherwise, RTLIL will contain unnecessary bit extraction and bit concatenation operations. This can be achieved through the `splitnets` command:
```
yosys> splitnets -ports
```
<!-- 然后, 可以执行`opt -full`命令让yosys开展一些优化工作,
以清除无用的单元和线网, 然后再查看结构图.

可以看到, 粗粒度表示中位宽为2的D触发器单元被拆分为2个位宽为1的D触发器单元,
加法器单元`$add`也被拆分为一些门级单元.
因此, 和粗粒度表示相比, 当前的细粒度表示更接近网表. -->
Next, you can execute the `opt -full` command to allow Yosys to perform some optimization work, which will clear out unused cells and nets, after which you can view the structure diagram.

It can be seen that the D flip-flop cell with a bit width of 2 in the coarse-grain representation has been split into 2 D flip-flop cells each with a bit width of 1, and the adder cell `$add` has also been split into several gate-level cells.
Therefore, compared with the coarse-grain representation, the current fine-grain representation is closer to the netlist.

<!-- > #### todo::查看结构图(4)
> 通过`show`命令查看当前的结构图, 对比执行`techmap`命令前后的不同. -->
> #### todo::View Structure Diagram (4)
> Use the `show` command to view the current structure diagram and compare the differences before and after executing the `techmap` command.

<!-- ### 工艺映射(Technology mapping)

工艺映射是指从工艺无关的电路表示映射到具体工艺的实现.
在这里, 工艺映射阶段负责将设计的细粒度表示映射到目标工艺的标准单元.
为了展示工艺映射的效果, 我们采用一个简单的示例标准单元库, 它源于yosys手册: -->
### Technology Mapping

Technology mapping refers to the process of mapping a technology-independent circuit representation to a specific technology implementation.
In this context, the technology mapping stage is responsible for mapping the fine-grain representation of the design to the standard cells of the target technology.
To demonstrate the effect of technology mapping, we use a simple example standard cell library, which is derived from the Yosys manual:
```
library(demo) {
  cell(BUF) {
    area: 6;
    pin(A) { direction: input; }
    pin(Y) { direction: output;
              function: "A"; }
  }
  cell(NOT) {
    area: 3;
    pin(A) { direction: input; }
    pin(Y) { direction: output;
              function: "A'"; }
  }
  cell(NAND) {
    area: 4;
    pin(A) { direction: input; }
    pin(B) { direction: input; }
    pin(Y) { direction: output;
             function: "(A*B)'"; }
  }
  cell(NOR) {
    area: 4;
    pin(A) { direction: input; }
    pin(B) { direction: input; }
    pin(Y) { direction: output;
             function: "(A+B)'"; }
  }
  cell(DFF) {
    area: 18;
    ff(IQ, IQN) { clocked_on: C;
                  next_state: D; }
    pin(C) { direction: input;
                 clock: true; }
    pin(D) { direction: input; }
    pin(Q) { direction: output;
              function: "IQ"; }
  }
}
```
<!-- 将上述内容保存到文件`cell.lib`, 它以文本方式描述了标准单元的属性.
上述文件包含如下属性:
* 单元的面积(area), 一般以$um^2$为单位
* 端口(pin), 其中又标识了方向(direction);
  特别地, 输出端口还包含功能(function)属性, 通过逻辑表达式给出;
  对于触发器的时钟输入端口, 还包含时钟(clock)属性, 用于标识该端口为时钟信号

在yosys中, 工艺映射的过程分两步.
首先通过如下命令对时序逻辑单元进行工艺映射: -->
Save the above content to the file `cell.lib`, which describes the properties of standard cells in text format. The above file contains the following properties:
* The area of the cell, generally in $um^2$ 
* Pins, which also indicate the direction;
In particular, output pins also contain a function attribute, given by a logical expression;
For the clock input pin of a flip-flop, it also contains a clock attribute to identify that the pin is a clock signal.

In Yosys, the technology mapping process is divided into two steps. First, perform technology mapping for sequential logic cells using the following command:
```
yosys> dfflibmap -liberty cell.lib
```
<!-- 执行上述命令后查看结构图, 你会发现在细粒度表示中,
门级单元``$_SDFFE_PP0P_``被替换成`DFF`和一些``$_MUX_``,
其中`DFF`就是标准单元库`cell.lib`中的标准单元.
之所以这一步骤会产生额外的``$_MUX_``,
是因为`cell.lib`中没有与``$_SDFFE_PP0P_``功能完全等价的标准单元: 查阅yosys手册发现,
``$_SDFFE_PP0P_``的功能是"带高有效同步复位信号和高有效使能信号的正边沿D触发器",
但`cell.lib`中仅有的时序逻辑单元`DFF`只是一个简单的D触发器,
因此需要引入一些额外的组合逻辑单元来实现"高有效同步复位信号"和"高有效使能信号"的功能.

不过你会发现, `DFF`单元的输出端`Q`在结构图中出现在代表输入端的左侧,
这是因为`cell.lib`对yosys来说属于外部单元库,
`show`命名默认没有关于`DFF`这个标准单元的信息.
为了修复这个问题, 我们可以让yosys先读入`cell.lib`这个标准单元库: -->
After executing the above command and viewing the structure diagram, you will notice that in the fine-grain representation, the gate-level cell ``$_SDFFE_PP0P_`` has been replaced with `DFF` and several ``$_MUX_`` cells, where `DFF` is the standard cell from the standard cell library `cell.lib`.
The reason why this step generates additional ``$_MUX_`` cells is that there is no standard cell in `cell.lib` that is fully functionally equivalent to ``$_SDFFE_PP0P_``. According to the Yosys manual, the function of ``$_SDFFE_PP0P_`` is "a positive-edge D flip-flop with an active-high synchronous reset signal and an active-high enable signal". However, the only sequential logic cell `DFF` in `cell.lib` is just a simple D flip-flop. Therefore, some additional combinational logic cells need to be introduced to implement the functions of "active-high synchronous reset signal" and "active-high enable signal".

However, you will find that the output pin `Q` of the `DFF` cell appears on the left side (which represents the input side) in the structure diagram. This is because `cell.lib` is an external cell library for Yosys, and the `show` command does not have information about the `DFF` standard cell by default. To fix this issue, we can let Yosys read the `cell.lib` standard cell library first:
```
yosys> read_liberty -lib cell.lib
```
<!-- 成功读入后, 再执行`show`命令, 即可修复该问题. -->
After a successful read-in, executing the `show` command again will resolve this issue.

<!-- > #### todo::查看结构图(5)
> 通过`show`命令查看当前的结构图, 对比执行`dfflibmap`命令前后的不同.

接下来通过如下命令对组合逻辑单元进行工艺映射: -->
> #### todo::View Structure Diagram (5)
> Use the `show` command to view the current structure diagram and compare the differences before and after executing the `dfflibmap` command.

Next, perform technology mapping for combinational logic cells using the following command:
```
yosys> abc -liberty cell.lib
```
<!-- `abc`命名将会调用一个外部工具`ABC`来进行组合逻辑单元的工艺映射工作.
所有门级单元都被替换成标准单元库`cell.lib`中的标准单元.
最后通过`clean`命令清除无用的单元和连线, 就得到了最终的网表,
从而完成从RTL代码到网表的转换. -->
The `abc` command will invoke an external tool `ABC` to perform technology mapping for combinational logic cells.
All gate-level cells will be replaced with standard cells from the standard cell library `cell.lib`.
Finally, use the `clean` command to remove unused cells and connections, and the final netlist will be obtained, thus completing the conversion from RTL code to netlist.

<!-- > #### todo::查看结构图(6)
> 通过`show`命令查看当前的结构图, 对比执行`abc`命令前后的不同.

> #### comment::工艺映射和yosys的techmap命令
> 在之前的细粒度综合阶段, 我们介绍了yosys的`techmap`命令,
> 它其实也是Technology Mapping的缩写.
> yosys官方手册对Technology Mapping的说明分两步:
> 第一步是将字级单元映射到门级单元,
> 第二步是将门级单元映射到目标工艺的标准单元.
>
> 这其实和讲义中介绍的工艺映射概念有所不同:
> 讲义对工艺映射的理解更多是强调"从抽象到具体".
> 为了与行业概念保持一致, 我们没有采用yosys官方手册中对工艺映射的理解.
> 因此, yosys官方手册中描述的"工艺映射的第一步", 其实对应讲义中的"细粒度综合";
> 而yosys官方手册中描述的"工艺映射的第二步", 其实对应讲义中的"工艺映射". -->
> #### todo::View Structure Diagram (6)
> Use the `show` command to view the current structure diagram and compare the differences before and after executing the abc command.

> #### comment::Technology Mapping and Yosys's techmap Command
> In the previous fine-grain synthesis stage, we introduced Yosys's `techmap` command, which is actually an abbreviation of "Technology Mapping".
The Yosys official manual describes Technology Mapping in two steps:
The first step is to map word-level cells to gate-level cells,
and the second step is to map gate-level cells to standard cells of the target technology.
>
> This is actually different from the concept of technology mapping introduced in the lecture notes:
The lecture notes understand technology mapping more as emphasizing "from abstraction to concreteness".
To align with industry concepts, we do not adopt the understanding of technology mapping in the Yosys official manual.
Therefore, what the official Yosys manual describes as "the first step of technology mapping" actually corresponds to "fine-grain synthesis" in the lecture notes;
and what the official Yosys manual describes as "the second step of technology mapping" actually corresponds to "technology mapping" in the lecture notes.

<!-- ### 网表和报告生成

最后, 通过``write_verilog``命令将网表写入到文件,
并通过`stat`命令输出所用标准单元的信息: -->
### Netlist and Report Generation

Finally, write the netlist to a file using the ``write_verilog`` command, and output information about the standard cells used via the `stat` command:
```
yosys> write_verilog netlist.v
yosys> stat -liberty cell.lib
```

<!-- > #### todo::通过yosys的日志文件了解综合过程
> 你已经对流水灯项目进行综合了.
> 尝试查看`yosys-sta/result`目录下的yosys日志文件, 结合上述文字了解综合过程.
>
> 为了避免反复键入yosys的命令, `make syn`通过脚本驱动yosys进行综合,
> 具体可查阅`yosys-sta/scripts/yosys.tcl`.
> 如果你想进一步了解yosys的命令, 可以查阅yosys的官方手册,
> 或者在yosys的命令行中输入`help xxx`来查看`xxx`命令的相关信息. -->
> #### todo::Understand the Synthesis Process through Yosys Log Files
> You have already synthesized the running light project.
Try to view the Yosys log files in the `yosys-sta/result` directory and understand the synthesis process in combination with the above text.
To avoid repeatedly typing Yosys commands, `make syn` drives Yosys to perform synthesis through a script. For details, you can refer to `yosys-sta/scripts/yosys.tcl`.
If you want to further learn about Yosys commands, you can consult the Yosys official manual, or enter `help xxx` in the Yosys command line to view information about the `xxx` command.

<!-- ### Verilog的RTL综合语义

将什么样的RTL转换成什么样的标准单元, 需要考虑RTL综合的语义.
但Verilog标准手册定义的是Verilog的仿真语义, 因此不适用于RTL综合这一场景.
为此, [Verilog RTL综合标准手册][verilog rtl synthesis manual]专门描述了Verilog语言在综合场景下的语义.
综合器读入Verilog代码, 然后根据这一标准手册所描述的语义,
将Verilog代码转换成语义等价的标准单元. -->
### RTL Synthesis Semantics of Verilog

When converting a certain type of RTL to a specific type of standard cells, the semantics of RTL synthesis must be considered. However, the Verilog standard manual defines the simulation semantics of Verilog, which is not applicable to the scenario of RTL synthesis. For this reason, the [Verilog RTL Synthesis Standard Manual][verilog rtl synthesis manual] specifically describes the semantics of the Verilog language in the synthesis scenario.
The synthesizer reads the Verilog code and then converts the Verilog code into semantically equivalent standard cells in accordance with the semantics described in this standard manual.

[verilog rtl synthesis manual]: https://0x04.net/~mwk/vstd/ieee-1364.1-2002.pdf

Verilog RTL综合标准手册的第1.1节介绍了RTL综合的背景:
```
This standard defines a set of modeling rules for writing Verilog® HDL descriptions
for synthesis. Adherence to these rules guarantees the interoperability of Verilog
HDL descriptions between register-transfer level synthesis tools that comply to this
standard. The standard defines how the semantics of Verilog HDL are used, for
example, to describe level- and edge-sensitive logic. It also describes the syntax
of the language with reference to what shall be supported and what shall not be
supported for interoperability.

Use of this standard will enhance the portability of Verilog-HDL-based designs
across synthesis tools conforming to this standard. In addition, it will minimize
the potential for functional mismatch that may occur between the RTL model and the
synthesized netlist.
```
<!-- 一些关键的信息包括:
* 这份标准描述了Verilog语法中哪些综合器需要支持的, 哪些是综合器不支持的.
  这说明, 综合器支持的Verilog语法, 只是Verilog整体语法中的一个子集.
* 采用这份标准可以提升Verilog设计在不同综合器之间的可移植性,
  从而让符合标准的综合器能按一致的语义来解析符合标准的Verilog代码.
* 采用这份标准也可以尽可能避免RTL模型和综合网表之间功能不一致的潜在风险. -->
Some key pieces of information include:
* This standard specifies which parts of the Verilog syntax need to be supported by synthesizers and which do not. This indicates that the Verilog syntax supported by synthesizers is only a subset of the overall Verilog syntax.
* Adopting this standard can improve the portability of Verilog designs across different synthesizers, enabling compliant synthesizers to parse compliant Verilog code with consistent semantics.
* Using this standard can also help minimize the potential risk of functional inconsistencies between the RTL model and the synthesized netlist.

> #### todo::RTFM
> Read Chapter 5 `Modeling hardware elements` of the Verilog RTL Synthesis Standard Manual to understand what kind of Verilog code is synthesized into what kind of circuit.
>
> This section is only about 10 pages long, but it is more authoritative than all other Verilog learning materials. It also provides a large number of code examples and explanations, even detailing the scenarios where `x` and `z` are synthesizable.
>
> In fact, some of the coding suggestions put forward by Professor Xia Yuwen in his book mentioned above are based on the specifications of the Verilog RTL Synthesis Standard Manual.

Since the semantics of simulation and synthesis are not completely consistent, there may be cases where the same Verilog code behaves inconsistently in simulation and synthesis scenarios. In the chip design flow, both simulation and synthesis are essential steps. Moreover, considering physical design and manufacturing, the behavior of the Verilog code we design should be based on synthesis. This requires us to avoid writing code that behaves inconsistently in simulation and synthesis scenarios.

Appendix B `Functional mismatches` of the Verilog RTL Synthesis Standard Manual describes some scenarios where such problems occur. Section `B.1` mentions uncertain behaviors, with examples as follows:
<!-- > 阅读Verilog RTL综合标准手册的第5章`Modeling hardware elements`,
> 了解什么样的Verilog代码被综合成什么样的电路.
>
> 这部分内容只有10页左右, 但比其他所有Verilog学习资料都要权威,
> 而且提供了大量的代码示例和说明,
> 甚至连`x`和`z`在哪些使用场景下是可综合, 都有详细的说明.
>
> 事实上, 上文提到夏宇闻老师在书中提出的若干编码建议,
> 其中有一些建议就是依据Verilog RTL综合标准手册的规范提出的.

由于仿真和综合的语义不完全一致,
因此可能会出现同一份Verilog代码在仿真和综合这两个场景下行为不一致的问题.
在芯片设计的流程中, 仿真和综合都是必须的步骤,
而且考虑到物理设计和制造, 我们设计的Verilog代码的行为需要以综合为准.
这要求我们需要避免编写出在仿真和综合这两个场景下行为不一致的代码.

Verilog RTL综合标准手册的附录B`Functional mismatches`描述了一些发生这种问题的场景.
其中`B.1`小节提到的就是不确定性的行为, 举例如下: -->
```verilog
always @(posedge clock) begin
  a = 0;
  a = 1;
end

always @(posedge clock)
  b = a;
```

<!-- > #### todo::用事件模型分析Verilog代码的行为(4)
> 尝试用事件模型分析上述代码为什么存在数据竞争.

在这个例子中, 综合器可以自由选择将`0`或`1`作为触发器`b`的输入.
但不管如何选择, 由于数据竞争的存在, 综合网表的行为都可能与仿真结果不一致.

> #### todo::RTFM(2)
> 阅读Verilog RTL综合标准手册的附录B,
> 了解还有哪些情况会造成综合网表和仿真行为的功能不匹配.

> #### hint::Chisel福利
> 如果你打算选择Chisel语言来设计电路,
> 你不必考虑上文提到的数据竞争和功能不匹配的问题,
> 因为Chisel语言的语义保证了生成的Verilog代码不存在这些问题. -->
> #### todo::Analyze the Behavior of Verilog Code Using Event Model (4)
> Try to analyze why there is a data race in the above code using the event model.

In this example, the synthesizer is free to choose either `0` or `1` as the input to the flip-flop `b`. However, regardless of the choice, due to the existence of data races, the behavior of the synthesized netlist may be inconsistent with the simulation results.

> #### todo::RTFM (2)
> Read Appendix B of the Verilog RTL Synthesis Standard Manual to understand other situations that may cause functional mismatches between the synthesized netlist and simulation behavior.

> #### hint::Chisel Benefits
> If you plan to use the Chisel language for circuit design, you don't need to consider the data races and functional mismatches mentioned above, because the semantics of the Chisel language ensure that the generated Verilog code is free from these issues.

## Evaluating Circuits with Open-Source EDA Tools

Since the standard cells in the netlist are manufacturable and have various attributes, we can conduct a preliminary evaluation of the circuit's quality after obtaining the netlist. There are multiple dimensions to measure the quality of a circuit, with three commonly used ones being performance, power consumption, and area, collectively referred to as PPA (Performance, Power, Area).

### Area Evaluation

The simplest is area evaluation. The `.lib` file already provides the area attributes of standard cells. The synthesizer only needs to count the number of instantiations of each standard cell in the netlist to calculate the total area of the current design.

### Performance Evaluation

The performance of a circuit is mainly measured by frequency, that is, "how many times the circuit can work at most per second". This is determined by "the minimum time required to complete one work cycle". We define "one work cycle" as "the sequential logic elements updating their states under the drive of the clock signal". Since these indicators are related to time, the process of analyzing them is also called timing analysis.

Recalling the state machine model of digital circuits, sequential logic elements update their states when the clock signal arrives. The "state" here is essentially data, which needs to be calculated through combinational logic. However, the calculation of combinational logic requires a certain delay. Therefore, we need to control the clock frequency so that the interval between two clocks (i.e., the period) can sufficiently accommodate the delay of the combinational logic; otherwise, the data signal used to update the state will not be the stable result calculated by the combinational logic, and thus the behavior of the circuit during operation will not match our design expectations.
<!-- ## 用开源EDA工具评估电路

由于网表中的标准单元是可制造的, 它具备各种属性,
因此在得到网表后, 我们就可以对电路的好坏进行初步评估了.
衡量一个电路的好坏有多个维度, 常用的三个维度分别是性能, 功耗, 面积,
它们统称为PPA(Performance, Power, Area).

### 面积评估

最简单的是面积评估. `.lib`文件已经给出了标准单元的面积属性,
综合器只需要统计出每个标准单元在网表中实例化的次数,
即可计算出当前设计的总面积.

### 性能评估

一个电路的性能主要通过频率来衡量, 也即"电路每秒最多能工作多少次".
这又是由"完成一次工作最少需要花多少时间"来决定的.
我们将"一次工作"定义为"时序逻辑元件在时钟信号的驱动下更新状态".
因为这些指标和时间相关, 因此分析它们的过程也称为时序分析(timing analysis).

回顾数字电路的状态机模型, 时序逻辑元件会在时钟信号到来时更新其状态.
这里的"状态"本质上也是数据, 需要通过组合逻辑计算得到.
但组合逻辑的计算需要经过一定的延迟, 因此我们需要控制好时钟的频率,
使得两次时钟之间的间隔(也即周期)能足够容纳组合逻辑的延迟;
否则, 用于更新状态的数据信号并不是由组合逻辑计算出的稳定结果,
这样电路工作时的行为就与我们设计的预期不符. -->

```
    +------------------+
+-->| Sequential Logic |----+
|   +------------------+    |
| next state                | current state
|                           |
|  +---------------------+  |
+--| Combinational Logic |<-+
   +---------------------+
```

<!-- 因此, 评估电路的性能, 就是通过评估电路中组合逻辑的延迟,
来推算出电路可以工作的最高频率.
如果电路的实际工作频率高于这个最高频率,
电路中的某些时序逻辑所更新的结果将与我们设计的预期不符,
从而无法让电路按照预期开展工作. -->
Therefore, evaluating the performance of a circuit involves extrapolating the maximum operating frequency the circuit can achieve by assessing the delay of combinational logic within it. If the actual operating frequency of the circuit exceeds this maximum frequency, the results updated by some sequential logic in the circuit will not match our design expectations, making it impossible for the circuit to function as intended.

<!-- > #### comment::更快的代价
> 有一些电子发烧友会尝试对处理器进行超频,
> 让处理器运行在比厂商所宣称的最高频率更高的频率,
> 从而尝试获得更好的计算机使用体验.
> 不过, 如果超频失败, 计算机将会进入不稳定状态, 运行一段时间后可能会卡死.
>
> 卡死的本质原因其实和上文的介绍一样:
> 由于处理器工作得太快, 其中某些时序逻辑单元没有按照预期的数据进行更新,
> 最终造成处理器进入错误的状态. -->
> #### comment::The Cost of Faster Speeds
> Some electronics enthusiasts attempt to overclock their processors, making them run at a higher frequency than the maximum frequency claimed by the manufacturer, in an attempt to get a better computer user experience. However, if overclocking fails, the computer will enter an unstable state and may freeze after running for a period of time.
>
> The essential reason for the freeze is actually the same as what was introduced above: because the processor is working too fast, some of its sequential logic units are not updated with the expected data, eventually causing the processor to enter an incorrect state.

There are numerous combinational logic elements in a circuit, and the operating frequency of the circuit is limited by the combinational logic path with the longest delay in the circuit. This path is called the "critical path" of the circuit.
To find the critical path in a circuit, EDA tools need to read the delay information of standard cells from the standard cell library, then analyze the synthesized netlist, and calculate the total delay of all standard cells on the combinational logic paths. The path with the longest total delay is the critical path of the circuit.
This evaluation process can be carried out based on the netlist and the delay information of the standard cell library, and it does not involve the actual operation process of the circuit. Therefore, it is called Static Timing Analysis (STA). It should be noted that the aforementioned `cell.lib` is only a simple example and does not contain delay information, so it cannot be used for static timing analysis.

However, the standard cell library in nangate45 provides complete standard cell delay information. In the `yosys-sta` project, executing the `make sta` command allows you to evaluate the performance of the RTL design on nangate45. Specifically, this command first calls the synthesizer Yosys to synthesize the RTL design to obtain a netlist of nangate45 standard cells. Then, it invokes the netlist optimization tool iNO to insert buffers into the netlist to optimize the performance of the netlist. Finally, the optimized netlist file and the standard cell information file in the PDK are input into the [open-source static timing analysis tool iSTA][ista]. iSTA will quickly evaluate the path delays in the RTL design and report several paths that have the largest gap from the target frequency for users' reference.
<!-- 电路中的组合逻辑有很多, 而电路的工作频率受限于电路中延迟最长的一条组合逻辑路径,
这条路径称为电路的"关键路径"(critical path).
为了找到电路中的关键路径, EDA工具需要从标准单元库中读出标准单元的延迟信息,
然后对综合出的网表进行分析, 计算出组合逻辑路径上所有标准单元的总延迟,
总延迟最长的路径即为电路的关键路径.
这个评估过程可以基于网表和标准单元库的延迟信息来开展,
不涉及电路工作的过程, 因此称为静态时序分析(STA, Static Timing Analysis).
需要说明的是, 上文的`cell.lib`只是一个简单的实例,
其中未包含延迟信息, 因此无法用于静态时序分析.

不过, nangate45中的标准单元库已经提供了完整的标准单元延迟信息.
在`yosys-sta`项目中执行`make sta`命令, 就可以在nangate45上评估RTL设计的性能.
具体地, 该命令首先调用综合器yosys对RTL设计进行综合, 得到nangate45标准单元的网表;
然后调用网表优化工具iNO工具在网表中插入缓冲器, 对网表的性能进行优化;
最后将优化后的网表文件和PDK中的标准单元信息文件输入到[开源静态时序分析工具iSTA][ista]中,
iSTA将快速评估RTL设计中的路径延迟, 并报告距离目标频率差距最大的若干条路径供用户参考. -->

<!-- > #### todo::评估电路的性能
> 尝试通过`yosys-sta`项目评估电路的性能,
> 并阅读静态时序分析的报告, 了解目标电路能运行的最大频率.
>
> 目前我们不要求你了解报告中的所有细节, 我们会在B阶段介绍更多STA的内容.
> 如果你现在对报告的细节感兴趣, 可以参考[这个教程][ista-tutorial],
> 或者在上网查询时序报告的阅读教程. 其他工具也可以生成时序报告,
> 虽然格式可能有所不同, 但其中的大部分概念是相通的. -->
> #### todo::Evaluate Circuit Performance
> Try to evaluate the circuit's performance through the `yosys-sta` project, and read the static timing analysis report to understand the maximum frequency at which the target circuit can operate.
>
> Currently, we do not require you to understand all the details in the report; we will cover more STA content in B Stage.
If you are interested in the details of the report now, you can refer to [this tutorial][ista-tutorial] or search online for tutorials on reading timing reports. Other tools can also generate timing reports, and although the formats may vary, most of the concepts in them are common.

[ista]: https://github.com/OSCC-Project/iEDA/tree/master/src/operation/iSTA
[ista-tutorial]: https://ieda.oscc.cc/tools/ieda-tools/ista.html

<!-- > #### danger::评估过程中遇到问题
> 如果在运行时遇到bug，可到`yosys-sta`仓库的Issue中报告问题，并提供如下信息：
> * 相应的RTL设计
> * sdc文件
> * yosys生成的网表文件
> * iEDA的版本号, 可通过命令`echo exit | ./bin/iEDA -v`获取 -->
> #### danger::Issues Encountered During Evaluation
> If you encounter bugs during runtime, you can report the problem in the Issues section of the `yosys-sta` repository and provide the following information:
> * The corresponding RTL design
> * SDC file
> * Netlist file generated by Yosys
> * Version number of iEDA, which can be obtained via the command `echo exit | ./bin/iEDA -v`

<!-- 事实上, 上述方式得到的时序报告并不能完全反映芯片流片时的频率.
这是因为, 网表中只包含标准单元及其拓扑信息, 并未包含标准单元的物理位置信息.
可以想象, 如果两个标准单元在物理位置上距离较远,
在它们之间传输的信号也需要经过一定的延迟才能到达,
这种延迟称为线延迟(net delay). 而标准单元库中标准单元的延迟属性,
只能反映出信号经过标准单元本身的延迟, 这种延迟称为逻辑延迟(logic delay).
完整的延迟信息应该由逻辑延迟和线延迟共同构成.
也就是说, 上述评估方式得到的频率, 只是基于逻辑延迟得到的.
只有等到EDA工具完成布局布线工作后, 才能获取准确的线延迟信息,
从而评估出更接近流片场景的频率信息. -->
In fact, the timing report obtained through the above method cannot fully reflect the frequency of the chip during tape-out. This is because the netlist only contains information about standard cells and their topology, but not the physical location information of the standard cells. It is conceivable that if two standard cells are far apart in physical location, the signal transmitted between them will also take a certain delay to arrive, which is called net delay. The delay attribute of standard cells in the standard cell library can only reflect the delay of signals passing through the standard cells themselves, which is called logic delay. Complete delay information should consist of both logic delay and net delay. That is to say, the frequency obtained by the above evaluation method is only based on logic delay. Only after the EDA tool completes the placement and routing work can accurate net delay information be obtained, thereby evaluating the frequency information that is closer to the tape-out scenario.

<!-- 那么, 当前得到的频率信息, 是否毫无意义呢? 并不是.
一方面, 开展物理设计工作也需要一定的时间,
对于复杂的高性能处理器, 甚至需要数天时间才能完成一轮物理设计工作.
显然, 为了获得更准确的延迟和频率信息,
设计团队需要付出更多时间, 这会影响项目迭代的效率.
另一方面, 逻辑延迟虽然不能代表最终的延迟信息,
但它已经给出了频率的上限, 同时也已经能反映出RTL逻辑设计阶段的某些问题, 如电路逻辑过于复杂.
这些信息已经足够帮助RTL设计者对RTL设计进行初步评估, 从而进行快速迭代优化.
我们将在B阶段进一步介绍优化的方法. -->
Then, is the frequency information obtained currently completely meaningless? Not at all.
On one hand, conducting physical design work also takes a certain amount of time. For complex high-performance processors, it may even take several days to complete one round of physical design. Obviously, in order to obtain more accurate delay and frequency information, the design team needs to invest more time, which will affect the efficiency of project iterations.
On the other hand, although logic delay cannot represent the final delay information, it has already given the upper limit of the frequency. At the same time, it can also reflect some problems in the RTL logic design stage, such as overly complex circuit logic. This information is sufficient to help RTL designers conduct a preliminary evaluation of the RTL design, thereby enabling rapid iterative optimization. We will further introduce optimization methods in B Stage.

<!-- 特别地, 对于处理器来说, 频率并不是衡量其性能的唯一因素.
频率的另一种理解是每秒工作了多少个周期, 但不一定每个周期都有"实质性的工作".
处理器的本分工作是执行程序, 因此对于处理器来说, 性能应该解读为"执行程序的效率".
更具体地, 处理器执行的是程序中的指令,
如果处理器的频率很高, 但要过很久才执行一条指令,
那么整体上来看也算不上一个优秀的处理器.
因此, 还需要通过另一个指标来衡量处理器执行指令的效率,
这个常用的指标称为IPC(Instruction Per Cycle),
它用来衡量处理器每周期执行的平均指令数.
我们将在B阶段进一步讨论IPC的测量和优化方法. -->
In particular, for a processor, frequency is not the sole factor in measuring its performance. Another way to understand frequency is the number of cycles it operates per second, but not every cycle necessarily involves "substantial work." The fundamental task of a processor is to execute programs; therefore, for a processor, performance should be interpreted as "the efficiency of program execution." More specifically, a processor executes instructions within a program. If a processor has a high frequency but takes a long time to execute a single instruction, it cannot be considered an excellent processor overall.
Thus, another metric is needed to measure the efficiency with which a processor executes instructions. A commonly used metric for this is IPC (Instructions Per Cycle), which quantifies the average number of instructions a processor executes per cycle. We will further discuss methods for measuring and optimizing IPC in B Stage.

<!-- ### 功耗评估

要评估电路的功耗, 就是要评估电路中所有标准单元的功耗之和.
EDA工具需要从标准单元库中读出标准单元的功耗信息,
计算出每个标准单元的功耗, 从而计算出电路的总功耗.
和延迟的评估类似, 上文的cell.lib只是一个简单的实例,
其中未包含功耗信息, 因此无法用于功耗分析.

同样地, nangate45中的标准单元库已经提供了完整的标准单元功耗信息.
在`yosys-sta`项目中执行`make sta`命令, 除了可以评估RTL设计的性能, 也能评估其功耗:
iSTA将快速评估并报告RTL设计中每个标准单元的功耗和总功耗. -->
### Power Consumption Evaluation

To evaluate the power consumption of a circuit, we need to assess the sum of the power consumption of all standard cells in the circuit. EDA tools need to read the power consumption information of standard cells from the standard cell library, calculate the power consumption of each standard cell, and thus compute the total power consumption of the circuit.
Similar to delay evaluation, the aforementioned cell.lib is only a simple example and does not contain power consumption information, so it cannot be used for power consumption analysis.

Likewise, the standard cell library in nangate45 provides complete power consumption information for standard cells. Executing the `make sta` command in the `yosys-sta` project can evaluate not only the performance of the RTL design but also its power consumption: iSTA will quickly evaluate and report the power consumption of each standard cell and the total power consumption in the RTL design.

> #### todo::Evaluate Circuit Power Consumption
> Try to evaluate the circuit's performance through the `yosys-sta` project and read the power consumption analysis report to understand the power consumption information of the target circuit.

The power consumption report includes three types of power consumption:
* `Internal Power` refers to internal power consumption. When transistors switch states, nMOS and pMOS do not transition instantaneously. Therefore, for a brief moment, both nMOS and pMOS are conducting simultaneously, creating a short circuit path from the power supply to the ground. The power consumed by this current is known as internal power consumption, also called short-circuit power. Internal power is part of dynamic power.
* `Switch Power` is the power consumed during state transitions. When a CMOS circuit switches between `0` and `1`, it needs to charge or discharge the equivalent capacitance. The power consumed in this process is called switching power. Switching power is also part of dynamic power, meaning dynamic power consists of both internal power and switching power.
* `Leakage Power` is leakage power consumption. Ideally, no current flows between the source and drain of a transistor when it is in the off state. In reality, however, various factors cause a small amount of current, known as leakage current, to flow between the source and drain. The power consumed by this leakage current is called leakage power. Since leakage power exists even when transistors are not switching, it is also referred to as static power.
<!-- > #### todo::评估电路的功耗
> 尝试通过`yosys-sta`项目评估电路的性能,
> 并阅读功耗分析的报告, 了解目标电路的功耗信息.

功耗报告中报告了三类功耗, 其中:
* `Internal Power`是内部功耗.
  在晶体管翻转时, 由于nMOS和pMOS并非瞬间就完成状态切换,
  因此在一段很短的时间内, nMOS和pMOS会同时处于导通状态,
  导致形成了从电源端到地端的短路电路,
  这部分电流所产生的功耗就是内部功耗, 也称短路功耗.
  内部功耗属于动态功耗(dynamic power)的一部分.
* `Switch Power`是翻转功耗.
  CMOS电路翻转时, 为了完成从`0`到`1`或从`1`到`0`的变化,
  需要对相应的等效电容进行充电或放电,
  这个过程产生的功耗就是翻转功耗, 也称开关功耗.
  翻转功耗也属于动态功耗的一部分,
  也即, 动态功耗由内部功耗和翻转功耗两部分组成.
* `Leakage Power`是漏电功耗.
  在理想情况下, 晶体管处于截止状态时, 源极和漏极之间没有任何电流通过.
  但实际上并非如此, 真正的晶体管会因为多种原因,
  导致在源极和漏极之间存在一定的微小电流, 称为漏电电流(leakage current).
  由漏电电流形成的功耗就是漏电功耗.
  由于漏电功耗在晶体管不翻转时也会存在, 因此也称为静态功耗. -->

<!-- 特别地, 在目前的报告中, 翻转功耗都是`0`.
这是因为评估翻转功耗需要先计算出相应的等效电容,
而等效电容不仅和标准单元本身有关, 也和走线的拓扑和长度相关.
进一步地, 要得到走线的拓扑和长度, 需要先完成后端物理设计的一系列步骤.
`yosys-sta`没有开展这些步骤, 因此无法计算出等效电容, 从而无法评估翻转功耗.
我们会在B阶段介绍更多功耗相关的内容. -->
In particular, in the current report, the switching power is always `0`. This is because evaluating switching power requires first calculating the corresponding equivalent capacitance, and the equivalent capacitance is related not only to the standard cells themselves but also to the topology and length of the interconnects. Furthermore, to obtain the topology and length of the interconnects, a series of backend physical design steps must be completed first. Since `yosys-sta` does not perform these steps, it cannot calculate the equivalent capacitance and thus cannot evaluate the switching power. We will cover more content related to power consumption in B Stage.

<!-- > #### comment::开源EDA工具的局限性
> 当然, `yosys-sta`这一评估项目也不是完美的, 至少从目前来说有以下缺陷:
> * yosys的综合质量不高, 和商业综合器相比还存在一定的差距
> * nangate45是一个面向学术研究的PDK, 其中标准单元的数量和质量也与商业PDK有一定差距
> * nangate45不能用于流片, 没有工厂将其用于产线中
>
> 不过, 在综合后时序评估这一场景中, 上述缺陷不会造成明显的影响:
> 即使yosys的综合质量不高, 我们也可以通过综合结果的相对提升, 来指导RTL优化的方向. -->
> #### comment::Limitations of Open-Source EDA Tools
> Of course, the `yosys-sta` evaluation project is not perfect. At least for now, it has the following drawbacks:
> * The synthesis quality of Yosys is not high, and there is still a certain gap compared with commercial synthesizers.
> * Nangate45 is a PDK oriented to academic research, and the quantity and quality of standard cells in it also have a certain gap with commercial PDKs.
> * Nangate45 cannot be used for tape-out, and no factory uses it in production lines.
> 
> However, in the scenario of timing evaluation after synthesis, the above defects will not cause obvious impact: even if the synthesis quality of Yosys is not high, we can guide the direction of RTL optimization through the relative improvement of synthesis results.

<!-- > #### comment::所以学习"一生一芯"还需要FPGA吗?
> 基本上不需要了:
> * 从准确度来说, yosys的综合流程是面向ASIC设计的, 相比于FPGA流程, 其原理和报告的准确度都更适合"一生一芯".
> * 从时间来说, FPGA的主要作用是仿真加速, 也就是说,
>   如果仿真任务并不需要花费很长时间来完成, 使用FPGA的优势并不明显.
>   事实上, 从两者的完整流程来看, 当以下不等式成立时, FPGA的优势才能体现出来:
>   $$T_{FPGA.syn} + T_{FPGA.impl} + T_{FPGA.run} < T_{Sim.compile} + T_{Sim.run}$$
>   其中, $T_{FPGA.syn} + T_{FPGA.impl}$通常达到小时量级,
>   而$T_{Sim.compile}$通常能在数分钟内完成,
>   因此, 只有当$T_{Sim.run}$达到小时量级, 上述不等式才有可能成立.
>   不过在"一生一芯"的学习中, 你很难遇到需要小时量级的时间才能完成的仿真任务.
>   而当你遇到这样的任务时, 我们也会对FPGA的评估过程提出更高的要求.
>   我们会在B阶段中继续讨论这个问题.
> * 从调试难度来说, FPGA的调试手段很有限, 只能在时间和空间均受限的条件下抓取底层的波形信息;
>   相反, 软件仿真则灵活很多, 我们可以借助很多软件方法来从多方面提升调试的效率. -->
> #### comment::So is an FPGA still needed for learning "OSOC"?
> Basically, it's not necessary anymore:
> * In terms of accuracy, Yosys' synthesis flow is oriented towards ASIC design. Compared with the FPGA flow, its principles and the accuracy of reports are more suitable for "OSOC".
> * In terms of time, the main role of FPGA is simulation acceleration. That is to say, if the simulation task does not take a long time to complete, the advantage of using FPGA is not obvious. In fact, from the perspective of the complete processes of both, the advantage of FPGA can only be reflected when the following inequality holds:
> $$T_{FPGA.syn} + T_{FPGA.impl} + T_{FPGA.run} < T_{Sim.compile} + T_{Sim.run}$$
> * Among them, $T_{FPGA.syn} + T_{FPGA.impl}$ usually reaches the order of hours, while $T_{Sim.compile}$ can usually be completed within a few minutes. Therefore, the above inequality can only hold when $T_{Sim.run}$ reaches the order of hours. However, in the study of "OSOC", it is difficult for you to encounter simulation tasks that take hours to complete. And when you encounter such tasks, we will also put forward higher requirements for the FPGA evaluation process. We will continue to discuss this issue in B Stage.
> * In terms of debugging difficulty, FPGA's debugging methods are very limited, and you can only capture underlying waveform information under the constraints of both time and space; on the contrary, software simulation is much more flexible, and we can use many software methods to improve debugging efficiency in various aspects.

<!-- ## PDK和标准单元库

我们刚才提到的`cell.lib`只是一个标准单元库的简单示例.
现在我们来介绍nangate45这个PDK.
你对流水灯项目进行综合的时候, 已经接触过nangate45了.
具体地, 你可以在`yosys-sta/result`目录下找到综合后的网表文件,
网表文件中实例化的都是nangate45的标准单元. -->
## PDK and Standard Cell Library

The `cell.lib` we mentioned earlier is just a simple example of a standard cell library. Now let's introduce the nangate45 PDK. You have already come into contact with nangate45 when synthesizing the Running light project. Specifically, you can find the synthesized netlist file in the `yosys-sta/result` directory, and the instantiated cells in the netlist file are all standard cells from nangate45.

<!-- ### PDK的内容

如上文所述, PDK包含了特定工艺节点下的器件模型, 设计规则,
工艺约束, 验证文件和标准单元库等一系列资源.
而标准单元库是标准单元及其属性的集合,
这些属性包括逻辑功能, 晶体管结构, 时序, 功耗, 物理大小等信息.
通常, 这些信息分布在PDK的多种文件格式中, 上文提到的`.lib`文件只是其中一种.
以nangate45为例, 其中的文件包括(部分文件未列出): -->
### Content of PDK

As mentioned above, PDK contains a series of resources under a specific process node, such as device models, design rules, process constraints, verification files, and standard cell libraries.
The standard cell library is a collection of standard cells and their attributes, which include information such as logical functions, transistor structures, timing, power consumption, and physical size.
Usually, this information is distributed in various file formats within the PDK, and the `.lib` file mentioned above is just one of them.
Taking nangate45 as an example, its files include (some files are not listed):

<!-- ```
nangate45
├── cdl
│   └── NangateOpenCellLibrary.cdl       # 标准单元的晶体管级信息
├── drc
│   └── FreePDK45.lydrc                  # 可制造芯片需要满足的设计规则
├── gds
│   └── NangateOpenCellLibrary.gds       # 标准单元的物理版图信息
├── lef
│   ├── fakeram45_1024x32.lef
│   ├── NangateOpenCellLibrary.macro.lef # 标准单元的物理几何信息
│   └── NangateOpenCellLibrary.tech.lef  # 工艺相关的设计规范
├── lib
│   ├── fakeram45_1024x32.lib
│   ├── Nangate45_fast.lib
│   ├── Nangate45_slow.lib
│   └── Nangate45_typ.lib                # 标准单元的逻辑功能, 面积, 时序, 功耗等信息
├── sim
│   └── cells.v                          # 标准单元的verilog行为仿真模型
└── verilog
    ├── blackbox.v
    ├── cells_clkgate.v
    └── cells_latch.v
``` -->
```
nangate45
├── cdl
│   └── NangateOpenCellLibrary.cdl       # Transistor-level information of standard cells
├── drc
│   └── FreePDK45.lydrc                  # Design rules that must be satisfied for manufacturable chips
├── gds
│   └── NangateOpenCellLibrary.gds       # Physical layout information of standard cells
├── lef
│   ├── fakeram45_1024x32.lef
│   ├── NangateOpenCellLibrary.macro.lef # Physical geometry information of standard cells
│   └── NangateOpenCellLibrary.tech.lef  # Process-related design specifications
├── lib
│   ├── fakeram45_1024x32.lib
│   ├── Nangate45_fast.lib
│   ├── Nangate45_slow.lib
│   └── Nangate45_typ.lib                # Information such as the logical functions, area, timing, and power consumption of standard cells
├── sim
│   └── cells.v                          # Verilog behavioral simulation models of standard cells
└── verilog
    ├── blackbox.v
    ├── cells_clkgate.v
    └── cells_latch.v
```

<!-- 特别地, 除了`.gds`文件属于二进制文件, 其余文件都是文本文件,
可以直接使用文本编辑器打开并阅读.

在处理器设计的全流程中, 不同的设计阶段会使用不同的文件.
例如, 综合的工艺映射会读入`.lib`文件, 根据标准单元的逻辑功能,
将逻辑上功能等价的子电路映射到相应的标准单元;
进行网表仿真时会读入`.v`文件, 让RTL仿真器进行标准单元级别的仿真,
从而验证仿真后的网表功能符合预期;
布局时需要读入`.lef`文件, 根据标准单元的大小等信息决定每个标准单元的位置. -->
In particular, except for the `.gds` files which are binary files, all other files are text files that can be directly opened and read using a text editor.

In the full flow of processor design, different design stages use different files. For example, the technology mapping in synthesis reads `.lib` files and maps logically equivalent subcircuits to corresponding standard cells based on the logical functions of the standard cells; when performing netlist simulation, `.v` files are read to allow the RTL simulator to conduct standard cell-level simulation, thereby verifying that the function of the simulated netlist meets expectations; during placement, `.lef` files need to be read, and the position of each standard cell is determined according to information such as the size of the standard cells.

<!-- ### 工艺视角的芯片结构

为了方便大家理解PDK中的信息以及后续的物理设计阶段,
我们需要先从工艺视角了解芯片的结构.
在半导体制造中, 芯片的物理结构是分层次的.
例如, 某工艺的芯片侧视图如下图所示: -->
### Chip Structure from a Process Perspective

To facilitate understanding of the information in the PDK and the subsequent physical design stages, we first need to understand the chip structure from a process perspective. In semiconductor manufacturing, the physical structure of a chip is hierarchical. For example, the cross-sectional view of a chip using a certain process is as shown in the following figure:
<!-- ```
---------------------   M7    --+
  | | | | | | | | |             +--- 时钟, 电源
---------------------   M6    --+
  | | | | | | | | |
---------------------   M5    --+
  | | | | | | | | |             +--- 标准单元间的连接
---------------------   M4    --+
  | | | | | | | | |
---------------------   M3    --+
  | | | | | | | | |             |
---------------------   M2      +--- 晶体管间的连接
  | | | | | | | | |             |
---------------------   M1    --+
  | | | | | | | | | <------- 通孔
=====================  多晶硅  --+
+++++++++++++++++++++  绝缘层    +--- 晶体管
ooooooooooooooooooooo  硅衬底  --+
``` -->
```
---------------------   M7    --+
  | | | | | | | | |             +--- Clock, Cower
---------------------   M6    --+
  | | | | | | | | |
---------------------   M5    --+
  | | | | | | | | |             +--- Wiring Between Standard Cells
---------------------   M4    --+
  | | | | | | | | |
---------------------   M3    --+
  | | | | | | | | |             |
---------------------   M2      +--- Wiring between Transistors
  | | | | | | | | |             |
---------------------   M1    --+
  | | | | | | | | | <------- Via
=====================  Poly-silicon        --+
+++++++++++++++++++++  dielectric            +--- Transistors
ooooooooooooooooooooo  Silicon Substrate   --+
```
<!-- 其中, 最底层是硅衬底(silicon substrate), 包含晶体管的源极和漏极;
其上是绝缘层(dielectric), 也称栅氧层, 通常使用二氧化硅作为材料;
再上方是多晶硅层(poly-silicon), 作为晶体管的栅极.
这三层用于实现晶体管的物理结构.

在多晶硅层上方还有多个金属层(metal), 利用其导电性质实现信号的传输,
从而连接不同的晶体管, 实现不同门电路或标准单元的功能.
连接方式有层内连接和跨层连接两种, 前者在同一个金属层内进行走线,
后者通过不同金属层之间的通孔(via)进行连接.
在RTL逻辑设计中各个元件之间的连接关系,
在物理上最终是通过金属层提供的连接功能实现的.

为了区分不同的金属层, 通常对它们进行编号, 编号越大, 层数越高.
不同金属层对其中的走线宽度和距离有不同的要求, 从而充当不同的作用, 如下表所示.
需要补充的是, 根据中学的物理知识, 走线的电阻与横截面积成反比. -->
Among them, the bottom layer is the silicon substrate, which contains the source and drain of the transistors;
On top of it is the dielectric layer, also known as the gate oxide layer, which usually uses silicon dioxide as the material;
Above that is the poly-silicon layer, which serves as the gate of the transistor.
These three layers are used to realize the physical structure of the transistor.

There are multiple metal layers above the poly-silicon layer, which utilize their conductive properties to realize signal transmission, thereby connecting different transistors and achieving the functions of different gate circuits or standard cells.
There are two types of connection methods: intra-layer connection and inter-layer connection. The former involves routing within the same metal layer, while the latter is achieved through vias between different metal layers. The connection relationships between various components in the RTL logic design are ultimately physically realized through the connection function provided by the metal layers.

To distinguish different metal layers, they are usually numbered. The larger the number, the higher the layer.
Different metal layers have different requirements for the width and distance of the traces within them, thus serving different roles, as shown in the following table. It should be added that, according to middle school physics knowledge, the resistance of a trace is inversely proportional to its cross-sectional area.

<!-- | 金属层 | 线宽 | 走线间距 | 走线特性 | 作用  |
|:----:|:--:|:--:|:------------:|:-----:|
| 低层 | 小 | 小 | 电阻大, 传输距离短, 布线密度高   |  连接不同的晶体管, 从而构成门电路和标准单元 |
| 中层 | 中 | 中 | 电阻中, 传输距离中等, 布线密度中 | 连接不同的标准单元, 实现芯片的主要逻辑 |
| 高层 | 大 | 大 | 电阻小, 传输距离长, 布线密度低   | 时钟或电源 | -->
| Metal Layer | Wire Width | Routing Space | Routing Characteristics | role  |
|:----:|:--:|:--:|:------------:|:-----:|
| Lower | Short | Short | High resistance, short transmission distance, high wiring density   |  Connect different transistors to form gate circuits and standard cells |
| Medium | Medium | Medium | Medium resistance, medium transmission distance, medium wiring density | Connect different standard cells to realize the main logic of the chip |
| Higher | Wide | Wide | Low resistance, long transmission distance, low wiring density   | Clock or power |

<!-- 对于不同的制造工艺, 其金属层数量可能不同.
例如, 上图的工艺结构简称为`1P7M`,
其中`P`表示`Poly`, 即多晶硅层; `M`表示`Metal`, 即金属层;
因此`1P7M`表示1层多晶硅层和7层金属层.
在`1P7M`中, `M1`-`M3`为低层金属层, `M4`-`M5`为中层金属层, `M6`-`M7`为高层金属层.
可见, 在`1P7M`中, 只有两层中层金属层专门用于实现标准单元之间的连接.
通常, 先进工艺会提供更多的金属层, 如`1P9M`, `1P11M`等,
它们能提供更丰富的空间用于进行标准单元之间的连接,
但在制造过程中需要用到更多的金属层掩膜(mask), 因此制造成本也更高.

金属层的属性记录在PDK的工艺LEF文件中.
LEF文件以`.lef`为后缀, 采用`Library Exchange Format`格式,
它以文本方式描述了相应工艺的金属层, 通孔, 布局规则等物理层信息. -->
The number of metal layers may vary for different manufacturing processes.
For example, the process structure in the above figure is abbreviated as `1P7M`, where P stands for Poly (polysilicon layer) and M stands for Metal (metal layer). Thus, `1P7M` indicates 1 polysilicon layer and 7 metal layers. In `1P7M`, `M1`-`M3` are lower metal layers, `M4`-`M5` are middle metal layers, and `M6`-`M7` are upper metal layers. It can be seen that in `1P7M`, only two middle metal layers are specifically used to realize connections between standard cells.
Generally, advanced processes provide more metal layers, such as `1P9M`, `1P11M`, etc. These can offer more abundant space for connections between standard cells, but more metal layer masks are required during the manufacturing process, resulting in higher manufacturing costs.

The properties of metal layers are recorded in the process LEF file of the PDK. The LEF file, with the suffix `.lef`, adopts the `Library Exchange Format`. It describes the physical layer information of the corresponding process, such as metal layers, vias, and layout rules, in a text format.
```bash
vim yosys-sta/pdk/nangate45/lef/Nangate45_tech.lef
```
<!-- 例如, 你可以看到`LAYER metal1`的定义, 相关字段描述了第1层金属层的属性. -->
For example, you can see the definition of `LAYER metal1`, where the relevant fields describe the properties of the first metal layer.
```
LAYER metal1
  TYPE ROUTING ;
  SPACING 0.065 ;
  WIDTH 0.07 ;
  PITCH 0.14 ;
  DIRECTION HORIZONTAL ;
  OFFSET 0.095 0.07 ;
  RESISTANCE RPERSQ 0.38 ;
  THICKNESS 0.13 ;
  HEIGHT 0.37 ;
  CAPACITANCE CPERSQDIST 7.7161e-05 ;
  EDGECAPACITANCE 2.7365e-05 ;
END metal1
```
<!-- 其中, `TYPE`字段为`ROUTING`, 表示该层用于布线;
`WIDTH`字段和`PITCH`字段分别以$um$为单位给出了该层的最小线宽和最小走线间距,
具体如下图所示.
如果你想了解LEF文件的更多信息, 可以查阅[相关手册][lef manual]. -->
Among them, the `TYPE` field is `ROUTING`, indicating that this layer is used for routing. 
The `WIDTH` and `PITCH` fields specify the minimum wire width and minimum routing spacing of this layer in $um$ (micrometers), respectively, as shown in the following figure.
For more information about LEF files, you can refer to the [relevant manual][lef manual].
```
 WIDTH
   |
 <-+->
|     |                          |     |
|     |                          |     |
|     |                          |     |
|     |                          |     |
|wire |                          |     |
|     |                          |     |
|     |                          |     |
|     |                          |     |
|     |                          |     |
|     |                          |     |
|     |           PITCH          |     |
|     |             |            |     |
|     |             |            |     |
|     |             |            |     |
   |<---------------+-------------->|
```

[lef manual]: https://www.ispd.cc/contests/18/lefdefref.pdf

<!-- 在金属层的定义之前, 你应该还能看到多晶硅层`LAYER poly`的定义,
但其中只有一个`TYPE`字段, 没有其他字段.
这是因为多晶硅层连同绝缘层和硅衬底共同用于实现晶体管,
而晶体管的参数由工艺决定, 这对后端物理设计过程来说是相对固定的,
并不像金属层那样可以让EDA工具根据设计需求进行动态布线.
因此, 在LEF文件中只需要声明其存在即可, 更多工艺细节记录在其他文件(如GDS)中.
类似地, 绝缘层和硅衬底从功能上与多晶硅层紧密绑定,
甚至不需要在LEF文件中出现. -->
Before the definition of metal layers, you should also be able to see the definition of the polysilicon layer `LAYER poly`, which contains only a `TYPE` field without any other fields.
This is because the polysilicon layer, together with the dielectric and silicon substrate, is used to form transistors. The parameters of transistors are determined by the manufacturing process and are relatively fixed during the backend physical design process, unlike metal layers that allow EDA tools to perform dynamic routing according to design requirements. Therefore, in the LEF file, it is only necessary to declare the existence of the polysilicon layer, while more process details are recorded in other files (such as GDS).
Similarly, the dielectric and silicon substrate are functionally closely bound to the polysilicon layer and do not even need to appear in the LEF file.

<!-- > #### todo::了解nangate45的金属层
> 阅读nangate45的工艺LEF文件, 其中包含多少层金属层?
> 并尝试根据线宽和走线间距, 推测每层金属层的作用.

如果处理器的规模复杂(如乱序超标量的高性能处理器),
标准单元之间则会存在较多连线, 使得布线阶段的压力较大, 走线就需要迂回.
这不仅增加了芯片的面积, 还增加了线延迟, 降低了芯片的频率.
还可能会因为过分拥堵而布线失败, 使得芯片无法进入制造阶段.
因此, 高性能处理器的设计通常选择金属层多的先进工艺,
通过更丰富的布线空间来缓解布线阶段的压力.
例如, 香山处理器团队在设计过程中尝试将工艺从`1P9M`切换到`1P11M`,
无需改动RTL代码, 即可降低线延迟, 提升处理器的主频. -->
> #### todo:: 了解 nangate45 的金属层
> Read the process LEF file of nangate45. How many metal layers does it contain?
> And try to infer the function of each metal layer based on the wire width and routing space.

If the scale of a processor is complex (such as an out-of-order superscalar high-performance processor),
there will be many interconnections between standard cells, which will put great pressure on the routing stage and require detours in routing.
This not only increases the area of the chip, but also increases the line delay and reduces the frequency of the chip.
It may also lead to routing failure due to excessive congestion, making the chip unable to enter the manufacturing stage.
Therefore, the design of high-performance processors usually chooses advanced processes with more metal layers.
The richer routing space can alleviate the pressure in the routing stage.
For example, the Xiangshan processor team tried to switch the process from `1P9M` to `1P11M` during the design process.
Without modifying the RTL code, the wire delay can be reduced and the main frequency of the processor can be increased.

<!-- > #### comment::多个多晶硅层的工艺
> 并非所有工艺都只有1层多晶硅层, 根据不同的应用场景, 可能会采用更多多晶硅层的工艺.
> 例如, 闪存(flash存储器)的存储单元采用浮栅晶体管, 是一种包含两个栅极的特殊晶体管.
> 其中一个称为浮栅(floating gate), 分"存储电荷"(充电)和"未存储电荷"(放电)两种状态,
> 分别表示`0`和`1`; 另一个称为控制栅(control gate), 用于控制存储单元的读写.
> 闪存采用`2P8M`的制造工艺来实现这种特殊的晶体管,
> 其中包含的两个多晶硅层分别用于实现浮栅和控制栅. -->
> #### comment::Processes with Multiple Polysilicon Layers
> Not all manufacturing processes have only one polysilicon layer. Depending on different application scenarios, processes with more polysilicon layers may be adopted.
> For example, the memory cells of flash memory use floating-gate transistors, which are special transistors containing two gates.
One of them is called the floating gate, which has two states: "storing charge" (charged) and "un-storing charge" (discharged), representing 0 and 1 respectively; the other is called the control gate, which is used to control the reading and writing of the memory cell.
Flash memory adopts the `2P8M` manufacturing process to realize such special transistors, where the two polysilicon layers are used to implement the floating gate and the control gate respectively.

<!-- ### 标准单元的属性

PDK提供的标准单元库通常包含很多标准单元.
从名称上看, 如果忽略类似`X1`和`X4`的后缀, 有些标准单元的功能很容易理解,
例如`NAND2_X1`表示一个两输入的与非门, `OR3_X4`表示一个三输入的或门.
接下来, 我们以`NAND2_X1`为例, 查阅标准单元库中的相关文件, 来进一步了解标准单元的各种属性. -->
#### Attributes of Standard Cells

The standard cell library provided by PDK usually contains a large number of standard cells.
In terms of their names, if we ignore suffixes like `X1` and `X4`, the functions of some standard cells are easy to understand. For example, `NAND2_X1` represents a 2-input NAND gate, and `OR3_X4` represents a 3-input OR gate.
Next, we will take `NAND2_X1` as an example and refer to the relevant files in the standard cell library to further understand the various attributes of standard cells.

<!-- #### LIB文件 - 功能和时序

LIB文件以`.lib`为后缀, 采用`Liberty Timing File`格式,
它以文本方式描述了标准单元的功能, 以及在某种条件下的时序和功耗等属性.
```bash
vim yosys-sta/pdk/nangate45/lib/Nangate45_typ.lib
```

简单查阅后发现, LIB文件由一些头部字段和若干个标准单元(cell)的描述组成.
例如, 我们可以直接搜索`NAND2_X1`来查阅这个标准单元的相关属性. -->

#### LIB Files - Functionality and Timing

LIB files, with the `.lib` extension, adopt the `Liberty Timing File` format. They describe the functionality of standard cells in text form, as well as attributes such as timing and power consumption under certain conditions.
```bash
vim yosys-sta/pdk/nangate45/lib/Nangate45_typ.lib
```

A brief review reveals that a LIB file consists of some header fields and descriptions of several standard cells. For example, we can directly search for `NAND2_X1` to check the relevant attributes of this standard cell.

```txt
  cell (NAND2_X1) {
	drive_strength     	: 1;
	area               	: 0.798000;

	pg_pin(VDD) {
		voltage_name : VDD;
		pg_type      : primary_power;
	}
	pg_pin(VSS) {
		voltage_name : VSS;
		pg_type      : primary_ground;
	}

	cell_leakage_power 	: 17.393360;

	leakage_power () {
		when           : "!A1 & !A2";
		value          : 3.482556;
	}
	leakage_power () {
		when           : "!A1 & A2";
		value          : 24.799456;
	}
	leakage_power () {
		when           : "A1 & !A2";
		value          : 4.085038;
	}
	leakage_power () {
		when           : "A1 & A2";
		value          : 37.206389;
	}

	pin (A1) {
		direction		: input;
		related_power_pin		: "VDD";
		related_ground_pin		: "VSS";
		capacitance		: 1.599032;
		fall_capacitance	: 1.529196;
		rise_capacitance	: 1.599032;
	}

	pin (A2) {
		direction		: input;
		related_power_pin		: "VDD";
		related_ground_pin		: "VSS";
		capacitance		: 1.664199;
		fall_capacitance	: 1.502278;
		rise_capacitance	: 1.664199;
	}

	pin (ZN) {
		direction		: output;
		related_power_pin	: "VDD";
		related_ground_pin	: "VSS";
		max_capacitance		: 59.356700;
		function		: "!(A1 & A2)";

		timing () { ...... }
		internal_power () { ...... }
	}
}
```

<!-- 目前为止, 我们能看懂的属性包括(一些属性的单位在头部字段处定义):
* 面积(area), 一般以$um^2$为单位
* 漏电功耗(leakage power), 该属性包含标准单元在各种情况下的漏电功耗
* 端口(pin), 包括方向(direction), 电容(capacitance)等; 特别地, 对于输出端口, 还包含以下信息
  * 功能(function), 通过逻辑表达式给出, 可从该属性了解该标准单元的功能
  * 时序(timing), 包含标准单元在各种情况下的延迟
  * 内部功耗(internal power), 该属性包含标准单元在各种情况下的内部功耗 -->
So far, the attributes we can understand include (the units of some attributes are defined in the header fields):
* Area: Usually measured in $um^2$ square micrometers (square micrometers).
* Leakage power: This attribute includes the leakage power consumption of the standard cell under various conditions.
* Pin: Including direction, capacitance, etc. In particular, for output pins, it also contains the following information:
  * Function: Given by a logical expression, from which we can understand the function of the standard cell.
  * Timing: Including the delay of the standard cell under various conditions.
  * Internal power: This attribute includes the internal power consumption of the standard cell under various conditions.

<!-- 我们对面积属性的含义稍加说明.
芯片是一个三维物体, 芯片中的标准单元也存在于三维空间中.
为了方便描述, 我们假设将芯片水平放置, 并建立一个三维坐标系.
标准单元的面积是指标准单元在平面$xOy$中投影的面积, 也即俯视图中的面积.
考虑芯片的工艺结构, 标准单元的面积也是其在多晶硅层和低层金属层中所占的面积.

从上述属性可以看到, LIB文件主要用于综合, 时序分析和功耗分析.
例如, yosys在进行工艺映射时会读入LIB文件, 并根据标准单元`function`字段,
决定将哪些子电路映射为何种标准单元, 从而保证网表所描述的电路逻辑与输入RTL代码等价;
iSTA工具会根据标准单元的`timing`字段, 计算出各种情况下的每个标准单元的逻辑延迟,
最后报告网表的若干条最长路径. -->
Let us elaborate on the meaning of the area attribute.
A chip is a three-dimensional object, and the standard cells within the chip also exist in three-dimensional space. For the convenience of description, we assume the chip is placed horizontally and a three-dimensional coordinate system is established. The area of a standard cell refers to the area of its projection onto the $xOy$ plane, that is, the area in its top view. Considering the process structure of the chip, the area of a standard cell is also the area it occupies in the polysilicon layer and the lower metal layers.

From the above attributes, it can be seen that LIB files are mainly used in synthesis, timing analysis, and power consumption analysis. For example, Yosys reads the LIB file during technology mapping and, based on the `function` field of standard cells, determines which subcircuits to map to which standard cells, thereby ensuring that the circuit logic described by the netlist is equivalent to the input RTL code; the iSTA tool calculates the logic delay of each standard cell under various conditions according to the `timing` field of the standard cells, and finally reports several longest paths of the netlist.

<!-- > #### comment::RTFM
> 上述LIB文件有13万行, 不方便直接查阅.
> 我们推荐你查阅[网页版本的nangate45数据手册][nangate databook],
> 其数据来源于上述LIB文件, 但具有较好的可视化效果,
> 还能查阅相应标准单元的晶体管结构图(schematic).
>
> 如果想了解LIB文件中各个字段的具体含义,
> 可以查阅[`Liberty Timing File`的文件格式手册][liberty format manual]. -->
> #### comment::RTFM
> The aforementioned LIB file contains 130,000 lines, making it inconvenient to refer to directly.
We recommend that you refer to the [web version of the nangate45 data book][nangate databook],
whose data is derived from the aforementioned LIB file but features better visualization.
It also allows you to view the transistor schematic diagrams of the corresponding standard cells.
>
> If you wish to understand the specific meanings of each field in the LIB file,
you can consult the [file format manual for `Liberty Timing File`][liberty format manual].

[nangate databook]: https://www.cs.upc.edu/~jpetit/CellRouting/nangate/Front_End/Doc/Databook/CornerList.html
[liberty format manual]: https://media.c3d2.de/mgoblin_media/media_entries/659/Liberty_User_Guides_and_Reference_Manual_Suite_Version_2017.06.pdf

<!-- #### Verilog文件 - 行为模型

为了验证综合后的网表与综合前的RTL设计等价,
一种方式是进行网表仿真, 即结合标准单元的行为, 对网表进行仿真.
虽然LIB文件中标准单元的`function`字段也描述了标准单元的行为,
但RTL仿真器通常无法识别LIB文件.
因此, 标准单元库通常还提供标准单元的Verilog行为模型.

在nangate45中, 标准单元的Verilog行为模型位于如下文件: -->
#### Verilog Files - Behavioral Models

To verify the equivalence between the synthesized netlist and the pre-synthesis RTL design, one approach is to perform netlist simulation, which involves simulating the netlist in conjunction with the behavior of standard cells. Although the `function` field of standard cells in the LIB file also describes their behavior, RTL simulators typically cannot recognize LIB files. Therefore, standard cell libraries usually also provide Verilog behavioral models of standard cells.

In nangate45, the Verilog behavioral models of standard cells are located in the following file:
```bash
vim yosys-sta/pdk/nangate45/sim/cells.v
```
<!-- 例如, `NAND2_X1`的行为模型如下: -->
For example, the behaviorial model of `NAND2_X1` is the following:
```verilog
module NAND2_X1 (A1, A2, ZN);
   input A1;
   input A2;
   output ZN;
   assign ZN = ~(A1 & A2);
endmodule
```
<!-- 可以看到, 这只不过是用Verilog语言将标准单元的功能实现了一遍.
将网表文件连同这个行为模型文件一同输入到RTL仿真器中,
RTL仿真器将会按照模型文件中的模块定义对网表文件中的标准单元进行实例化,
从而开展网表层次的仿真工作.

nangate45提供的行为模型比较简单, 只能用于进行功能仿真.
有一些PDK提供的行为模型还包含丰富的时序信息,
以支持用户开展网表层次的时序仿真工作. -->
It can be seen that this is simply an implementation of the standard cell functions using the Verilog language. When the netlist file is input into the RTL simulator together with this behavioral model file, the RTL simulator will instantiate the standard cells in the netlist file according to the module definitions in the model file, thereby enabling simulation work at the netlist level.

The behavioral models provided by nangate45 are relatively simple and can only be used for functional simulation. Some PDKs provide behavioral models that also contain rich timing information to support users in carrying out timing simulation work at the netlist level.

<!-- #### LEF文件 - 物理几何信息

上文已经介绍了和工艺相关的LEF文件, 事实上还有一种和标准单元相关的LEF文件,
用于描述标准单元的物理几何信息. -->
#### LEF Files - Physical Geometry Information

As mentioned earlier, there are process-related LEF files. In fact, there is another type of LEF file associated with standard cells, which is used to describe the physical geometry information of standard cells.
```bash
vim yosys-sta/pdk/nangate45/lef/Nangate45_stdcell.lef
```
<!-- 以`NAND2_X1`为例, LEF文件对其描述如下: -->
Taking `NAND2_X1` as an example, the description of it in the LEF file is as follows:
```
MACRO NAND2_X1
  CLASS core ;
  FOREIGN NAND2_X1 0.0 0.0 ;
  ORIGIN 0 0 ;
  SYMMETRY X Y ;
  SITE FreePDK45_38x28_10R_NP_162NW_34O ;
  SIZE 0.57 BY 1.4 ;
  PIN A1
    DIRECTION INPUT ;
    ANTENNAPARTIALMETALAREA 0.021875 LAYER metal1 ;
    ANTENNAPARTIALMETALSIDEAREA 0.078 LAYER metal1 ;
    ANTENNAGATEAREA 0.05225 ;
    PORT
      LAYER metal1 ;
      POLYGON 0.385 0.525 0.51 0.525 0.51 0.7 0.385 0.7  ;
    END
  END A1
  ......
END NAND2_X1
```
<!-- 其中, `SYMMETRY X Y`表示标准单元可以沿$x$轴或沿$y$轴对称放置,
从而优化布局的效果(如到某端口的线延迟等);
`SITE`给出了标准单元在放置时需要对齐规则,
此处字段的值`FreePDK45_38x28_10R_NP_162NW_34O`表示引用了另一处的对齐规则,
具体位于工艺LEF文件中: -->
Among them, `SYMMETRY X Y` indicates that the standard cell can be placed symmetrically along the $x$-axis or $y$-axis, thereby optimizing the layout effect (such as the wire delay to a certain pin, etc.).
The `SITE` field specifies the alignment rules that the standard cell must follow during placement. Here, the value `FreePDK45_38x28_10R_NP_162NW_34O` refers to alignment rules defined elsewhere, which are specifically located in the process LEF file:
```
SITE FreePDK45_38x28_10R_NP_162NW_34O
  SYMMETRY y ;
  CLASS core ;
  SIZE 0.19 BY 1.4 ;
END FreePDK45_38x28_10R_NP_162NW_34O
```
<!-- 这里的`SYMMETRY y`含义表示标准单元可以沿$y$轴对称放置;
`SIZE 0.19 BY 1.4`给出了对齐规则为`0.19 X 1.4`,
也即摆放标准单元时, $x$轴坐标必须为`0.19`的整数倍, $y$轴坐标必须为`1.4`的整数倍.
回过头来看`NAND2_X1`的`SIZE`字段, 它给出了标准单元的尺寸.
可以看到, `SIZE`字段在$x$轴上的长度`0.57`和在$y$轴上的长度`1.4`,
都分别是对齐规则中`0.19`和`1.4`的整数倍.
更一般地, 可以认为`SITE`定义了一个网格单元,
所有标准单元从尺寸上来看, 都是由一个或多个网格单元组成的矩形.
`PIN`字段用于描述指定引脚的一些属性, 包括方向(`DIRECTION`),
天线效应的参数(以`ANTENNA`开头的属性), 以及端口的几何形状(`PORT`).
其中的`PORT`又描述了端口需要在`metal1`层占用一个多边形, 形状通过`POLYGON`字段给出.

可以看到, LEF文件详细地描述了标准单元的几何外形信息.
这些信息将会帮助EDA工具正确地将标准单元摆放在芯片中. -->
Here, `SYMMETRY y` means that the standard cell can be placed symmetrically along the y-axis.
The `SIZE 0.19 BY 1.4` specifies the alignment rule as `0.19 X 1.4`, which means that when placing the standard cell, the $x$-axis coordinate must be an integer multiple of `0.19`, and the $y$-axis coordinate must be an integer multiple of `1.4`.
Looking back at the `SIZE` field of `NAND2_X1`, it gives the dimensions of the standard cell. It can be seen that the length in the $x$-axis (`0.57`) and the length in the $y$-axis (`1.4`) in the SIZE field are respectively integer multiples of `0.19` and `1.4` in the alignment rules.
More generally, the `SITE` can be considered as defining a grid unit, and all standard cells, in terms of size, are rectangles composed of one or more grid units.
The `PIN` field is used to describe some attributes of the specified pin, including direction (`DIRECTION`), parameters related to antenna effect (attributes starting with `ANTENNA`), and the geometry of the port (`PORT`). The `PORT` further describes that the port needs to occupy a polygon on the `metal1` layer, and the shape is given by the `POLYGON` field.

It can be seen that the LEF file describes the geometric shape information of the standard cell in detail. This information will help EDA tools correctly place the standard cells in the chip.

<!-- #### CDL文件 - 晶体管网表

CDL文件以`.cdl`为后缀, 它其实是一种电路描述语言(Circuit Description Language),
以文本方式描述了标准单元的晶体管结构. -->
#### CDL Files - Transistor Netlists

CDL files, with the `.cdl` extension, are based on a Circuit Description Language. They describe the transistor structure of standard cells in text form.
```bash
vim yosys-sta/pdk/nangate45/cdl/NangateOpenCellLibrary.cdl
```
<!-- CDL文件中对晶体管结构的描述格式如下: -->
The format for describing transistor structures in CDL files is as follows:
<!-- ```
.SUBCKT 子电路名称 端口1 端口2 ...
晶体管实例名称 漏极 栅极 源极 衬底 晶体管类型 沟道宽度 沟道长度
...
.ENDS
``` -->
```
.SUBCKT subcircuit name port1 port2 ...
transistor instance name drain gate source substrate transistor type channel width channel length
...
.ENDS
```
<!-- 以`NAND2_X1`为例, CDL文件对其描述如下: -->
Taking `NAND2_X1` as an example, the description of it in the CDL file is as follows:
```
.SUBCKT NAND2_X1 A1 A2 ZN VDD VSS
*.PININFO A1:I A2:I ZN:O VDD:P VSS:G
*.EQN ZN=!(A1 * A2)
M_i_1 net_0 A2 VSS VSS NMOS_VTL W=0.415000U L=0.050000U
M_i_0 ZN A1 net_0 VSS NMOS_VTL W=0.415000U L=0.050000U
M_i_3 ZN A2 VDD VDD PMOS_VTL W=0.630000U L=0.050000U
M_i_2 VDD A1 ZN VDD PMOS_VTL W=0.630000U L=0.050000U
.ENDS
```
<!-- 其中, 以``*``开头的行是注释.
上述描述通过`.SUBCKT`定义了一个名为`NAND2_X1`的子电路(即标准单元),
有5个端口, 依次为`A1`, `A2`, `ZN`, `VDD`和`VSS`.
以`M_i_1`开头的行实例化了一个名为`M_i_1`的nMOS晶体管, 其漏极和线网`net_0`相连,
栅极和端口`A2`相连, 源极和端口`VSS`相连, 衬底和端口`VSS`相连,
沟道的宽度和长度分别为$0.415um$和$0.05um$.
上述例子的剩余内容通过类似方式描述剩余的晶体管及其连接关系. -->
Lines starting with ``*`` are comments.
The above description defines a subcircuit (i.e., a standard cell) named `NAND2_X1` using `.SUBCKT`, which has 5 ports: `A1`, `A2`, `ZN`, `VDD`, and `VSS` in sequence.
The line starting with `M_i_1` instantiates an nMOS transistor named `M_i_1`. Its drain is connected to the net `net_0`, its gate is connected to the port `A2`, its source is connected to the port `VSS`, and its substrate is connected to the port `VSS`. The channel width and length are $0.415um$ and $0.05um$, respectively.
The remaining content of the above example describes the remaining transistors and their connection relationships in a similar manner.

<!-- > #### todo::根据CDL文件画出晶体管结构
> 尝试根据上述CDL描述, 画出标准单元`NAND2_X1`的晶体管结构,
> 并检查其功能与与非门是否一致.

CDL中描述的晶体管结构信息主要用于进行晶体管层次的SPICE仿真,
以及用于检查GDS版图与网表逻辑的一致性, 后者的工作称为LVS(Layout Versus Schematic). -->
> #### todo::Draw the transistor structure based on the CDL file
> Try to draw the transistor structure of the standard cell `NAND2_X1` according to the above CDL description,
and check whether its function is consistent with that of a NAND gate.

The transistor structure information described in the CDL is mainly used for transistor-level SPICE simulation,
and for checking the consistency between the GDS layout and the netlist logic. The latter task is called LVS (Layout Versus Schematic).

<!-- #### GDS文件 - 物理版图

GDS文件以`.gds`为后缀, 它包含了制造某标准单元的所需的所有物理和工艺信息.
GDS文件并非文本文件, 需要专门的工具来解析读取.
"一生一芯"对GDS文件中的具体内容不作要求, 故此处不展开介绍.

### 标准单元的分类

标准单元库中的标准单元种类繁多, 可以根据功能对其进行分类, 包括但不限于如下类别.
通常来说, 前5类单元和时钟缓存器是必须的, 从而保证能正确实现各种设计的基本功能.
通过提供其他类型的单元, 用户可以针对指定的场景设计出更优的电路, 或实现更方便的芯片调试功能. -->
#### GDS File - Physical Layout

GDS files, with the suffix `.gds`, contain all the physical and process information required for manufacturing a standard cell.
GDS files are not text files and require specialized tools for parsing and reading.
The "OSOC" program does not impose requirements on the specific content within GDS files, so no further elaboration will be provided here.

### Classification of Standard Cells

There is a wide variety of standard cells in a standard cell library, which can be classified according to their functions, including but not limited to the following categories.
Generally speaking, the first 5 categories of cells and clock buffers are essential to ensure the correct implementation of the basic functions of various designs.
By providing other types of cells, users can design better circuits for specific scenarios or achieve more convenient chip debugging functions.

<!-- #### 逻辑门单元

逻辑门单元包括基本逻辑门(与门, 或门, 非门等)和复杂逻辑门.

> #### todo::理解复杂逻辑门单元的功能
> nangate45的LIB文件中还存在命名类似`OAI22_X1`的标准单元, 其功能并不直观.
> 尝试查阅标准单元`OAI22_X1`相关的属性, 了解其功能.

查阅nangate45的LIB文件后可发现, `OAI22_X1`这个标准单元的功能比单一的逻辑门更复杂,
其功能包含两个二输入或门, 一个二输入与门和一个非门.
这种逻辑门称为复杂门(complex gate).
如果我们查阅相关标准单元的面积, 可以得到如下数据:
```
area(OAI22_X1) = 1.33
area(OR2_X1)*2 + area(AND2_X1) + area(INV_X1) = 1.064*2 + 1.064 + 0.532 = 3.724
```
可以看到, `OAI22_X1`这个标准单元的面积,
比采用功能等价的多个逻辑门单元所花费的面积要小得多,
这是因为, 通过晶体管之间的串联和并联来实现"与"和"或"的逻辑功能,
比通过"与门"和"或门"来实现相应的逻辑功能, 代价要低很多.
这里的代价不仅仅体现在面积上, 还体现在延迟和功耗上.
因此, 标准单元库并非只包含简单逻辑门单元,
对于类似`OAI22_X1`这种在晶体管层次实现的复杂逻辑门, 也作为标准单元提供. -->

#### Logic Gate Cells

Logic gate cells include basic logic gates (AND gates, OR gates, NOT gates, etc.) and complex logic gates.

> #### todo::Understand the Function of Complex Logic Gate Cells
> There are standard cells named like `OAI22_X1` in the Nangate45 LIB file, whose functions are not intuitive.
Try to look up the relevant attributes of the standard cell `OAI22_X1` to understand its function.

After checking the Nangate45 LIB file, it can be found that the function of the standard cell `OAI22_X1` is more complex than a single logic gate.
Its function includes two 2-input OR gates, one 2-input AND gate, and one NOT gate.
This type of logic gate is called a complex gate.
If we check the area of the relevant standard cells, we can get the following data:
```
area(OAI22_X1) = 1.33
area(OR2_X1)*2 + area(AND2_X1) + area(INV_X1) = 1.064*2 + 1.064 + 0.532 = 3.724
```
It can be seen that the area of the standard cell `OAI22_X1`
is much smaller than the area occupied by using multiple functionally equivalent logic gate cells.
This is because realizing the logical functions of "AND" and "OR" through the series and parallel connection of transistors
is much less costly than realizing the corresponding logical functions through "AND gates" and "OR gates".
The cost here is not only reflected in the area but also in the delay and power consumption.
Therefore, the standard cell library does not only contain simple logic gate cells.
Complex logic gates like `OAI22_X1` that are implemented at the transistor level are also provided as standard cells.
<!-- > #### todo::理解OAI22的晶体管结构
> 在CDL文件中查阅`OAI22_X1`的晶体管结构, 它有多少根晶体管?
> 尝试理解如何通过其晶体管结构实现`OAI22_X1`的逻辑表达式.

> #### comment::OAI22的命名
> 事实上, `OAI22`的命名是有其含义的, 其中`OAI`表示`Or-And-Invert`,
> `22`表示两组输入信号, 每组各两个. 不妨假设输入信号分别为`A1, A2, B1, B2`,
> 那么, `OAI`表示首先对每组信号内部进行`Or`运算, 得到`A1 | A2`和`B1 | B2`;
> 再对结果进行`And`运算, 得到`(A1 | A2) & (B1 | B2)`;
> 最后对结果进行`Invert`运算, 得到`!((A1 | A2) & (B1 | B2))`. -->
> #### todo::Understand the Transistor Structure of OAI22
> Check the transistor structure of `OAI22_X1` in the CDL file. How many transistors does it have?
> Try to understand how its transistor structure implements the logical expression of `OAI22_X1`.

> #### comment::Naming of OAI22
> In fact, the naming of `OAI22` has its meaning, where `OAI` stands for `Or-And-Invert`,
> and `22` indicates two groups of input signals, with two in each group. Let's assume the input signals are `A1, A2, B1, B2` respectively.
Then, `OAI` means first performing the `Or` operation within each group of signals to get `A1 | A2` and `B1 | B2`;
then performing the `And` operation on the results to get `(A1 | A2) & (B1 | B2)`;
and finally performing the `Invert` operation on the result to get `!((A1 | A2) & (B1 | B2))`.

<!-- > #### option::理解复杂逻辑门单元的功能(2)
> 类似地, 有一个标准单元的命名为`AOI221`, 尝试根据命名列出其逻辑表达式,
> 并查阅标准单元库中的功能, 对比你的理解是否正确.

标准单元中包含的类似`X1`, `X4`等后缀, 表示这个标准单元的驱动能力(drive strength).
驱动能力是指标准单元在维持指定电压范围时能驱动或吸收的电流, 它会影响下游标准单元翻转所需的时间.
因此, `NAND2_X1`, `NAND2_X2`和`NAND2_X4`在逻辑功能上是完全等价的,
但`NAND2_X4`能提供更大的驱动能力, 能使其下游逻辑翻转得更快,
不过这需要更大或更多的晶体管来实现, 因此`NAND2_X4`具有更大的面积, 其功耗也更高. -->
> #### option::Understand the Function of Complex Logic Gate Cells (2)
> Similarly, there is a standard cell named `AOI221`. Try to list its logical expression based on the naming, and check the function in the standard cell library to compare whether your understanding is correct.

The suffixes like `X1`, `X4`, etc., included in standard cells indicate the drive strength of the standard cell. Drive strength refers to the current that a standard cell can source or sink while maintaining a specified voltage range, and it affects the time required for the downstream standard cells to switch. Therefore, `NAND2_X1`, `NAND2_X2`, and `NAND2_X4` are completely equivalent in terms of logical function. However, `NAND2_X4` can provide greater drive strength, enabling its downstream logic to switch faster. But this requires larger or more transistors to achieve, so `NAND2_X4` has a larger area and higher power consumption.

<!-- > #### todo::理解驱动能力
> 尝试查阅`NAND2_X1`, `NAND2_X2`和`NAND2_X4`的相关属性, 对比其面积和功耗.

> #### todo::理解驱动能力(2)
> 尝试查阅`NAND2_X2`的晶体管结构, 和`NAND2_X1`相比, 有何不同?

考虑到不同驱动能力在性能, 面积, 功耗等指标上的权衡,
通常在影响频率的关键路径上使用驱动能力较高的标准单元,
从而降低关键路径的延迟, 提升芯片的频率;
在不影响频率的非关键路径上使用驱动能力较低的标准单元,
从而在不降低芯片频率的情况下, 降低芯片整体的面积和功耗. -->
> #### todo::Understand Drive Strength
> Try to look up the relevant attributes of `NAND2_X1`, `NAND2_X2`, and `NAND2_X4`, and compare their area and power consumption.

> #### todo::Understand Drive Strength (2)
> Try to check the transistor structure of `NAND2_X2` and see how it differs from that of `NAND2_X1`.

Considering the trade-offs between different drive strengths in terms of performance, area, power consumption, and other indicators, standard cells with higher drive strengths are usually used in critical paths that affect the frequency. This helps reduce the delay of critical paths and improve the chip's frequency. On non-critical paths that do not affect the frequency, standard cells with lower drive strengths are used. This way, the overall area and power consumption of the chip can be reduced without lowering the chip's frequency.

<!-- #### 时序单元

时序单元包括触发器, 锁存器等, 其中又包含有/无清零端/置位端等各种类型,
如触发器`DFF_X1`等.

> #### option::根据CDL文件画出晶体管结构(2)
> 在CDL文件中查阅`DFF_X1`的晶体管结构.
> 这个标准单元由多少个晶体管组成?
> 根据CDL文件的描述画出`DFF_X1`的晶体管结构,
> 并尝试理解如何通过该晶体管结构实现触发器的功能.

#### I/O单元

芯片需要通过I/O单元(输入输出单元)来与外界进行通信.
I/O单元用于将芯片内部的I/O信号和I/O单元的金属压焊块(pad)连接起来,
在芯片生产后, 封装工序会从I/O单元的金属压焊块中引出金属引脚,
从而允许芯片外部的信号通过引脚与芯片内部的I/O信号进行交互.

nangate45的I/O单元可以参考相关LIB文件: -->
#### Sequential Cells

Sequential cells include flip-flops, latches, etc., among which there are various types with/without clear/set terminals, such as the flip-flop `DFF_X1` and so on.

> #### option::Draw the Transistor Structure Based on the CDL File (2)
> Check the transistor structure of `DFF_X1` in the CDL file.
How many transistors does this standard cell consist of?
Draw the transistor structure of `DFF_X1` according to the description in the CDL file,
and try to understand how the flip-flop function is realized through this transistor structure.

#### I/O Cells

A chip needs to communicate with the outside world through I/O cells (input/output cells).
I/O cells are used to connect the internal I/O signals of the chip to the metal bonding pads of the I/O cells.
After the chip is manufactured, the packaging process will lead out metal pins from the metal bonding pads of the I/O cells,
allowing external signals of the chip to interact with the internal I/O signals of the chip through the pins.
For the I/O cells of nangate45, reference can be made to the relevant LIB files:
```bash
vim yosys-sta/pdk/nangate45/lib/dummy_pads.lib
```
<!-- 其中, I/O单元可继续分类如下:
1. 数据I/O单元(也称GPIO), 用于提供数据信号的输入输出, 如`PADCELL_SIG_H`.
1. 核心电源单元, 用于为芯片内部的晶体管提供电源,
   包括源极的电源(VSS)和漏极的电源(VDD),
   如`PADCELL_VSS_H`和`PADCELL_VDD_H`.
1. I/O电源单元, 用于为数据I/O单元(即第1类I/O单元)提供电源.
   如`PADCELL_VSSIO_H`和`PADCELL_VDDIO_H`.
   数据I/O单元通常比一般的标准单元要复杂,
   因此其供电需求也不同于一般的标准单元,
   故不能使用核心电源单元(即第2类I/O单元)为数据I/O单元供电.

每类I/O单元又分水平方向和垂直方向两种:
其中水平方向的I/O单元以``_H``为后缀,
如上文的`PADCELL_SIG_H`, `PADCELL_VDD_H`等;
垂直方向的I/O单元以``_V``为后缀,
如`PADCELL_SIG_V`, `PADCELL_VDD_V`等.

虽然I/O单元也是标准单元库中的一部分, 但它们的面积比一般的标准单元要大几个数量级.
这是因为, 与芯片外界通信对I/O单元的功能提出了更多需求,
例如需要具备很强的驱动能力来向芯片外部输送信号,
需要集成保护电路来防止外部的静电对芯片内部造成损害,
需要符合芯片引脚的物理尺寸和焊接要求(如间距,
金属层厚度, 保留空白区域避免短路)等.
因此, I/O单元的电路层实现要比一般的标准单元复杂得多. -->
Among them, I/O cells can be further classified as follows:
1. Data I/O cells (also known as GPIO), which are used to provide input and output of data signals, such as `PADCELL_SIG_H`.
1. Core power supply cells, which are used to provide power for transistors inside the chip, including the source power supply (VSS) and the drain power supply (VDD), such as `PADCELL_VSS_H` and `PADCELL_VDD_H`.
1. I/O power supply cells, which are used to provide power for data I/O cells (i.e., the first type of I/O cells). For example, `PADCELL_VSSIO_H` and `PADCELL_VDDIO_H`. Data I/O cells are usually more complex than general standard cells, so their power supply requirements are different from those of general standard cells. Therefore, core power supply cells (i.e., the second type of I/O cells) cannot be used to power data I/O cells.

Each type of I/O cell is further divided into horizontal and vertical directions:
Horizontal I/O cells are suffixed with `_H`, such as the aforementioned `PADCELL_SIG_H`, `PADCELL_VDD_H`, etc.
Vertical I/O cells are suffixed with `_V`, such as `PADCELL_SIG_V`, `PADCELL_VDD_V`, etc.

Although I/O cells are also part of the standard cell library, their area is several orders of magnitude larger than that of general standard cells. This is because communicating with the outside of the chip imposes more requirements on the functions of I/O cells. For example, they need to have strong driving capability to transmit signals to the outside of the chip, integrate protection circuits to prevent external static electricity from damaging the inside of the chip, and meet the physical size and welding requirements of chip pins (such as spacing, metal layer thickness, and retaining blank areas to avoid short circuits). Therefore, the circuit-level implementation of I/O cells is much more complex than that of general standard cells.

<!-- > #### todo::了解I/O单元的尺寸
> 尝试查阅nangate45中的相关文件,
> 了解一个二输入与非门的尺寸以及一个I/O单元的尺寸,
> 并对比它们.

#### 驱动单元

驱动单元用于增强信号的驱动能力, 保证信号完整性, 优化时序和负载.
当信号传输距离过长或下游电路过多(高扇出)时,
信号可能会因为驱动能力不足而导致传输延迟过高, 甚至使得信号失真从而导致错误.
插入驱动单元有助于缓解上述问题. 具体分为:
* 逻辑正向驱动单元, 又称缓冲器(buffer), 其输出在逻辑上和输入完全相同.
  在nangate45中, 这种驱动单元包括`BUF_X1`, `BUF_X2`, `BUF_X4`等,
  后缀的数字最大, 单元的驱动能力越强.
* 逻辑反向驱动单元, 又称反相器(inverter), 其功能和非门相同, 同样也存在多种驱动能力. -->
> #### todo::Learn About the Size of I/O Cells
> Try to refer to relevant files in nangate45,
find out the size of a 2-input NAND gate and the size of an I/O cell,
and compare them.

#### Driver Cells

Driver cells are used to enhance the driving capability of signals, ensure signal integrity, and optimize timing and load.
When a signal is transmitted over a long distance or there are too many downstream circuits (high fan-out),
the signal may suffer from excessive transmission delay due to insufficient driving capability, or even signal distortion leading to errors.
Inserting driver cells helps alleviate the above problems. They are specifically divided into:
* Logical non-inverting driver cells, also known as buffers, whose output is logically identical to the input.
In nangate45, such driver cells include `BUF_X1`, `BUF_X2`, `BUF_X4`, etc.
The larger the number in the suffix, the stronger the driving capability of the cell.
* Logical inverting driver cells, also known as inverters, which have the same function as NOT gates and also come with various driving capabilities.

<!-- #### 物理单元

物理单元没有逻辑功能, 主要用于解决后端物理设计中与电路逻辑功能无关的特定问题.
一些常见的物理单元包括:
* 上拉/下拉单元. 这类单元没有输入, 只有输出, 分别提供`逻辑0`(低电平)和`逻辑1`(高电平).
  在nangate45中, 上拉单元和下拉单元分别是`LOGIC1_X1`和`LOGIC0_X1`.
* 填充单元(filler). 用于填充芯片中的空白区域,
  保证某些层(如电源层)的连续性, 避免制造过程导致的缺陷.
  在nangate45中, 填充单元包括`FILLCELL_X1`, `FILLCELL_X2`等.
* 去耦单元(decap). 用于避免电路中大量单元同时翻转引起的动态电压降对电路的影响.
  nangate45暂未提供去耦单元.
* 天线效应修复单元. 在芯片制造过程的离子刻蚀步骤中,
  在一定条件下会引发电路上的天线效应, 这种效应会击穿晶体管, 使其失效.
  在合适的位置添加这种标准单元可以消除天线效应, 从而保证芯片的正确性.
  在nangate45中, 天线效应修复单元是`ANTENNA_X1`.

#### 宏单元

宏单元是一种具有特定功能的, 被厂商(晶圆厂或IP厂商)预先设计好其物理实现的,
面积较大的标准单元, 例如SRAM存储器, DDR phy模块等.
SRAM存储器是一类常见的宏单元, 在处理器设计中经常使用.
nangate45本身并不带SRAM宏单元, 而是集成了由[SRAM生成器][fakeram]生成的SRAM宏单元. -->
#### Physical Cells

Physical cells have no logical functions and are mainly used to solve specific problems in backend physical design that are unrelated to the circuit's logical functions. Some common physical cells include:
* Pull-up/pull-down cells. These cells have no inputs, only outputs, providing `logic 0` (low level) and `logic 1` (high level) respectively. In nangate45, the pull-up cell and pull-down cell are `LOGIC1_X1` and `LOGIC0_X1` respectively.
* Filler cells. They are used to fill blank areas in the chip, ensuring the continuity of certain layers (such as the power layer) and avoiding defects caused during the manufacturing process. In nangate45, filler cells include `FILLCELL_X1`, `FILLCELL_X2`, etc.
* Decoupling cells (decap). They are used to avoid the impact of dynamic voltage drop caused by the simultaneous switching of a large number of cells in the circuit. Nangate45 does not currently provide decoupling cells.
* Antenna effect repair cells. During the ion etching step of the chip manufacturing process, under certain conditions, the antenna effect on the circuit may be triggered, which can break down the transistor and make it ineffective. Adding such standard cells in appropriate positions can eliminate the antenna effect, thereby ensuring the correctness of the chip. In nangate45, the antenna effect repair cell is `ANTENNA_X1`.

#### Macro Cells

Macro cells are standard cells with specific functions, pre-designed for their physical implementation by manufacturers (foundries or IP vendors), and have a relatively large area. Examples include SRAM memories, DDR phy modules, etc. SRAM memories are a common type of macro cell and are often used in processor design. Nangate45 itself does not come with SRAM macro cells but integrates SRAM macro cells generated by the [SRAM generator][fakeram].

[fakeram]: https://github.com/bespoke-silicon-group/bsg_fakeram

<!-- > #### todo::对比存储密度
> 在nangate45中选择一种规格的SRAM存储器, 查看其面积,
> 计算其存储密度(即单位面积能存储的信息量).
> 对比锁存器和触发器, 你选择的SRAM存储器的存储密度是它们的多少倍?

> #### option::对比存储密度(2)
> 同样是实现信息的存取, 为什么SRAM的存储密度能高于锁存器和触发器?

> #### option::对比存储密度(3)
> 对于`32x64`和`64x32`这两种规格的SRAM, 其存储容量一样, 但面积却不同.
> 哪种规格的面积更大? 为什么? -->
> #### todo::Compare storage density
> Select an SRAM memory of a certain specification in nangate45, check its area, and calculate its storage density (that is, the amount of information that can be stored per unit area). Compare it with latches and flip-flops, and find out how many times the storage density of the selected SRAM memory is that of them?

> #### option::Compare storage density (2)
> Both are used to realize information access. Why can the storage density of SRAM be higher than that of latches and flip-flops?

> #### option::Compare storage density (3)
> For the two specifications of SRAM, `32x64` and `64x32`, their storage capacities are the same, but their areas are different. Which specification has a larger area? Why?

<!-- #### 复杂功能单元

复杂功能单元包括多路选择器, 半加器, 全加器, 比较器等.
相比于用逻辑门搭建出功能等价的电路,
以标准单元提供这些功能可以实现更优的延迟和面积.
在nangate45中, 复杂功能单元包括`MUX2_X1`, `MUX2_X2`, `HA_X1`和`FA_X1`.

> #### todo::复杂单元的全定制电路
> 以`HA_X1`为例, 尝试从标准单元库的相关文件中找到这个标准单元的面积和晶体管结构.
> 假设某标准单元库不提供半加器的标准单元,
> 需要通过若干基本逻辑门的标准单元来搭建半加器,
> 请计算此时所需的面积和晶体管数量. -->
#### Complex Function Units

Complex function units include multiplexers, half-adders, full-adders, comparators, etc.
Compared to circuits built with logic gates to achieve equivalent functions,
providing these functions as standard cells can achieve better delay and area performance.
In nangate45, complex function units include `MUX2_X1`, `MUX2_X2`, `HA_X1`, and `FA_X1`.

> #### todo::Full-Custom Circuits of Complex Units
> Taking `HA_X1` as an example, try to find the area and transistor structure of this standard cell from the relevant files of the standard cell library.
Assume that a certain standard cell library does not provide a standard cell for the half-adder,
and it is necessary to build a half-adder using several standard cells of basic logic gates.
Please calculate the required area and number of transistors in this case.

<!-- #### 时钟专用单元

时钟专用单元专门用于处理时钟信号的单元, 包括时钟缓冲器,
时钟门控(clock gating)单元, 用于处理时钟信号的逻辑门单元等.
之所以不能用一般的标准单元(如与门, 缓冲器等)来处理时钟信号, 是因为时钟信号的特殊性:
* 时钟信号的细微变化可能会导致触发器无法正确工作,
  例如, 时钟信号因抖动产生的毛刺可能会被触发器误认为时钟边沿的到来.
* 时钟信号的延迟也会影响触发器的时序, 进而影响整个电路的工作频率.
* 电路中的触发器都需要接入时钟, 因此时钟信号的扇出非常大,
  传输距离也很远, 需要很强的驱动能力.
  根据上文对芯片内部结构的介绍, 时钟信号通常在高层金属层进行传输.

因此, 和一般的标准单元相比, 标准单元库的设计者需要对时钟专用单元进行针对性设计,
使其具备低抖动, 低延迟, 高驱动能力等特性.

在nangate45中, 时钟专用单元包括`CLKBUF_X1`, `CLKGATE_X1`等.

#### 电源管理单元

电源管理单元用于实现低功耗设计, 包括电源门控(power gating)单元, 隔离单元等.
nangate45暂未提供此类单元. -->
#### Clock-Specific Cells

Clock-specific cells are dedicated to processing clock signals, including clock buffers, clock gating cells, and logic gate cells for handling clock signals, etc. The reason why general standard cells (such as AND gates, buffers, etc.) cannot be used to process clock signals is due to the particularity of clock signals:
* Minor changes in clock signals may cause flip-flops to work incorrectly. For example, glitches in clock signals caused by jitter may be mistaken by flip-flops as the arrival of clock edges.
* The delay of clock signals will also affect the timing of flip-flops, thereby affecting the operating frequency of the entire circuit.
* All flip-flops in the circuit need to be connected to the clock, so the fan-out of the clock signal is very large and the transmission distance is very long, requiring strong driving capability. According to the introduction of the internal structure of the chip above, clock signals are usually transmitted in the upper metal layers.

Therefore, compared with general standard cells, the designers of the standard cell library need to carry out targeted designs for clock-specific cells, making them have characteristics such as low jitter, low delay, and high driving capability.

In nangate45, clock-specific cells include `CLKBUF_X1`, `CLKGATE_X1`, etc.

#### Power Management Cells

Power management cells are used to implement low-power designs, including power gating cells, isolation cells, etc. Nangate45 does not currently provide such cells.

<!-- #### 测试调试单元

测试调试单元用于支持芯片的测试和调试, 包括扫描链(scan chain)单元,
内建自测试(Built-In Self Test, BIST)控制单元等.

扫描链单元通常用于可测试性设计(Design for Testability, DFT),
它们在一般触发器的基础上, 添加了扫描使能端`SE`(scan enable)和扫描输入端`SI`(scan input).
当`SE`有效时, 用`SI`来更新触发器.
因此, 开发者可以通过外部的控制将特定状态注入到这种触发器中,
从而帮助开发者对生产后的芯片进行调试.
不过, 和一般的触发器相比, 扫描链单元的面积更大, 功耗也更高.

在nangate45中, 测试调试单元包括`SDFF_X1`, `SDFFS_X1`, `SDFFR_X1`, `SDFFRS_X1`等.

> #### todo::了解的所有标准单元
> 尝试结合PDK的相关文件, 进一步了解nangate45提供的标准单元.
> 你可以查看相应的注释和功能属性了解相关标准单元的作用.
> 了解后, 你将会对你的RTL代码如何被综合器处理有一个简单的认识. -->
#### Test and Debug Cells

Test and debug cells are used to support chip testing and debugging, including scan chain cells, Built-In Self Test (BIST) control cells, etc.

Scan chain cells are usually used in Design for Testability (DFT). On the basis of general flip-flops, they add a scan enable terminal `SE` (scan enable) and a scan input terminal `SI` (scan input). When `SE` is active, `SI` is used to update the flip-flop. Therefore, developers can inject specific states into such flip-flops through external control, which helps them debug the chip after production. However, compared with general flip-flops, scan chain cells have a larger area and higher power consumption.

In nangate45, test and debug cells include `SDFF_X1`, `SDFFS_X1`, `SDFFR_X1`, `SDFFRS_X1`, etc.

> #### todo::Learn About All Standard Cells
> Try to further understand the standard cells provided by nangate45 in combination with the relevant files of the PDK.
You can check the corresponding comments and functional attributes to understand the role of related standard cells.
After understanding, you will have a simple understanding of how your RTL code is processed by the synthesizer.

<!-- ### PVT角

电路的延迟主要受三个因素的影响: 工艺(Process),
电压(Voltage)和温度(Temperature). 三者统称PVT参数.
电子工程师一般会选取多个PVT参数的组合作为一系列环境,
并在设计阶段尽可能保证芯片将来能在这些环境下工作.
这些环境称为PVT角(PVT corner).

工艺波动是指芯片制造过程中不可控的扰动因素.
例如, 晶圆中心的芯片所处的环境与晶圆边界的芯片有所不同,
晶体管金属层的厚度并非完全均匀, 晶体管衬底的掺杂浓度不均匀, 等等.
这些因素都会影响晶体管的电阻和电容(统称RC参数),
最终影响晶体管的延迟表现: 可能会变快, 也可能会变慢.

为了测试电路在各种晶体管延迟下都能正确工作, 一般会根据晶体管的工作速度定义若干情况,
这些情况称为工艺角(process corner).
工艺角通常用两个字母来命名, 第一个字母表示nMOS的工作速度, 第二个字母表示pMOS的工作速度.
工作速度分成三种情况: 典型(typical, 用字母`t`表示),
快速(fast, 用字母`f`表示)和慢速(slow, 用字母`s`表示).
其中, 快速和慢速都是相对与典型情况而言的.
因此, 根据晶体管的极性和工作速度, 可以组合出五种工艺角: `ss`, `tt`, `ff`, `sf`和`fs`.
例如, `fs`表示nMOS工作得比典型情况快, 但pMOS工作得比典型情况慢的延迟情况. -->
### PVT Corners

The delay of a circuit is mainly affected by three factors: Process, Voltage, and Temperature, collectively referred to as PVT parameters. Electronics engineers typically select multiple combinations of PVT parameters as a series of environments and strive to ensure that the chip will work in these environments during the design phase. These environments are called PVT corners.

Process variations refer to uncontrollable disturbance factors during chip manufacturing. For example, the environment of chips at the center of a wafer is different from that at the edge of the wafer; the thickness of the transistor's metal layer is not completely uniform; the doping concentration of the transistor substrate is uneven, and so on. These factors will affect the resistance and capacitance (collectively referred to as RC parameters) of the transistor, and ultimately affect the delay performance of the transistor: it may become faster or slower.

To test that the circuit can work correctly under various transistor delays, several scenarios are generally defined according to the operating speed of the transistor, which are called process corners. Process corners are usually named with two letters. The first letter represents the operating speed of nMOS, and the second letter represents the operating speed of pMOS. The operating speed is divided into three cases: typical (denoted by the letter `t`), fast (denoted by the letter `f`), and slow (denoted by the letter `s`). Among them, fast and slow are relative to the typical case. Therefore, according to the polarity and operating speed of the transistor, five process corners can be combined: `ss`, `tt`, `ff`, `sf`, and `fs`. For example, `fs` indicates a delay situation where nMOS works faster than the typical case, but pMOS works slower than the typical case.

<!-- > #### comment::tt算一个"角"吗?
> 在一个坐标轴中, 如果用X轴代表nMOS的工作速度, 用Y轴代表pMOS的工作速度,
> 那么`ss`, `ff`, `sf`和`fs`将分别落在一个矩形的四个角, 这也是"工艺角"的由来.
> 而`tt`其实落在矩形的中心, 严格来说它并不是一个"角".
> 但作为典型情况, 电子工程师还是会把它归到"工艺角"的概念中.

在上述五种工艺角中, 对于`ss`, `tt`和`ff`来说, nMOS和pMOS的工作速度基本保持一致,
因此对晶体管整体的功能没有太大影响, 只不过会影响其延迟.
但对于`sf`和`fs`来说, 由于nMOS和pMOS的工作速度一个变快而另一个变慢,
从而使得晶体管从`0`变成`1`与从`1`变成`0`时的延迟有所不同,
为了保证各种电路元件能正确工作, 元件延迟参数的确定需要更加谨慎.
不过在实际的制造过程中, 由于工艺波动也有一定的随机性,
要使得芯片中nMOS和pMOS的工作速度恰好往相反方向变化, 概率是非常低的.
因此, 电子工程师通常不会考虑`sf`和`fs`这两个工艺角. -->
> #### comment::Is "tt" considered a "corner"?
> In a coordinate system where the X-axis represents the operating speed of nMOS and the Y-axis represents the operating speed of pMOS, `ss`, `ff`, `sf`, and `fs` will each fall at the four corners of a rectangle, which is the origin of the term "process corner".
`tt`, however, actually lies at the center of the rectangle. Strictly speaking, it is not a "corner". But as a typical scenario, electronics engineers still include it in the concept of "process corners".

Among the five process corners mentioned above, for `ss`, `tt`, and `ff`, the operating speeds of nMOS and pMOS are basically consistent. Therefore, they do not have a significant impact on the overall function of the transistor, but only affect its delay. However, for `sf` and `fs`, since one of the nMOS and pMOS operates faster while the other operates slower, the delay when the transistor switches from `0` to `1` differs from that when it switches from `1` to `0`. To ensure that various circuit components can work correctly, the determination of component delay parameters needs to be more cautious. Nevertheless, in actual manufacturing processes, due to the randomness of process variations, the probability that the operating speeds of nMOS and pMOS in a chip change in exactly opposite directions is extremely low. Therefore, electronics engineers usually do not consider the `sf` and `fs` process corners.


<!-- > #### comment::工艺角和Intel处理器型号
> 由于工艺波动的存在, 同一批次的芯片可能会有不同的性能表现.
> Intel正好利用了这一点, 将同一批次中属于不同工艺角的芯片划分到不同层次的型号中进行销售.
> 例如, 在Intel Core系列中, 大部分性能表现属于`tt`工艺角的芯片以i5的型号进行销售;
> 少部分属于`ff`工艺角的芯片能运行在更高的频率, 以价格更高的i7型号进行销售, 以赚取更多利用;
> 而剩下属于`ss`工艺角的芯片只能运行在比`tt`更低的频率, 则以价格更低的i3型号进行销售,
> 避免将其作为废片丢弃. -->
> #### comment::Process Corners and Intel Processor Models
> Due to process variations, chips from the same batch may exhibit different performance. Intel has taken advantage of this by classifying chips from the same batch that belong to different process corners into different model tiers for sale.
For example, in the Intel Core series, most chips with performance corresponding to the `tt` process corner are sold under the i5 model; a small number of chips belonging to the `ff` process corner, which can run at higher frequencies, are sold under the more expensive i7 model to generate higher profits; and the remaining chips that fall into the `ss` process corner, which can only run at lower frequencies than `tt`, are sold under the cheaper i3 model. This avoids discarding them as defective chips.

<!-- 在芯片的工作环境中, 电压也并非恒定不变.
例如, 电流通过电源网络会根据其电阻形成电压降,
使得不同位置上的标准单元的输入电压并不完全相同:
靠近电源I/O单元的标准单元能获得较强的输入电压, 晶体管的工作速度较快;
而远离电源I/O单元的标准单元由于电压降的存在,
相对而言它们获得的输入电压较低, 晶体管的工作速度也相对较慢.
此外, 电源也可能会存在白噪声, 即使是对同一个位置的标准单元而言,
晶体管的工作速度也会随时间而波动.
为了应对电压的波动, 电子工程师一般需要保证电路在标准工作电压$v$
的$\pm 10\%$区间(即$[0.9v, 1.1v]$)内能正确工作.

温度也会影响晶体管的工作速度. 一方面是外部环境温度的影响,
有的芯片在工厂车间的高温环境中工作, 有的芯片在南北极的低温环境中工作.
另一方面, 即使外部环境相同, 芯片中不同位置的晶体管也会受到不同温度的影响:
在晶体管密度高或者晶体管翻转频率高的区域, 产生的热量也高.
相对于常温而言, 温度升高会使晶体管的工作速度变慢.
这是因为, 根据热力学效应, 粒子在高温状态下具有更高的能量,
因此半导体材料中的原子会在晶格中加剧振动.
受这种振动的影响, 晶体管沟道中电子移动的方向会被改变,
从而使得电流降低, 进一步使得晶体管的工作速度下降.
因此, 为了提升芯片的健壮性, 不同温度下的工作情况都需要考虑. -->
In the operating environment of a chip, the voltage is not constant either. For example, the current passing through the power supply network will form a voltage drop based on its resistance, resulting in the input voltages of standard cells at different positions not being completely the same: standard cells close to the power I/O cells can obtain a higher input voltage, and the transistors work faster; while standard cells far from the power I/O cells, due to the existence of voltage drop, relatively obtain a lower input voltage, and the working speed of the transistors is relatively slower. In addition, the power supply may also have white noise. Even for standard cells at the same position, the working speed of the transistors will fluctuate over time. To cope with voltage fluctuations, electronic engineers generally need to ensure that the circuit can work correctly within the range of $\pm 10\%$ of the standard operating voltage v (i.e., $[0.9v, 1.1v]$).

Temperature also affects the working speed of transistors. On the one hand, it is affected by the external ambient temperature. Some chips work in the high-temperature environment of factory workshops, and some work in the low-temperature environment of the North and South Poles. On the other hand, even if the external environment is the same, transistors at different positions in the chip will be affected by different temperatures: areas with high transistor density or high transistor switching frequency generate more heat. Compared with normal temperature, an increase in temperature will slow down the working speed of transistors. This is because, according to thermodynamic effects, particles have higher energy at high temperatures, so atoms in semiconductor materials will vibrate more intensely in the crystal lattice. Affected by this vibration, the direction of electron movement in the transistor channel will be changed, resulting in a decrease in current, which further reduces the working speed of the transistor. Therefore, to improve the robustness of the chip, the working conditions at different temperatures need to be considered.


<!-- LIB文件的命名中通常会包含PVT角的信息,
例如, ``ss_100C_1v60``表示工艺角为`ss`, 温度为`100`摄氏度, 电压为`1.60V`;
``ff_n40C_1v95``表示工艺角为`ff`, 温度为`-40`摄氏度, 电压为`1.95V`.
在集成电路领域, 类似`1v60`这种用单位替代小数点`.`的命名方式很常见.
一方面, 一些早期的文件系统或EDA工具不支持文件名中包含小数点;
另一方面, 在书写密集的技术文档或字体很小的板卡上,
`1v60`的视觉区分效果比`1.60v`更好, 尤其是小数点很容易看漏.
用字母`n`(表示`negative`)替代负号`-`也是出于相似的考虑.
此外, 不同厂商采用的命名规范可能有所不同,
包括用字母`p`(表示`point`)替代小数点(如用`v1p60`表示`1.60V`),
用字母`m`(表示`minus`)替代负号(如用`m40C`表示`-40`摄氏度)等. -->
The naming of LIB files usually includes information about PVT corners. For example, ``ss_100C_1v60`` indicates a process corner of `ss`, a temperature of `100` degrees Celsius, and a voltage of `1.60V`; ``ff_n40C_1v95`` indicates a process corner of `ff`, a temperature of `-40` degrees Celsius, and a voltage of `1.95V`.
In the integrated circuit field, the naming convention that uses a letter to replace the decimal point `.`, such as `1v60`, is very common. On one hand, some early file systems or EDA tools did not support decimal points in file names. On the other hand, in densely written technical documents or on boards with small fonts, `1v60` has a better visual distinguishability than `1.60v`, especially since the decimal point is easily overlooked. The use of the letter `n` (representing `negative`) to replace the minus sign `-` is for similar reasons.
In addition, different manufacturers may adopt different naming conventions. For instance, some use the letter `p` (representing `point`) to replace the decimal point (e.g., `v1p60` for `1.60V`), and some use the letter `m` (representing `minus`) to replace the minus sign (e.g., `m40C` for `-40` degrees Celsius).

<!-- > #### todo::尝试不同PVT角的评估结果
> nangate45提供了不同PVT角的LIB文件(位于`yosys-sta/pdk/nangate45/lib/`目录下).
> 尝试为`yosys-sta`项目更换不同PVT角的LIB文件(在`yosys-sta/pdk/nangate45.tcl`中指定),
> 然后重新评估电路的性能, 对比不同PVT角下的评估结果.

由于PVT角描述的是标准单元在不同环境下的工作情况,
因此, 同一个标准单元在不同的PVT角下, 其内部结构和几何形状是完全一样的,
因此只需要在不同的LIB文件中不同PVT角的时序信息和功耗信息.
用EDA工具在某个PVT角下设计一款芯片,
其实是回答"如果芯片将来在这个PVT角所描述的环境中工作, 其表现如何"的问题.
而芯片的实测表现与其真实的工作环境相关,
如果实际工作环境和设计芯片时采用的PVT角不一致,
则EDA工具报告的信息并不能完全代表芯片实测的表现. -->
> #### todo::Try Evaluation Results of Different PVT Corners
> Nangate45 provides LIB files for different PVT corners (located in the `yosys-sta/pdk/nangate45/lib/ directory`).
Try to replace the LIB files for different PVT corners in the `yosys-sta` project (specified in `yosys-sta/pdk/nangate45.tcl`), then re-evaluate the circuit performance and compare the evaluation results under different PVT corners.

Since PVT corners describe the working conditions of standard cells in different environments, the internal structure and geometry of the same standard cell are exactly the same under different PVT corners. Therefore, it is only necessary to include timing information and power consumption information for different PVT corners in different LIB files. Designing a chip with EDA tools under a certain PVT corner is actually answering the question: "How will the chip perform if it works in the environment described by this PVT corner in the future?" The actual measured performance of the chip is related to its real working environment. If the actual working environment is inconsistent with the PVT corner used when designing the chip, the information reported by EDA tools cannot fully represent the actual measured performance of the chip.

<!-- > #### todo::PVT角和超频
> 某发烧友群体采用水冷甚至液氮等技术对处理器进行超频,
> 成功让计算机稳定地运行在更高的工作频率.
> 尝试从PVT角的角度分析为什么采用这些技术后可以成功超频.

> #### comment::厂商的营销策略
> 一些厂商可能会利用PVT角与实际工作环境的差异来进行营销.
> 例如, 某厂商在芯片设计阶段采用`ff_n40C_1v95`这个PVT角,
> EDA工具报告芯片最高可运行在2GHz的频率,
> 厂商便宣称其芯片频率达到2GHz.
> 但用户购买该厂商的芯片或搭载该芯片的相关产品后,
> 发现芯片最高只能运行在1.5GHz.
>
> 一方面, 用户是在常温(约`25`摄氏度)环境下使用芯片产品, 并不是`-40`摄氏度;
> 另一方面, 在一批芯片中, 工艺波动处于典型情况的芯片占大多数,
> 大部分用户购买到的都是这部分芯片, 而工艺波动落在`ff`范围内的芯片则是占少数.
> 如果厂商在设计阶段采用`tt_25C_1v95`这个PVT角,
> EDA工具报告的数据将更接近用户实际使用的情况.
>
> 因此, 如果厂商广告中的频率不是实测数据,
> 还需要关注相关数据是在哪个PTV角下评估得到的,
> 从而对将来芯片的工作情况进行更加客观的估计. -->
> #### todo::PVT Corners and Overclocking
> Some enthusiast groups use water cooling or even liquid nitrogen to overclock processors, successfully enabling computers to run stably at higher operating frequencies. Try to analyze why these technologies allow successful overclocking from the perspective of PVT corners.

> #### comment::Manufacturers' Marketing Strategies
> Some manufacturers may leverage the differences between PVT corners and actual operating environments for marketing purposes. For example, a manufacturer uses the PVT corner `ff_n40C_1v95` during the chip design phase. EDA tools report that the chip can run at a maximum frequency of 2GHz, so the manufacturer claims that its chip reaches a 2GHz frequency. However, after users purchase the manufacturer's chips or related products equipped with these chips, they find that the chips can only run at a maximum of 1.5GHz.
>
> On one hand, users use chip products at room temperature (about `25` degrees Celsius) rather than `-40` degrees Celsius. On the other hand, among a batch of chips, those with typical process variations account for the majority, and most users purchase these chips, while those with process variations in the ff range are in the minority. If the manufacturer uses the PVT corner `tt_25C_1v95` during the design phase, the data reported by EDA tools will be closer to the actual usage of users.
>
> Therefore, if the frequency in a manufacturer's advertisement is not measured data, it is necessary to pay attention to the PVT corner under which the relevant data is evaluated, so as to make a more objective estimate of the future working conditions of the chip.

<!-- ### 阈值电压

回顾晶体管的工作原理, 栅极电压与源极电压之间的差值必须达到某个阈值,
晶体管才能导通, 否则晶体管截止.
对于不同阈值的晶体管, 其电气属性有所不同,
因此用不同阈值的晶体管搭建的标准单元, 其特性也有所不同.

不同阈值电压的标准单元主要用于在延迟和静态功耗之间取得权衡.
具体地, 对于阈值电压较高的标准单元,
需要花费更多时间才能让晶体管从截止状态变成导通状态, 因此延迟较高.
而对于静态功耗, 如上文所述, 它主要由漏电电流产生.
在目前的CMOS技术中, 漏电电流中占比最多的部分是亚阈值电流(sub-threshold current).
之所以存在亚阈值电流, 是因为晶体管从导通状态转换为截止状态时,
并非瞬间就进入完美的截止状态, 而是进入了"亚阈值"状态.
在这种状态下, 栅极附近仍然存在微弱的电场, 在其作用下仍然会吸引少量电子.
这些电子虽然不足以形成沟道连通源极和漏极,
但它们仍然会产生从漏极到源极的微小电流, 这就是亚阈值电流.
如果其他因子不变, 亚阈值电流$I_{sub}$和阈值电压$V_T$之间存在如下关系:
$$I_{sub} \propto Ae^{-BV_T}$$
其中$A$和$B$是两个与$V_T$无关的因子.
由于亚阈值电流在漏电电流中占比较大, 因此静态功耗可近似看成:
$$P_{static} = V_{DD}\cdot I_{leakage} \approx V_{DD}\cdot I_{sub} \propto V_{DD}\cdot Ae^{-BV_T}$$
其中, $V_{DD}$为电源电压.
可以看到, 阈值电压越高, 漏电电流越低, 静态功耗也越低.
相反, 当阈值电压降低时, 静态功耗却呈指数增长. -->
### Threshold Voltage

Recalling the working principle of a transistor, the difference between the gate voltage and the source voltage must reach a certain threshold for the transistor to conduct; otherwise, the transistor remains off. Transistors with different thresholds have different electrical properties, so standard cells built with transistors of different thresholds also have distinct characteristics.

Standard cells with different threshold voltages are mainly used to strike a balance between delay and static power consumption. Specifically, for standard cells with a higher threshold voltage, it takes more time for the transistor to switch from the off state to the on state, resulting in higher delay. As for static power consumption, as mentioned earlier, it is mainly caused by leakage current. In current CMOS technology, the largest component of leakage current is the sub-threshold current. The existence of sub-threshold current is because when a transistor switches from the on state to the off state, it does not instantly enter a perfect off state but instead enters a "sub-threshold" state. In this state, there is still a weak electric field near the gate, which can still attract a small number of electrons. Although these electrons are not enough to form a channel connecting the source and the drain, they still generate a tiny current from the drain to the source, which is the sub-threshold current.
Assuming other factors remain unchanged, the relationship between the sub-threshold current $I_{sub}$ and the threshold voltage \(V_T\) is as follows:
$$I_{sub} \propto Ae^{-BV_T}$$
where $A$ and $B$ are two factors independent of $V_T$. Since the sub-threshold current accounts for a large proportion of the leakage current, the static power consumption can be approximately expressed as:
$$P_{static} = V_{DD}\cdot I_{leakage} \approx V_{DD}\cdot I_{sub} \propto V_{DD}\cdot Ae^{-BV_T}$$
where $V_{DD}$ is the supply voltage. It can be seen that the higher the threshold voltage, the lower the leakage current and the lower the static power consumption. Conversely, when the threshold voltage decreases, the static power consumption increases exponentially.


<!-- 不过, 对于逻辑功能相同但阈值电压不同的标准单元, 其面积通常相同.
这是因为不同阈值电压是通过调整晶体管本身的参数来实现的,
如衬底的参杂浓度, 栅极绝缘层的厚度等,
这些参数的调整并不影响标准单元中晶体管的大小和排布,
因此不会影响标准单元的面积.

通常将标准单元按阈值电压分如下几类:
HVT(High Threshold Voltage), SVT(Standard Threshold Voltage),
LVT(Low Threshold Voltage)和ULVT(Ultra-Low Threshold Voltage).
其中, HVT的阈值电压最高, 其静态功耗最低, 但延迟最高;
ULVT则相反, 其阈值电压最低, 延迟也最低, 但静态功耗最大.
有一些厂商将SVT称为RVT(Regular Threshold Voltage).
有一些工艺节点还提供UHVT(Ultra-High Threshold Voltage)的标准单元供用户选择.
不过, nangate45暂未提供不同阈值电压的标准单元,
因此可认为只提供了SVT的标准单元.

电子工程师需要根据芯片的应用场景, 选择合适阈值电压的标准单元来设计芯片.
例如, 在低功耗应用场景中, 偏向选择HVT;
在高性能应用场景中, 偏向选择LVT甚至ULVT.
在两个目标都追求的场合, 可以选择混合设计方式,
即在影响频率的关键路径上使用LVT或ULVT,
从而降低关键路径的延迟, 提升芯片的频率;
在不影响频率的非关键路径上使用SVT或HVT,
从而在不降低芯片频率的情况下, 降低芯片整体的静态功耗.
例如, 根据[体系结构领域国际顶级会议MICRO上发表的"香山"论文][xiangshan micro paper],
第一代"香山"处理器芯片中不同电压阈值的标准单元的比例为:
ULVT 1.04%, LVT 19.32%, SVT 25.19%, HVT 53.67%. -->
However, standard cells with the same logical function but different threshold voltages usually have the same area. This is because different threshold voltages are achieved by adjusting the parameters of the transistors themselves, such as the doping concentration of the substrate and the thickness of the gate dielectric. These parameter adjustments do not affect the size and arrangement of the transistors in the standard cell, so they will not affect the area of the standard cell.

Standard cells are usually classified by threshold voltage into the following categories: HVT (High Threshold Voltage), SVT (Standard Threshold Voltage), LVT (Low Threshold Voltage), and ULVT (Ultra-Low Threshold Voltage). Among them, HVT has the highest threshold voltage, the lowest static power consumption, but the highest delay; ULVT is the opposite, with the lowest threshold voltage, the lowest delay, but the highest static power consumption. Some manufacturers refer to SVT as RVT (Regular Threshold Voltage). Some process nodes also provide UHVT (Ultra-High Threshold Voltage) standard cells for users to choose from. However, nangate45 does not currently provide standard cells with different threshold voltages, so it can be considered that only SVT standard cells are provided.
Electronic engineers need to select standard cells with appropriate threshold voltages to design chips according to the application scenarios of the chips. For example, in low-power application scenarios, HVT is preferred; in high-performance application scenarios, LVT or even ULVT is preferred. In occasions where both goals are pursued, a hybrid design approach can be chosen, that is, using LVT or ULVT in the critical paths that affect the frequency, thereby reducing the delay of the critical paths and increasing the frequency of the chip; using SVT or HVT in non-critical paths that do not affect the frequency, so as to reduce the overall static power consumption of the chip without reducing the chip frequency. For example, according to the "Xiangshan" paper published in MICRO, a top international conference in the field of architecture, the proportion of standard cells with different voltage thresholds in the first-generation "Xiangshan" processor chip is: ULVT 1.04%, LVT 19.32%, SVT 25.19%, HVT 53.67%.

[xiangshan micro paper]: https://ieeexplore.ieee.org/abstract/document/9923860


<!-- ### 轨道数

轨道(track)数是标准单元的其中一个属性, 它是标准单元高度的另一种衡量.
这里的"高度"(height)并不是指标准单元在三维空间中$z$轴方向投影的长度,
而是在$y$轴方向投影的长度;
相应地, 标准单元在$x$轴方向投影的长度称为"宽度"(width).
因此, 后端设计在尺寸描述上的术语和数学三维空间中使用习惯有所不同,
后端设计中的"宽度", "高度"和"厚度", 分别对应数学三维空间中"长度", "宽度"和"高度".

我们已经知道, 金属层的`PITCH`属性描述了该层的最小走线间距.
为了方便EDA工具开展布局布线工作, 通常会让标准单元的高度取`PITCH`属性的整数倍,
这个倍数就是标准单元的轨道数.
金属层有很多, 但标准单元一定会使用M1金属层,
因此通常用M1金属层的`PITCH`属性作为轨道数计算的参考.

在一种标准单元库中, 标准单元的高度通常是相同的, 从而方便EDA工具开展布局工作.
因此, 也可以通过轨道数的角度来描述不同标准单元库的标准单元.
例如, 某标准单元库的标准单元轨道数为6, 则称为"6T标准单元". -->


<!-- > #### todo::确定nangate45的轨道数
> 尝试在相关文件中找到需要的参数, 计算nangate45标准单元的轨道数.

轨道数较少的标准单元(如6T, 7T), 其面积较小, 功耗较低,
但驱动能力较弱, 使得晶体管翻转时间较长, 故性能不高;
相反, 轨道数较多的标准单元(如12T, 13T),
则具备较高的性能, 但面积较大, 功耗也较高;
也有轨道数处于两者之间的标准单元(如9T, 10T),
它们在性能，面积和功耗等指标上相对平衡.

有的PDK会提供不同轨道数的多种标准单元库.
电子工程师需要根据芯片的应用场景, 选择合适轨道数的标准单元来设计芯片.
不过在选定标准单元库后, 电路中无法混合使用不同轨道数的标准单元.
这和阈值电压不同, 因为一个标准单元库中也可以包含多种阈值电压的标准单元, 它们可以混合使用.
例如, skywater130的PDK提供了如下的标准单元库: -->
> #### todo::Determine the number of tracks in nangate45
> Attempt to find the required parameters in relevant files and calculate the number of tracks in nangate45 standard cells.

Standard cells with fewer tracks (such as 6T, 7T) have smaller areas and lower power consumption, but their driving capability is weaker, resulting in longer transistor switching times and thus lower performance. On the contrary, standard cells with more tracks (such as 12T, 13T) have higher performance but larger areas and higher power consumption. There are also standard cells with a track count between the two (such as 9T, 10T), which achieve a relatively balanced performance in terms of indicators like performance, area, and power consumption.
Some PDKs provide multiple standard cell libraries with different numbers of tracks. Electronics engineers need to select standard cells with an appropriate number of tracks for chip design based on the application scenarios of the chip. However, after selecting a standard cell library, it is impossible to mix standard cells with different track counts in the circuit. This is different from threshold voltages, because a standard cell library can also include standard cells with multiple threshold voltages, which can be mixed and used. For example, the PDK of skywater130 provides the following standard cell libraries:

<!-- | 标准单元库          |  特征                     | 轨道数 | 网格单元      |
|:-------------------:|:-------------------------:|:------:|:-------------:|
| `sky130_fd_sc_hd`   | high density              |   9T   | `0.46 x 2.72` |
| `sky130_fd_sc_hdll` | high density, low leakage |   9T   | `0.46 x 2.72` |
| `sky130_fd_sc_hs`   | high speed                |   11T  | `0.48 x 3.33` |
| `sky130_fd_sc_ms`   | medium speed              |   11T  | `0.48 x 3.33` |
| `sky130_fd_sc_ls`   | low speed                 |   11T  | `0.48 x 3.33` |
| `sky130_fd_sc_lp`   | low power                 |   11T  | `0.48 x 3.33` |
| `sky130_fd_sc_hvl`  | high voltage              |   14T  | `0.48 x 4.07` | -->
| Standard Cell Library    |  Characteristics        | Track Number | Grid Cell   |
|:-------------------:|:-------------------------:|:------:|:-------------:|
| `sky130_fd_sc_hd`   | high density              |   9T   | `0.46 x 2.72` |
| `sky130_fd_sc_hdll` | high density, low leakage |   9T   | `0.46 x 2.72` |
| `sky130_fd_sc_hs`   | high speed                |   11T  | `0.48 x 3.33` |
| `sky130_fd_sc_ms`   | medium speed              |   11T  | `0.48 x 3.33` |
| `sky130_fd_sc_ls`   | low speed                 |   11T  | `0.48 x 3.33` |
| `sky130_fd_sc_lp`   | low power                 |   11T  | `0.48 x 3.33` |
| `sky130_fd_sc_hvl`  | high voltage              |   14T  | `0.48 x 4.07` |

<!-- > #### option::了解skywater130
> skywater130作为一个可生产的开源PDK,
> 提供了丰富的标准单元库, 包括不同的PVT角,
> 不同的阈值电压, 不同的轨道数等, 整个PDK大小高达20GB.
> 如果你感兴趣, 可以[下载skywater130][sky130 github]并进一步了解其中的各种细节. -->
> #### option::Learn about skywater130
> As a producible open-source PDK, skywater130 offers a rich set of standard cell libraries, including different PVT corners, different threshold voltages, and different track counts. The entire PDK size is as large as 20GB.
If you are interested, you can [download skywater130][sky130 github] and further explore its various details.

[sky130 github]: https://github.com/google/skywater-pdk

<!-- ## 物理设计(Physical Design) - 从网表到可流片版图

物理设计是指将网表中记录的标准单元及其连接关系映射到真实芯片三维空间的过程.
具体地, 负责物理设计的EDA工具需要确定好每个标准单元在芯片中的坐标,
还需要确定走线的走向, 使得走线可以按照网表中的连接关系,
将位于不同坐标的标准单元连接起来, 从而实现和网表逻辑一致的功能.
记录标准单元的坐标以及走线走向的文件, 就是上文提到的GDS版图文件.
最后, EDA工具还需要评估得到的芯片是否能被正确地制造, 芯片的指标是否满足预期等.

理解芯片的工艺结构之后, 你就可以理解物理设计的本质了.
物理设计的过程就是确定每一层中的内容:
在低层的什么位置摆放什么标准单元(布图规划, 布局),
如何在中层连接这些标准单元(布线),
如何在高层规划电源(电源规划)和时钟(时钟树综合),
以及每一层的面积应该取多大(布图规划).
下面我们逐一介绍这些阶段需要开展哪些工作. -->
## Physical Design - From Netlist to Tapeout-Ready Layout

Physical design refers to the process of mapping the standard cells and their connection relationships recorded in the netlist to the three-dimensional space of a real chip.
Specifically, EDA tools responsible for physical design need to determine the coordinates of each standard cell in the chip, as well as the routing direction of the wires. This ensures that the wires can connect standard cells located at different coordinates according to the connection relationships in the netlist, thereby achieving functions consistent with the netlist logic. The file that records the coordinates of standard cells and the routing directions is the GDS layout file mentioned above. Finally, EDA tools also need to evaluate whether the resulting chip can be manufactured correctly and whether the chip's indicators meet expectations.

After understanding the process structure of the chip, you can grasp the essence of physical design.
The process of physical design is to determine the content in each layer:
Where to place which standard cells in the lower layers (floorplanning, placement)
How to connect these standard cells in the middle layers (routing)
How to plan power (power planning) and clocks (clock tree synthesis) in the upper layers
What size the area of each layer should be (floorplanning)
Let's introduce the work to be carried out in each of these stages one by one.

<!-- ```
---------------------   M7    <----- 电源规划
  | | | | | | | | |
---------------------   M6    <----- 时钟树综合
  | | | | | | | | |
---------------------   M5    <-+
  | | | | | | | | |             +--- 布线
---------------------   M4    <-+
  | | | | | | | | |
---------------------   M3    <-+
  | | | | | | | | |             |
---------------------   M2    <-+--- 布图规划, 布局
  | | | | | | | | |             |
---------------------   M1    <-+
  | | | | | | | | |             |
=====================  多晶硅 <-+
+++++++++++++++++++++  绝缘层
ooooooooooooooooooooo  硅衬底
``` -->
```
---------------------   M7    <----- Power Planning
  | | | | | | | | |
---------------------   M6    <----- Clock Tree Synthesis
  | | | | | | | | |
---------------------   M5    <-+
  | | | | | | | | |             +--- Routing
---------------------   M4    <-+
  | | | | | | | | |
---------------------   M3    <-------+
  | | | | | | | | |                   |
---------------------   M2    <-------+--- Floorplanning, Placement
  | | | | | | | | |                   |
---------------------   M1    <-------+
  | | | | | | | | |                   |
=====================  Poly-silicon <-+
+++++++++++++++++++++  dielectric
ooooooooooooooooooooo  Silicon Substrate
```

<!-- 由于物理设计涉及真正的电路,
因此物理设计工程师需要理解电子领域的相关知识才能很好地胜任相关工作.
不过在"一生一芯"中, 你只需要大致了解从网表转换为可流片版图都经历了哪些步骤,
从而帮助你在将来理解逻辑设计(即RTL设计)和物理设计之间有哪些相互影响之处,
你不必深入了解甚至记忆物理设计过程中的所有细节. -->
Since physical design involves actual circuits, physical design engineers need to understand relevant knowledge in the field of electronics to be competent in their work. However, in "OSOC", you only need to roughly understand the steps involved in converting a netlist into a tapeout-ready layout. This will help you understand the mutual influences between logical design (i.e., RTL design) and physical design in the future. You do not need to delve into or even memorize all the details of the physical design process.

<!-- ### 布图规划(Floorplan)

布图规划的主要任务是确定芯片的大小, 并且摆放一些在后续流程中不会调整位置的单元.
布图规划的工作主要包括以下内容. -->
### Floorplan

The main task of floorplan is to determine the size of the chip and place some cells whose positions will not be adjusted in subsequent processes. The work of floorplan mainly includes the following contents.

<!-- #### 确定芯片大小

与标准单元的面积类似, 芯片大小(die size)是指芯片在平面$xOy$中投影的面积,
也即芯片俯视图所得矩形的面积, 同时也是芯片中每一层金属层的面积, 故也称芯片面积.
芯片的厚度(即$z$轴方向的长度)和选取的工艺相关, 如上文提到的`1P7M`.
一般来说, 选定一种工艺后, 芯片的厚度并非一个可以调整的参数,
因此物理设计阶段通常不关心芯片的厚度.

根据芯片的工艺结构, 芯片面积主要由晶体管的面积和走线的面积构成.
晶体管的面积主要包括硅衬底的源极和漏极所占的面积, 加上多晶硅层的栅极所占的面积.
不过, 标准单元库会给出每个标准单元所占用的面积, 因此用户或EDA工具无需考虑晶体管层次的尺寸.
而走线分垂直方向(即$z$轴方向)和水平方向两种,
前者会经过金属层之间的通孔, 在平面$xOy$的投影为一个点;
后者在金属层内部延伸, 在平面$xOy$的投影为一条线.
表面上看这两种情况都不占用面积, 但根据工艺制造的要求,
通孔之间以及走线之间都存在最小间距, 否则将会发生信号干扰甚至短路,
因此实际上走线也会占用一定的面积. -->
#### Determining the Chip Size

Similar to the area of standard cells, the die size refers to the projected area of the chip on the $xOy$ plane, which is the area of the rectangle obtained from the top view of the chip. It is also the area of each metal layer in the chip, hence also called the chip area. The thickness of the chip (i.e., the length in the $z$-axis direction) is related to the selected process, such as the `1P7M` mentioned above. Generally, once a process is selected, the thickness of the chip is not an adjustable parameter, so the physical design stage usually does not concern itself with the chip's thickness.

Based on the chip's process structure, the chip area is mainly composed of the area occupied by transistors and the area occupied by routing. The area of transistors mainly includes the area occupied by the source and drain of the silicon substrate, plus the area occupied by the gate of the polysilicon layer. However, the standard cell library provides the area occupied by each standard cell, so users or EDA tools do not need to consider the dimensions at the transistor level. Routing is divided into vertical direction (i.e., $z$-axis direction) and horizontal direction. The former passes through vias between metal layers, with a projection on the $xOy$ plane as a point; the latter extends within the metal layer, with a projection on the $xOy$ plane as a line. On the surface, neither of these two cases occupies area, but according to the requirements of process manufacturing, there are minimum distances between vias and between routing lines. Otherwise, signal interference or even short circuits will occur. Therefore, in practice, routing also occupies a certain area.

<!-- 由于此时还没有开展布线工作, 因此无法得到走线所占的具体面积.
在布图规划阶段, 一般是通过综合所得的面积报告(即标准单元所占总面积)来估算芯片大小.
估算时, 工程师需要考虑标准单元总面积占芯片总面积的预期比例,
这个比例称为利用率(utilization).
根据经验, 利用率一般在60%~80%左右.
例如, 假设某芯片综合后, 其标准单元总面积约$700000um^2$,
某工程师预期能做到70%的利用率,
那么在布图规划阶段, 可以估算芯片大小为$700000um^2/0.7 = 1000000um^2 = 1mm^2$.

利用率的选取需要在成本和设计难度之间进行权衡.
如果利用率较高, 说明留给布线阶段的空间较小,
布线阶段就容易发生拥堵而进行长距离走线,
从而增加了线延迟, 使得芯片频率下降,
甚至可能因为过分拥堵而失败, 无法完成物理设计;
如果利用率较低, 则芯片中空余的面积较大, 造成浪费,
而芯片的制造费用一般和面积成正比, 从而引入不必要的成本开销. -->
Since routing work has not yet been carried out at this point, the specific area occupied by the routing cannot be determined. In the floorplanning stage, the chip size is generally estimated based on the area report obtained from synthesis (i.e., the total area occupied by standard cells). For estimation, engineers need to consider the expected proportion of the total area of standard cells to the total chip area, and this proportion is called utilization. Based on experience, the utilization rate is generally around 60% to 80%. For example, suppose after synthesis, the total area of standard cells of a chip is approximately $700000um^2$, and an engineer expects a utilization rate of 70%. Then, in the floorplanning stage, the estimated chip size can be $700000um^2/0.7 = 1000000um^2 = 1mm^2$.

The selection of utilization rate requires a trade-off between cost and design difficulty. A higher utilization rate means less space left for the routing stage, which makes it easier to encounter congestion during routing and requires long-distance wiring. This increases wire delay, reduces the chip frequency, and may even lead to failure due to excessive congestion, making it impossible to complete the physical design. On the other hand, a lower utilization rate results in a larger amount of redundant area in the chip, causing waste. Since the manufacturing cost of a chip is generally proportional to its area, this introduces unnecessary cost expenses.

<!-- 工程师需要根据芯片属性和自身经验来选择目标利用率:
对于小芯片, 其拓扑较简单, 布局布线相对容易成功, 因此可以设置较高的利用率;
而复杂的大芯片则不宜设置过高的利用率, 需要为布线阶段预留足够的空间.
有经验的工程师可以设置更高的利用率, 而新手在前期可以从低利用率开始积累经验.
在大型项目中, 工程师一般会开展多轮的物理设计,
根据前一轮的设计结果(过度拥挤或剩余面积过多)来调整后一轮的参数,
从而不断优化物理设计的结果, 在不引入过多成本的情况下实现预期的性能目标. -->
Engineers need to select the target utilization rate based on the chip's characteristics and their own experience:
For small chips, their topology is relatively simple, and placement and routing are easier to achieve successfully, so a higher utilization rate can be set.
For complex large chips, however, a too high utilization rate is not appropriate, as sufficient space needs to be reserved for the routing stage.
Experienced engineers can set a higher utilization rate, while novices can start with a lower utilization rate in the early stages to accumulate experience. In large-scale projects, engineers typically conduct multiple rounds of physical design. They adjust the parameters of subsequent rounds based on the results of the previous round (such as excessive congestion or excessive remaining area), thereby continuously optimizing the physical design outcomes and achieving the expected performance goals without incurring excessive costs.

<!-- #### 确定芯片边长

确定大致面积后, 还需要考虑芯片的边长, 即芯片在$x$轴和$y$轴两个方向上的长度.
影响边长的因素除了标准单元的综合面积, 还需要考虑芯片引脚的数量.
引脚数量的影响又与封装方案有关.
一种常见的封装方案是QFP(Quad Flat Package，四侧引脚扁平封装),
这种方案的引脚会分布在芯片的四周, 因此芯片边长会与引脚数量成正比. -->
#### Determining the Chip Side Lengths

After determining the approximate area, it is also necessary to consider the chip's side lengths, i.e., the lengths of the chip along the $x$-axis and $y$-axis directions.
Factors affecting the side lengths include not only the synthesized area of standard cells but also the number of chip pins. The impact of the number of pins is, in turn, related to the packaging scheme.
A common packaging scheme is QFP (Quad Flat Package), where pins are distributed around the four sides of the chip. Therefore, the side lengths of the chip are proportional to the number of pins.

```
         |    |    |
    +----+----+----+----+
    |                   |
 ---+                   +---
    |                   |
 ---+                   +---
    |                   |
 ---+                   +---
    |                   |
    +----+----+----+----+
         |    |    |
```

<!-- 一个芯片引脚需要对应一个I/O单元, 因此芯片引脚数量对芯片边长的影响,
其实是通过I/O单元的尺寸反映出来的.
一方面, 如上文所述, I/O单元的尺寸比一般的标准单元要大好几个数量级.
另一方面, 由于部分I/O单元需要承担供电的任务, 无法用于通信,
因此实际需要规划的引脚总数要多于用于通信的引脚.
供电引脚的比例和分布密度与芯片的尺寸, 工艺, 功耗等属性有关,
工艺相关的手册会给出推荐的供电引脚排布方案.
但通常来说, 尺寸越大, 功耗越高, 需要的供电量也越大, 供电引脚的数量也更多.

例如, 某芯片需要90个引脚进行通信, 假设需要1/3的引脚用于供电,
则实际需要$90/(1-1/3) = 135$个引脚, 故应选择144脚这种常见的封装方案.
如果让引脚在四周均匀分布, 则每条边大约需要放置$144/4 = 38$个引脚.
假设该芯片采用某130nm工艺进行设计, 一个I/O单元的尺寸为$80um\times 180um$,
该工艺允许I/O单元之间可以紧挨着排布,
那么芯片的一条边长为$38\times80um = 3040um$,
芯片的最小面积为$3040um\times3040um = 9.24mm^2$.
也即, 如果采用这种封装方案, 即使按照利用率估算出芯片大小为$1mm^2$,
考虑引脚和封装方案后仍然需要规划$9.24mm^2$的芯片面积.
有的工艺要求I/O单元之间预留一定的间隙,
这时芯片的边长将会更长, 最小面积也会更大. -->
Each pin of a chip corresponds to an I/O cell, so the influence of the number of chip pins on the chip's side lengths is actually reflected through the size of the I/O cells.
On one hand, as mentioned earlier, the size of an I/O cell is several orders of magnitude larger than that of a general standard cell.
On the other hand, since some I/O cells need to undertake the task of power supply and cannot be used for communication, the total number of pins that actually need to be planned is more than the number of pins used for communication.
The proportion and distribution density of power supply pins are related to the chip's size, process, power consumption and other attributes. Process-related manuals will provide recommended layouts for power supply pins.
But generally speaking, the larger the size and the higher the power consumption of the chip, the greater the power supply required, and the more the number of power supply pins.

For example, if a chip requires 90 pins for communication and it is assumed that 1/3 of the pins are needed for power supply, then the actual number of pins required is $90/(1-1/3) = 135$. Therefore, a common packaging scheme with 144 pins should be chosen. If the pins are evenly distributed around the four sides, each side will need to place approximately $144/4 = 38$ pins. Suppose the chip is designed using a 130nm process, and the size of an I/O cell is $80um\times 180um$. This process allows I/O cells to be arranged closely next to each other. Then, the length of one side of the chip is $38\times80um = 3040um$, and the minimum area of the chip is $3040um\times3040um = 9.24mm^2$. That is to say, if this packaging scheme is adopted, even if the estimated chip size based on utilization is $1mm^2$, the chip area still needs to be planned as $9.24mm^2$ after considering the pins and packaging scheme. Some processes require a certain gap to be reserved between I/O cells, in which case the side length of the chip will be longer and the minimum area will be larger.

<!-- > #### comment::芯片的形状必须是正方形吗?
> 正方形的对称性可以减轻后续某些工作的负担, 如电源规划, 时钟树综合等,
> 这些工作要求从源点到所有目标点的距离不能相差过大.
> 但实际上, 芯片的边长可以不相同.
> 只要能放置所需要的I/O单元, 成功进行物理设计(如布线成功),
> 并且芯片满足厂商指定的制造约束, 并且封装方案可实施, 芯片都是可以投片生产的.

因此, 芯片引脚数量作为一种资源, 需要在项目前期的规格定义阶段就明确其需求.
同时, 我们也可以通过引脚数量快速估计芯片的最小面积.
例如, 某芯片只需要28个引脚进行通信,
按照同样的供电引脚比例进行计算, 可采用44脚的封装方案.
在上述130nm工艺下, 芯片的最小面积为$(11\times 80um)^2 = 0.77mm^2$.

另一个可能会影响芯片尺寸的因素是特殊的宏单元.
由于宏单元已经被预先设计好, 其形状是固定的.
为了摆放某些特殊的宏单元, 需要芯片的边长满足一定的要求.
例如, 有一些DDR phy模块需要摆放在芯片的I/O边界上,
并且形状是L型的, 这就要求芯片长边必须长于L型形状的长边,
否则这个DDR phy模块将无法摆放.

综合上述条件可以初步确定芯片的尺寸, 其俯视图如下图所示. -->
> #### comment::Must a chip be square in shape?
> The symmetry of a square can ease the burden of certain subsequent tasks, such as power planning and clock tree synthesis, which require that the distances from the source point to all target points do not differ too much.
However, in reality, the side lengths of a chip can be different.
A chip can be taped out and produced as long as it can accommodate the required I/O cells, successfully complete physical design (such as successful routing), meet the manufacturing constraints specified by the manufacturer, and have a feasible packaging scheme.

Therefore, the number of chip pins, as a kind of resource, needs to have its requirements clearly defined in the specification definition stage at the early stage of the project.
At the same time, we can also quickly estimate the minimum area of the chip through the number of pins.
For example, if a chip only needs 28 pins for communication, according to the same calculation of the proportion of power supply pins, a 44-pin packaging scheme can be adopted.
Under the above-mentioned 130nm process, the minimum area of the chip is $(11\times 80um)^2 = 0.77mm^2$.

Another factor that may affect the chip size is special macro cells.
Since macro cells are pre-designed, their shapes are fixed.
In order to place certain special macro cells, the side lengths of the chip need to meet certain requirements.
For example, some DDR phy modules need to be placed on the I/O boundary of the chip and have an L-shaped form. This requires that the long side of the chip must be longer than the long side of the L-shape; otherwise, this DDR phy module cannot be placed.By integrating the above conditions, the size of the chip can be initially determined, and its top view is as shown in the following figure.
```
+-----------------------------------------+
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
|                                         |
+-----------------------------------------+
```

<!-- #### 摆放I/O单元

确定好芯片的边长后, 接下来就可以在芯片四周摆放I/O单元了.
一般I/O单元的摆放会遵循以下做法:
* 将功能相近的顶层端口对应的数据I/O单元摆放在物理上相邻的位置.
  数据I/O单元在逻辑上对应整个设计的顶层端口,
  它会通过走线连接到芯片内部的标准单元.
  因此, 这种摆放方式有利于降低布线阶段中的线延迟(如下图的`A`和`B`两个端口).
  否则, 若将功能相近的端口摆放在芯片的两侧甚至对角,
  必定有其中一端需要经过较长的走线才能到达目标标准单元. -->
#### Placing I/O Cells

After determining the chip's side lengths, the next step is to place I/O cells around the chip. Generally, the placement of I/O cells follows these practices:
* Place data I/O cells corresponding to functionally similar top-level ports in physically adjacent positions. Data I/O cells logically correspond to the top-level ports of the entire design and are connected to the standard cells inside the chip through wiring. Therefore, this placement method helps reduce wire delays during the routing stage (such as ports `A` and `B` in the figure below). Otherwise, if functionally similar ports are placed on opposite sides or even diagonally of the chip, one end will inevitably require long wiring to reach the target standard cells.

```
         |    |    |                         |    |    |
    +----+----+----+----+               +----+----+----+----+
    |                   |               |                   |
A---+--+                +---        A---+--+                +---
    |  o                |               |  o                |
B---+--+                +---         ---+  +                +---
    |                   |               |  |                |
 ---+                   +---         ---+  +----------------+---B
    |                   |               |                   |
    +----+----+----+----+               +----+----+----+----+
         |    |    |                         |    |    |
```

<!-- * 根据工艺手册中对供电引脚密度的要求, 摆放相应的核心电源单元和I/O电源单元.
  例如, 某工艺可能会要求每隔两个数据I/O单元就要放置一个电源单元. -->
* Place corresponding core power supply units and I/O power supply units in accordance with the requirements for power pin density specified in the process manual. For example, a certain process may require that a power supply unit be placed every two data I/O units.

<!-- ```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
|                                         |
|p                                       I|
|                                         |
|P                                       P|
|                                         |          I 数据I/O单元
|I                                       p|          p 核心电源单元
|                                         |          P I/O电源单元
|I                                       I|
|                                         |
|I                                       I|
|                                         |
|p                                       p|
|                                         |
|P                                       P|
|                                         |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
``` -->
```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
|                                         |
|p                                       I|
|                                         |
|P                                       P|
|                                         |          I Data I/O Cell
|I                                       p|          p Core Power Cell
|                                         |          P I/O Power Cell
|I                                       I|
|                                         |
|I                                       I|
|                                         |
|p                                       p|
|                                         |
|P                                       P|
|                                         |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
```

<!-- #### 摆放宏单元

还有一项工作是摆放宏单元.
宏单元占用的面积比一般的标准单元大得多.
例如, 一个`64x64`的SRAM, 仅考虑存储单元, 就需要$64\times64\times6 = 24576$根晶体管,
而一个二输入与非门的标准单元只需要4根晶体管.
因此, 宏单元需要提前摆放, 否则在摆放标准单元后, 将很难空出连续的大面积来摆放宏单元. -->
#### Placing Macro Cells

Another task is to place macro cells.
Macro cells occupy a much larger area than ordinary standard cells. For example, a `64x64` SRAM, considering only the memory cells, requires $64\times64\times6 = 24576$ transistors, while a standard cell of a two-input NAND gate only needs 4 transistors.
Therefore, macro cells need to be placed in advance; otherwise, after placing standard cells, it will be difficult to free up a continuous large area for placing macro cells.

<!-- ```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
|                                         |
|p                                       I|
|    +-------+                            |
|P   | MMMMM |                           P|
|    | MMMMM |                            |          I 数据I/O单元
|I   | MMMMM |                           p|          p 核心电源单元
|    +-------+                            |          P I/O电源单元
|I                                       I|<-- clk   M 宏单元
|                            +-------+    |
|I                           | MMMMM |   I|
|                            +-------+    |
|p                                       p|
|                                         |
|P                                       P|
|                                         |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
``` -->
```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
|                                         |
|p                                       I|
|    +-------+                            |
|P   | MMMMM |                           P|
|    | MMMMM |                            |          I Data I/O Cell
|I   | MMMMM |                           p|          p Core Power Cell
|    +-------+                            |          P I/O Power Cell
|I                                       I|<-- clk   M Macro Cell
|                            +-------+    |
|I                           | MMMMM |   I|
|                            +-------+    |
|p                                       p|
|                                         |
|P                                       P|
|                                         |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
```

<!-- 和I/O单元的摆放类似, 宏单元的摆放也需要参考它们的功能,
来将功能相近的宏单元摆放在物理上相邻的位置,
从而避免在布线阶段产生较长的走线, 从而影响芯片的频率. -->
Similar to the placement of I/O cells, the placement of macro cells also needs to refer to their functions. Macro cells with similar functions should be placed in physically adjacent positions. This avoids long wiring during the routing stage, which would otherwise affect the chip's frequency.

<!-- ### 电源规划(Powerplan)

电源规划的目标是在芯片层面规划电源走线的分布, 从而保证芯片供电的可靠性.
电源规划的工作主要包括:
1. 规划I/O单元的电源环(Power Ring).
   从物理分布上来看, I/O单元的电源环围绕芯片四周的I/O单元,
   并与I/O单元的电源端口相连, 由I/O单元中的I/O电源单元进行供电.
   上文提到, 为了驱动芯片外部的电路, I/O单元需要很强的驱动能力,
   因此I/O单元的供电与一般标准单元的供电也不同, 需要单独规划和设计.
1. 规划芯片内部电源环.
   物理分布上和I/O单元的电源环类似, 但位于I/O单元的内侧并围绕芯片四周,
   形成电源网络的主干, 由I/O单元中的核心电源单元供电,
   向芯片内部的标准单元提供均匀的供电输入.
1. 规划芯片内部的电源条线(power stripe).
   从物理分布上来看, 电源条线以纵横交错的方式分布在芯片内部,
   用于将电源均匀地输送到芯片内部的各种宏单元和标准单元.
   在布局阶段, 这些电源条线将会连接标准单元中门电路的源极和漏极.

考虑到简洁性, 下图只展示了一条电源条线作为示意,
实际上应规划纵横交错的多条电源条线. -->
### Powerplan

The goal of powerplan is to plan the distribution of power supply wiring at the chip level to ensure the reliability of the chip's power supply. The work of powerplan mainly includes:
1. Planning the power ring for I/O cells. From a physical distribution perspective, the power ring of I/O cells surrounds the I/O cells around the chip and is connected to the power ports of the I/O cells, with power supplied by the I/O power units within the I/O cells. As mentioned earlier, I/O cells require strong driving capability to drive circuits external to the chip, so the power supply for I/O cells is different from that for general standard cells and requires separate planning and design.
1. Planning the internal power ring of the chip. In terms of physical distribution, it is similar to the power ring of I/O cells but is located inside the I/O cells and surrounds the chip, forming the main trunk of the power network. It is powered by the core power units in the I/O cells and provides a uniform power input to the standard cells inside the chip.
1. Planning the internal power stripes of the chip. Physically, power stripes are distributed in a crisscross pattern inside the chip, used to uniformly deliver power to various macro cells and standard cells within the chip. During the placement stage, these power stripes will be connected to the source and drain of the gate circuits in the standard cells.

For the sake of simplicity, the following figure only shows one power stripe as an illustration; in reality, multiple crisscrossing power stripes should be planned.
<!-- ```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
| ####################################### |
|p#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#I|
| #% +-------+                         %# |
|P#% | MMMMM |                         %#P|
| #% | MMMMM |                         %# |          I 数据I/O单元
|I#% | MMMMM |                         %#p|          p 核心电源单元
| #% +-------+                         %# |          P I/O电源单元
|I#%                                   %#I|<-- clk   M 宏单元
| #%                         +-------+ %# |          # I/O电源环
|I#%                         | MMMMM | %#I|          % 核心电源环
| #%                         +-------+ %# |          = 电源条线
|p#%===================================%#p|
| #%                                   %# |
|P#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#P|
| ####################################### |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
``` -->
```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
| ####################################### |
|p#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#I|
| #% +-------+                         %# |
|P#% | MMMMM |                         %#P|
| #% | MMMMM |                         %# |          I Data I/O Cell
|I#% | MMMMM |                         %#p|          p Core Power Cell
| #% +-------+                         %# |          P I/O Power Cell
|I#%                                   %#I|<-- clk   M Macro Cell
| #%                         +-------+ %# |          # I/O Power Ring
|I#%                         | MMMMM | %#I|          % Core Power Ring
| #%                         +-------+ %# |          = Power Stripe
|p#%===================================%#p|
| #%                                   %# |
|P#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#P|
| ####################################### |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
```

<!-- 将来芯片工作时, 电源通过供电引脚输入芯片, 通过电源环传播到芯片的四周,
并通过电源条线传播到芯片各区域的标准单元,
对晶体管的源极和漏极施加相应电压, 从而使其按照晶体管的电气特性进行工作.

一些复杂的芯片还需要支持电源管理相关的功能, 如多电压域, 电源门控等.
这些功能也需要在此阶段开展相关的规划工作. -->
In the future, when the chip is operating, power will be input into the chip through the power supply pins, propagated to the surrounding areas of the chip via the power rings, and then transmitted to the standard cells in various regions of the chip through the power stripes. Corresponding voltages will be applied to the source and drain of the transistors, enabling them to operate in accordance with their electrical characteristics.

Some complex chips also need to support power management-related functions, such as multi-voltage domains and power gating. Planning work related to these functions also needs to be carried out at this stage.

<!-- ### 布局(Placement)

布局的目标是将标准单元摆放在芯片中, 确定每个标准单元在芯片中的物理位置.
但标准单元的摆放并非任意均可, 需要遵循一定的规则:
1. 标准单元之间不能互相重叠.
   虽然芯片是一个三维物体, 但根据芯片的工艺结构,
   标准单元是通过底层的晶体管和低层金属层的连接实现的,
   不同标准单元的晶体管应该占用这些层次的不同位置.
   也即, 所有标准单元的$z$轴坐标分量都是相同的.
   因此从$xOy$平面的投影(即芯片的俯视图)来看, 标准单元之间不能相互重叠.
1. 标准单元的摆放需要满足一定的对齐条件.
   上文提到了标准单元的SITE和轨道数等属性,
   它们本质上都是用于约束标准单元在布局时的位置.
   按SITE对齐可以让电源规划阶段所设置的电源条线轻松地接入到标准单元中(如下图所示),
   而轨道数的概念可以让后续的布线阶段较轻松地满足金属层走线的最小间距要求(即`PITCH`属性).
   如果不对标准单元的摆放满足对齐要求,
   EDA工具将需要花费很大的代价来生成一个满足工艺要求的设计方案. -->
### Placement

The goal of placement is to position standard cells within the chip and determine the physical location of each standard cell. However, the placement of standard cells is not arbitrary and must follow certain rules:
1. Standard cells must not overlap with each other. Although a chip is a three-dimensional object, according to its process structure, standard cells are implemented through transistors in the lower layers and connections in the lower metal layers. Transistors of different standard cells should occupy different positions in these layers. That is, all standard cells have the same $z$-axis coordinate component. Therefore, from the projection on the $xOy$ plane (i.e., the top view of the chip), standard cells must not overlap.
1. The placement of standard cells must meet certain alignment conditions. As mentioned earlier, attributes such as the SITE and track count of standard cells are essentially used to constrain the positions of standard cells during placement. Aligning by SITE allows the power stripes set in the power planning stage to be easily connected to the standard cells (as shown in the figure below), while the concept of track count enables the subsequent routing stage to more easily meet the minimum spacing requirements for metal layer routing (i.e., the `PITCH` attribute). If the placement of standard cells does not meet the alignment requirements, EDA tools will need to spend significant effort to generate a design that meets process requirements.

```
        --- +------+  +------------+----------+    +---+
         ^  |======|==|============|==========|====|===| <- VSS power stripe
         |  |      |  |            |          |    |   |
height --+  |      |  |            |          |    |   |
         |  |      |  |            |          |    |   |
         v  |======|==|============|==========|====|===| <- VDD power stripe
        --- +------+  +------------+----------+    +---+
               OR2        AOI221       AND4        NAND2
```

<!-- ```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
| ####################################### |
|p#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#I|
| #% +-------+  @@  @@  @           @ @%# |
|P#% | MMMMM |   @      @@@      @@  @@%#P|
| #% | MMMMM |  @    @                @%# |          I 数据I/O单元
|I#% | MMMMM |                @        %#p|          p 核心电源单元
| #% +-------+   @   @@           @    %# |          P I/O电源单元
|I#%                                   %#I|<-- clk   M 宏单元
| #% @   @   @   @@  @       +-------+ %# |          # I/O电源环
|I#% @    @  @   @   @   @   | MMMMM | %#I|          % 核心电源环
| #% @   @   @   @   @    @  +-------+@%# |          = 电源条线
|p#%===================================%#p|          @ 标准单元
| #% @   @       @   @    @     @     @%# |
|P#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#P|
| ####################################### |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
``` -->
```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
| ####################################### |
|p#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#I|
| #% +-------+  @@  @@  @           @ @%# |
|P#% | MMMMM |   @      @@@      @@  @@%#P|
| #% | MMMMM |  @    @                @%# |          I Data I/O Cell
|I#% | MMMMM |                @        %#p|          p Core Power Cell
| #% +-------+   @   @@           @    %# |          P I/O Power Cell
|I#%                                   %#I|<-- clk   M Macro Cell
| #% @   @   @   @@  @       +-------+ %# |          # I/O Power Ring
|I#% @    @  @   @   @   @   | MMMMM | %#I|          % Core Power Ring
| #% @   @   @   @   @    @  +-------+@%# |          = Power Stripe
|p#%===================================%#p|          @ Standard Cell
| #% @   @       @   @    @     @     @%# |
|P#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#P|
| ####################################### |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
```

<!-- 除了让标准单元的布局满足工艺制造要求之外,
EDA工具还会考虑如何提升电路的质量.
一些措施包括但不限于:
* 将逻辑上相近的标准单元靠近摆放. 和上文提到的数据I/O单元的摆放类似,
  如果逻辑上相近的两个标准单元距离很远, 在布线阶段将会引入较高的线延迟, 从而降低芯片的频率.
* 对标准单元进行镜像对称.
  上文提到, LEF文件中的`SYMMETRY`属性表示标准单元可以沿$x$轴或沿$y$轴对称放置,
  从而优化布局的效果(如到某端口的线延迟等).
  例如, 某标准单元`A`左侧的端口`p`需要与位于`A`右侧的另一个标准单元`B`相连,
  此时可以将`A`沿$y$轴进行镜像对称, 使得端口`p`位于`A`的右侧,
  从而让`p`与`B`的距离更近, 降低线延迟.
* 拥塞缓解.
  标准单元过分集中在某区域, 可能会使得后续的布线工作变得困难,
  不仅会造成走线迂回而引入较高的线延迟, 甚至有可能会因为过分拥塞而造成布线失败.
  为了缓解拥塞, EDA工具可能会将过分集中的标准单元进行分散处理,
  从而给布线阶段预留更多的空间. -->
In addition to ensuring that the placement of standard cells meets the requirements of process manufacturing, EDA tools also consider ways to improve the quality of the circuit. Some of the measures include, but are not limited to:
* Placing logically similar standard cells close to each other. Similar to the placement of data I/O cells mentioned above, if two logically similar standard cells are far apart, higher line delays will be introduced during the routing stage, thereby reducing the chip's frequency.
* Applying mirror symmetry to standard cells. As mentioned earlier, the `SYMMETRY` attribute in the LEF file indicates that a standard cell can be placed symmetrically along the $x$-axis or $y$-axis to optimize the placement effect (such as the line delay to a certain port). For example, if the port `p` on the left side of a standard cell `A` needs to be connected to another standard cell `B` located on the right side of `A`, `A` can be mirrored along the $y$-axis so that port `p` is on the right side of `A`, which shortens the distance between `p` and `B` and reduces line delay.
* Congestion mitigation. Excessive concentration of standard cells in a certain area may make subsequent routing work difficult. It will not only cause routing detours, introducing high line delays, but may even lead to routing failure due to excessive congestion. To alleviate congestion, EDA tools may disperse the overly concentrated standard cells, thereby reserving more space for the routing stage.

<!-- > #### todo::填充单元的尺寸
> 标准单元库通常提供不同尺寸的填充单元,
> 用于填充芯片中没有摆放标准单元的空白位置.
> 以nangate45为例, 尝试在相关文件中找到最小填充单元的尺寸,
> 这个尺寸和标准单元的`SITE`属性有什么关联? 为什么? -->
> #### todo::Size of Filler Cells
> The standard cell library usually provides filler cells of different sizes, which are used to fill the blank positions in the chip where no standard cells are placed. Taking nangate45 as an example, try to find the size of the minimum size filler cell in the relevant files. What is the relationship between this size and the `SITE` property of the standard cell? Why?

<!-- ### 时钟树综合(CTS, Clock Tree Synthesis)

时钟树综合的目标是构建时钟网络, 将时钟信号输送到所有时序单元的时钟端.
这个时钟网络通常只有一个或少数几个源头(时钟引脚或锁相环的输出),
我们可以将这些源头看作根节点, 时序单元看作叶子节点,
这个时钟网络就像是从根节点向叶子节点生长的一棵或几颗树, 因此称为"时钟树".

在RTL设计阶段, 我们会认为时钟信号是理想的.
但实际上并非如此, 在物理设计阶段, 我们需要考虑实际时钟信号需要处理的问题.
上文介绍"时钟专用单元"时已经简单讨论了时钟信号的特殊性质,
因此, 构建的时钟树也应满足这些性质, 具体包括: -->
### Clock Tree Synthesis (CTS)

The goal of Clock Tree Synthesis is to construct a clock network that delivers clock signals to the clock pins of all sequential cells. This clock network typically has only one or a few sources (clock pins or outputs of phase-locked loops). We can regard these sources as root nodes and the sequential cells as leaf nodes. Thus, this clock network is like one or several trees growing from the root nodes to the leaf nodes, hence the name "clock tree".

In the RTL design stage, we consider clock signals to be ideal. However, this is not the case in reality. In the physical design stage, we need to take into account the actual issues that clock signals have to deal with. The special properties of clock signals were briefly discussed when introducing "clock-dedicated cells" earlier. Therefore, the constructed clock tree should also satisfy these properties, which specifically include:
<!-- * 低延迟(low latency).
  给时钟信号的传播引入延迟的因素有很多,
  有一些是EDA工具可以优化的, 如时钟信号的走线,
  EDA工具应尽可能减少时钟源到触发器时钟端口的距离;
  另一些是EDA工具无法优化的, 如时钟源本身的延迟,
  EDA工具应在建模时钟信号延迟时考虑这些因素.
* 低偏斜(low skew).
  在RTL设计时, 我们会认为理想时钟的信号同时到达所有的触发器.
  但实际上, 不同的触发器在布局阶段被放置在不同的位置,
  同一个时钟信号到达不同触发器的所需时间并不完全相同, 这就产生了时钟偏斜的概念.
  为了尽可能降低时钟偏斜, EDA工具需要仔细规划时钟信号的走线,
  使得时钟源到各触发器的线延迟尽可能均匀.
* 低抖动(low jitter).
  抖动是电信号在物理世界中天然存在的特性,
  和具体的工艺参数有关, 无法通过EDA工具优化或消除.
  因此EDA工具应在建模时钟信号延迟时考虑抖动的影响,
  否则EDA工具对时钟信号延迟的估计可能会过于乐观, 将来芯片在真实场景下工作时,
  真实的抖动可能会使得电路违反过于乐观的时序条件, 最终令芯片无法正确工作.
* 高驱动能力(high drive).
  为了实现时钟信号的高驱动能力, 一般会在时钟树中插入专用的时钟缓冲器. -->
* Low latency.
There are many factors that introduce delays into the propagation of clock signals.
Some can be optimized by EDA tools, such as the routing of clock signals.
EDA tools should minimize the distance from the clock source to the clock ports of flip-flops.
Others cannot be optimized by EDA tools, such as the delay of the clock source itself.
EDA tools should consider these factors when modeling clock signal delays.
* Low skew.
During RTL design, we assume that ideal clock signals reach all flip-flops simultaneously.
In reality, however, different flip-flops are placed in different positions during the placement stage,
and the time required for the same clock signal to reach different flip-flops is not exactly the same, which gives rise to the concept of clock skew.
To minimize clock skew as much as possible, EDA tools need to carefully plan the routing of clock signals,
ensuring that the wire delays from the clock source to each flip-flop are as uniform as possible.
* Low jitter.
Jitter is an inherent characteristic of electrical signals in the physical world,
related to specific process parameters, and cannot be optimized or eliminated by EDA tools.
Therefore, EDA tools should consider the impact of jitter when modeling clock signal delays.
Otherwise, the EDA tool's estimation of clock signal delays may be overly optimistic, and when the chip operates in real scenarios in the future,
the actual jitter may cause the circuit to violate the overly optimistic timing conditions, ultimately making the chip unable to work correctly.
* High drive capability.
To achieve high drive capability of clock signals, dedicated clock buffers are generally inserted into the clock tree.
However, there are certain mutual constraints among these properties. For example, some routing topologies have the property of low skew but come with high line delays; inserting clock buffers can enhance the driving capability of clock signals, but it will also change the delay on the corresponding paths, which may lead to severe skew. Therefore, EDA tools need to comprehensively consider the impact of these technologies on the clock tree and construct a clock tree that meets the requirements as a whole.

For the sake of simplicity, the following figure only shows a part of the clock tree as an illustration; in reality, the clock tree should be connected to all sequential cells.
<!-- 不过, 这些性质之间还存在一定的相互制约关系.
例如, 一些走线拓扑具有低偏斜的性质, 但其线延迟较高;
插入时钟缓冲器可以提高时钟信号的驱动能力,
但也会改变相应路径上的延迟, 从而可能让偏斜变得严重.
因此, EDA工具需要综合考虑这些技术对时钟树的影响,
从整体上构建出满足需求的时钟树.

考虑到简洁性, 下图只展示了时钟树的一部分作为示意,
实际上时钟树应连接到所有时序单元. -->
<!-- ```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
| ####################################### |
|p#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#I|
| #% +-------+  @@o @@  @           @ @%# |
|P#% | MMMMM |   @o     @@@      @@ o@@%#P|
| #% | MMMMM |  @ o  @    o         o @%# |          I 数据I/O单元
|I#% | MMMMM |    o       o   @     o  %#p|          p 核心电源单元
| #% +-------+   @o  @@   o       @ o  %# |          P I/O电源单元
|I#% oooooooooooooooooooooooooooooooooo%#I|<-- clk   M 宏单元
| #% @   @   @   @@o @    o  +-------+ %# |          # I/O电源环
|I#% @    @  @   @ o @   @o  | MMMMM | %#I|          % 核心电源环
| #% @   @   @   @ o @    @  +-------+@%# |          = 电源条线
|p#%===================================%#p|          @ 标准单元
| #% @   @       @ o @    @     @   oo@%# |          o 时钟树
|P#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#P|
| ####################################### |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
``` -->
```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
| ####################################### |
|p#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#I|
| #% +-------+  @@o @@  @           @ @%# |
|P#% | MMMMM |   @o     @@@      @@ o@@%#P|
| #% | MMMMM |  @ o  @    o         o @%# |          I Data I/O Cell
|I#% | MMMMM |    o       o   @     o  %#p|          p Core Power Cell
| #% +-------+   @o  @@   o       @ o  %# |          P I/O Power Cell
|I#% oooooooooooooooooooooooooooooooooo%#I|<-- clk   M Macro Cell
| #% @   @   @   @@o @    o  +-------+ %# |          # I/O Power Ring
|I#% @    @  @   @ o @   @o  | MMMMM | %#I|          % Core Power Ring
| #% @   @   @   @ o @    @  +-------+@%# |          = Power Stripe
|p#%===================================%#p|          @ Standard Cell
| #% @   @       @ o @    @     @   oo@%# |          o Clock Tree
|P#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#P|
| ####################################### |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
```

<!-- ### 布线(Routing)

布线的目标是根据网表的拓扑关系, 将布局阶段的标准单元通过走线连接起来.
作为大规模和超大规模集成电路, 标准单元的数量非常多,
标准单元之间的走线也很多, 只要有一条走线无法连通, 布线就会失败.
为了提升布线成功的概率, 一般将布线任务分成两个阶段进行:
全局布线(Global Routing)和详细布线(Detailed Routing).

以城市的道路规划为例, 全局布线就好比规划城市的主干道,
一方面要保证城市中不同地点之间的连通性,
另一方面不能让主干道过分迂回, 尽量以较短的距离实现连通,
最后还需要避免某些区域过分拥堵.
而详细布线就相当于在主干道上进一步划分真正的车道,
让车辆可以在车道上行驶, 从而到达由主干道连通的地点.

回到布线的场景, 全局布线的目标是规划粗粒度的走线方案,
并为这些粗粒度的走线方案分配布线资源,
包括轨道数量, 走线方向, 以及金属层之间的通孔等.
具体地, 布线工具在全局布线阶段会将多个轨道看成一个网格,
然后尝试以网格为粗粒度单元, 把标准单元连接起来,
得到一些"网格路径"(类似道路规划中的主干道).
在全局布线的过程中, 布线工具会在保证连通性的同时,
寻找一套距离较短, 同时避免过分拥塞的"网格路径连通方案".
详细布线的目标是在全局布线的基础上, 在"网格路径"内部确定走线轨道,
通过这些走线轨道将标准单元真正地连接起来. -->
### Routing

The goal of routing is to connect the standard cells placed during the placement stage through wires according to the topological relationship of the netlist. As large-scale and very-large-scale integrated circuits contain a huge number of standard cells, there are also numerous wires between them. Routing will fail if even one wire cannot be connected. To increase the probability of successful routing, the routing task is generally divided into two stages: Global Routing and Detailed Routing.

Using urban road planning as an analogy, global routing is similar to planning a city's main roads. On one hand, it must ensure connectivity between different locations in the city; on the other hand, it should prevent main roads from being excessively circuitous and achieve connectivity with the shortest possible distance. Finally, it also needs to avoid excessive congestion in certain areas. Detailed routing, by contrast, is equivalent to further dividing actual lanes on the main roads, allowing vehicles to travel on these lanes to reach destinations connected by the main roads.

Returning to the context of routing, the goal of global routing is to plan coarse-grained wiring schemes and allocate wiring resources for these schemes, including the number of tracks, wiring directions, and vias between metal layers. Specifically, during the global routing stage, routing tools treat multiple tracks as a grid and then attempt to connect standard cells using the grid as a coarse-grained unit, resulting in "grid paths" (similar to main roads in road planning). In the process of global routing, while ensuring connectivity, routing tools seek a "grid path connectivity scheme" that is relatively short in distance and avoids excessive congestion. The goal of detailed routing is, based on the global routing, to determine specific wiring tracks within the "grid paths" and use these tracks to physically connect the standard cells.

<!-- ```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
| ####################################### |
|p#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#I|
| #% +-------+..@@o @@..@...   .....@.@%# |
|P#% | MMMMM |  .@o.....@@@..... @@ o@@%#P|
| #% | MMMMM |..@ o  @    o   .   . o @%# |          I 数据I/O单元
|I#% | MMMMM |  . o       o   @   . o .%#p|          p 核心电源单元
| #% +-------+  .@o  @@...o   ....@ o .%# |          P I/O电源单元
|I#% oooooooooooooooooooooooooooooooooo%#I|<-- clk   M 宏单元
| #% @ ..@...@ ..@@o @... o  +-------+.%# |          # I/O电源环
|I#% @....@ .@.. @ o @. .@o .| MMMMM |.%#I|          % 核心电源环
| #% @...@...@  .@ o @  ..@..+-------+@%# |          = 电源条线
|p#%===================================%#p|          @ 标准单元
| #% @...@      .@ o @... @.....@.. oo@%# |          o 时钟树
|P#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#P|          . 走线
| ####################################### |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
``` -->
```
+-----------------------------------------+
|  I  I  P  p  I  I  P  p  I  I  P  p  I  |
| ####################################### |
|p#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#I|
| #% +-------+..@@o @@..@...   .....@.@%# |
|P#% | MMMMM |  .@o.....@@@..... @@ o@@%#P|
| #% | MMMMM |..@ o  @    o   .   . o @%# |          I Data I/O Cell
|I#% | MMMMM |  . o       o   @   . o .%#p|          p Core Power Cell
| #% +-------+  .@o  @@...o   ....@ o .%# |          P I/O Power Cell
|I#% oooooooooooooooooooooooooooooooooo%#I|<-- clk   M Macro Cell
| #% @ ..@...@ ..@@o @... o  +-------+.%# |          # I/O Power Ring
|I#% @....@ .@.. @ o @. .@o .| MMMMM |.%#I|          % Core Power Ring
| #% @...@...@  .@ o @  ..@..+-------+@%# |          = Power Stripe
|p#%===================================%#p|          @ Standard Cell
| #% @...@      .@ o @... @.....@.. oo@%# |          o Clock Tree
|P#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#P|          . Wiring
| ####################################### |
|  I  p  P  I  I  p  P  I  I  p  P  I  I  |
+-----------------------------------------+
```

<!-- 至此, 物理设计的工作已全部完成, 芯片中每一层的内容都已确定,
可以通过GDS版图文件来描述芯片中所有标准单元和物理走线在每一层中的具体布局. -->
Up to this point, the work of physical design has been fully completed, and the content of each layer in the chip has been determined. The specific layout of all standard cells and physical wirings in each layer of the chip can be described through the GDS layout file.

<!-- ### 签核分析(Sign-off)

签核分析的目标是保证物理设计过程得到的版图是可生产的.
一方面, 需要保证版图满足前端设计的指标, 包括PPA等;
另一方面, 还需要保证版图满足晶圆厂的生产制造要求.
严格来说, 签核分析并不属于物理设计的范畴,
但为了保证版图是可流片的, 签核分析是不可或缺的,
否则生产得到的芯片将可能无法工作. -->
### Sign-off Analysis

The goal of sign-off analysis is to ensure that the layout obtained through the physical design process is manufacturable. On one hand, it is necessary to ensure that the layout meets the indicators of the front-end design, including PPA and others; on the other hand, it is also required to ensure that the layout complies with the manufacturing requirements of the wafer fab. Strictly speaking, sign-off analysis does not fall within the scope of physical design, but it is indispensable to guarantee that the layout is tape-out ready. Otherwise, the chips produced may fail to function properly.
<!-- 签核分析的具体工作包括但不限于:
* 静态时序分析.
  物理设计工作完成后, 所有标准单元的在三维空间中的位置都已确定,
  所有走线的方向, 长度和拐角等细节都已明了,
  因此可以准确建模出电路中每一条路径的逻辑延迟和线延迟,
  包括时钟信号的传播延迟, 抖动和偏斜,
  综合这些因素, 得到更准确的时序评估结果,
  从而确定是否满足用户指定的频率指标.
* 功耗分析.
  和静态时序分析类似, 物理设计工作完成后,
  可以得到更准确的功耗评估结果, 从而确定是否满足用户指定的功耗指标.
* 信号完整性分析.
  分析相邻走线之间的串扰(crosstalk)现象,
  确保信号在噪声环境和串扰条件下仍然能正确传输, 不失真.
* 物理验证(Physical Verification, 简称PV).
  对芯片进行物理结构上的检查, 若发现违例,
  则需要修改布局布线的结果, 重新进行检查.
  物理验证的检查工作具体包括: -->
The specific tasks of sign-off analysis include but are not limited to:
* Static Timing Analysis (STA).
After the completion of physical design, the positions of all standard cells in three-dimensional space are determined, and details such as the direction, length, and corners of all wirings are clear. Therefore, it is possible to accurately model the logic delays and wire delays of each path in the circuit, including the propagation delay, jitter, and skew of clock signals. By integrating these factors, more accurate timing evaluation results can be obtained to determine whether the user-specified frequency indicators are met.
* Power Analysis.
Similar to static timing analysis, after the physical design is completed, more accurate power consumption evaluation results can be obtained to determine whether the user-specified power consumption indicators are satisfied.
* Signal Integrity Analysis.
This involves analyzing the crosstalk phenomenon between adjacent wirings to ensure that signals can still be transmitted correctly without distortion in noisy environments and under crosstalk conditions.
* Physical Verification (PV for short).
It conducts checks on the physical structure of the chip. If any violations are found, it is necessary to modify the placement and routing results and recheck. The specific inspection tasks of physical verification include:
  * Design Rule Check (DRC).
Ensure that the GDS layout complies with the foundry's design rules, such as minimum line width requirements and minimum spacing requirements. These rules are documented in text files with the `.lydrc` extension, provided as part of the PDK:
  ```bash
  vim yosys-sta/pdk/nangate45/drc/FreePDK45.lydrc
  ```
  As can be seen, it contains check rules for the poly-silicon layer and various metal layers. EDA tools can read these rules from the file and check them one by one. Some examples of the rules are as follows:
  ```
  # The minimum width of the metal1 layer is 65nm
  metal1.width(65.nm, euclidian).output("METAL1.1", "METAL1.1 : Minimum width of metal1 : 65nm")

  # The minimum spacing of the via6 layer is 160nm
  via6.space(160.nm, euclidian).output("VIA6.2", "VIA6.2 : Minimum spacing of via6 : 160nm")
  ```
  * Electrical Rule Check (ERC).
Check for electrical issues in the circuit, such as dangling wires and short circuits.
  * Layout Versus Schematic (LVS).
Verify the consistency between the GDS layout (physical circuit) and the netlist (logical circuit).
  <!-- * 设计规则检查(Design Rule Check, DRC).
    保证GDS版图满足晶圆厂的设计规则, 如最小线宽要求, 最小间距要求等.
    这些规则以文本形式记录到文件中, 文件以`.lydrc`为后缀, 作为PDK的一部分提供:
    ```bash
    vim yosys-sta/pdk/nangate45/drc/FreePDK45.lydrc
    ```
    可以看到, 其中包含了多晶硅层和各种金属层的检查规则.
    EDA工具可以从文件中读取这些规则并逐条检查. 一些规则如下:
    ```
    # metal1层的最小线宽是65nm
    metal1.width(65.nm, euclidian).output("METAL1.1", "METAL1.1 : Minimum width of metal1 : 65nm")

    # via6层的最小间距是160nm
    via6.space(160.nm, euclidian).output("VIA6.2", "VIA6.2 : Minimum spacing of via6 : 160nm")
    ```
  * 电学规则检查(Electrical Rule Check, ERC).
    检查电路中是否存在走线悬空, 短路等电气问题.
  * 版图和原理图比较(Layout Versus Schematic, LVS).
    确认GDS版图(物理电路)与网表(逻辑电路)的一致性. -->

<!-- > #### comment::从可流片的版图到可运行的芯片
> 从可流片的版图到可运行的芯片还需要经过以下步骤:
> 1. 后端设计团队将芯片的GDS版图提交给晶圆厂后, 晶圆厂将会按照版图制作出掩膜(mask),
> 1. 晶圆厂用掩膜批量生产出晶圆(wafer).
>    一个晶圆上有多个裸片(die), 晶圆厂对晶圆进行切割, 得到一批裸片.
> 1. 晶圆厂将然后交给封装厂, 由封装厂按照计划的封装方案对裸片进行封装, 得到芯片成品.
> 1. 封装厂将芯片成品交给开发板团队, 由开发板团队设计开发板, 并将芯片成品焊接到开发板上.
> 1. 将开发板交给用户, 用户在芯片上部署软件并运行. -->
> #### comment::From Tape-out Ready Layout to Operational Chip
> The journey from a tape-out ready layout to an operational chip involves the following steps:
> 1. After the backend design team submits the chip's GDS layout to the wafer fab, the wafer fab will fabricate masks according to the layout.
> 1. The wafer fab uses the masks to mass-produce wafers. A single wafer contains multiple dies. The wafer fab then cuts the wafer to obtain a batch of individual dies.
> 1. The wafer fab then sends these dies to the packaging house, which packages the dies according to the planned packaging scheme to produce finished chips.
> 1. The packaging house delivers the finished chips to the development board team, who designs the development board and solders the finished chips onto it.
> 1. The development board is then provided to the user, who deploys software on the chip and operates it.

<!-- ## 若干代码风格和规范 -->
## Several Coding Styles and Standards


<!-- 在往期的"一生一芯"计划中, 我们发现部分不规范的代码风格会给后期的SoC集成带来额外的问题.
为了避免将来影响SoC集成的进度, 我们建议大家遵守以下若干代码规范. -->
In previous phases of OSOC, we found that certain non-standard coding styles can introduce additional problems during the SoC integration phase. 
To avoid impacting the progress of future SoC integrations, we recommend that everyone adhere to the following coding standards.


<!-- > #### caution::1. 如果你还没有深入理解Verilog的事件模型, 不要使用行为建模 -->
> #### caution:: 1. If you have not deeply understood the event model of Verilog, do not use behavioral modeling.


<!-- 事实上, 南京大学数字电路实验讲义中也提到"行为建模不利于初学者建立电路思维",
我们在这里引用相关的描述: -->
In fact, **the Digital Circuit Lab notes from Nanjing University** also mention that “behavioral modeling is detrimental to beginners in establishing circuit thinking.” 
We quote the relevant description here:


<!-- > #### caution::强烈建议初学者不要使用行为建模方式设计电路
> Verilog一开始并不是为了设计可综合电路而提出的, 它的本质是一门基于事件队列模型的电路建模语言.
> 因此, 行为建模很容易会让初学者偏离描述电路的初衷:
> 开发者需要看着电路图, 心里想象电路的行为, 然后转化成事件队列模型的思考方式,
> 最后再用行为建模方式来描述电路的行为, 综合器再来根据这样的描述推导出相应的电路.
> 从这个过程来看, 这不仅是没有必要的, 而且还很容易引入错误:
> * 如果开发者心里本身就已经有电路图, 直接描述它是最方便的
> * 如果开发者心里本身就已经有电路图, 而开发者对行为建模方式的理解所有偏差,
>   可能会采用了错误的描述方式, 从而设计出非预期的电路
> * 如果开发者心里没有电路图, 而是期望通过行为建模方式让综合器生成某种行为的电路,
>   这就已经偏离“描述电路”的本质了.
>   大部分同学非常容易犯这样的错误, 把行为建模当作过程式的C语言来写,
>   尝试把任意复杂的行为描述映射到电路, 最终综合器只会生成出延迟大, 面积大, 功耗高的低质量电路,
>   甚至因为代码包含数据竞争而被综合器综合成行为不符合预期的电路
>
> 所以, 直到大家掌握"描述电路"的思维而不被行为建模误导之前
> 我们强烈建议初学者远离行为建模方式, 仅通过数据流建模和结构化建模方式直接描述电路.
> 下面的问题可以帮助大家测试自己是否已经掌握Verilog的本质:
> * 在硬件描述语言中, "执行"的精确含义是什么?
> * 是谁在执行Verilog的语句? 是电路，综合器，还是其它的?
> * if的条件满足, 就不执行else后的语句, 这里的"不执行"又是什么意思? 和描述电路有什么联系?
> * 有"并发执行", 又有"顺序执行", 还有"任何一个变量发生变化就立即执行",
>   以及"在任何情况下都执行", 它们都是如何在设计出来的电路中体现的?
>
> 如果你无法对这些问题作出明确的回答, 我们强烈建议你不要使用行为建模方式.
> 如果你真的想弄懂它们, 你需要阅读[Verilog标准手册][verilog manual]. -->
> ### caution:: it is strongly recommended that beginners do NOT design circuits using behavioral modeling.
> Verilog was not originally intended for designing synthesizable circuits; its essence is a circuit modeling language based on an event queue model. 
> Therefore, behavioral modeling can easily lead beginners away from the original intent of circuit description: 
> Developers need to look at the circuit diagram, mentally visualize the circuit behavior, and then convert that into the event queue model, 
> ultimately using behavioral modeling to describe the circuit’s behavior, from which the synthesizer derives the corresponding circuit. 
> From this process, it is not only unnecessary but also very easy to introduce errors:
> * If the developer already has the circuit diagram in mind, describing it directly is the most convenient.
> * If the developer already has the circuit diagram in mind, but their understanding of behavioral modeling is flawed, 
> they may adopt an incorrect description method, resulting in an unexpected circuit design.
> * If the developer does not have the circuit diagram, but expects the synthesizer to generate a circuit of a certain behavior through behavioral modeling, 
> this has already deviated from the essence of “describing circuits.” 
> Many students easily make this mistake, treating behavioral modeling as procedural C code 
> and attempting to map any complex behavior to a circuit, 
> ultimately leading the synthesizer to generate low-quality circuits with high delay, area, and power consumption, 
> or even result in a circuit that behaves unexpectedly due to data races in the code.
>
> Therefore, until everyone masters the “description of circuits” thinking without being misled by behavioral modeling, 
> we strongly recommend that beginners stay away from behavioral modeling and directly describe circuits using data flow modeling and structured modeling. 
> The following questions can help test whether you have grasped the essence of Verilog:
> * In hardware description languages, what is the precise meaning of “execution”?
> *  Who executes Verilog statements? Is it the circuit, the synthesizer, or something else?
> *  If the condition of an if statement is met, the statements following else are not executed; 
> what does “not executed” mean here? What is its relation to describing circuits?
> * There are “concurrent executions”, “sequential executions”, and “executions triggered by any variable change”, 
> as well as “executions under any circumstances”; how are they reflected in the designed circuit?
>
> If you cannot answer these questions clearly, we strongly recommend that you refrain from using behavioral modeling. If you truly want to understand them, you need to read the [Verilog Standard Manual][verilog manual].



<!-- > #### caution:: 真正的描述电路 = 实例化 + 连线
> 忘记行为建模方式, 就可以很容易回归到描述电路的简单本质.
> 想象一下, 你手中有一张电路图纸, 如果你需要向其它人描述图纸上的内容, 你将会如何描述?
> 你一定会说出类似"有一个A元件/模块, 它的x引脚和另一个B元件/模块的y引脚相连"的描述,
> 因为这才是描述电路的最自然的方式.
> 用HDL设计电路, 就是在用HDL来描述电路图纸, 图纸上有什么, 就直接描述什么.
> 所以, 用HDL描述电路, 无非是做两件事情:
> * 实例化: 在电路板上放一个元件/模块, 可以是一个门电路, 或者是由门电路组成的模块
> * 连线: 用导线将元件/模块的引脚正确地连起来
>
> 大家可以体会一下, 数据流建模和结构化建模是如何体现这两件事的,
> 而行为建模又是如何把这两件简单的事情复杂化的. -->
> #### caution::  the true description of a circuit = instantiation + wiring.
> Forgetting behavioral modeling allows for a straightforward return to the simple essence of circuit description. 
> Imagine you have a circuit diagram; how would you describe its contents to others? 
> You would likely say something like, “There is an A component/module, and its x pin is connected to the y pin of another B component/module,” 
> as this is the most natural way to describe a circuit. 
> Designing circuits with HDL is about using HDL to describe the circuit diagram—what’s on the diagram is directly what you describe. 
> Thus, using HDL to describe a circuit essentially involves two tasks:
> * Instantiation: Placing a component/module on the circuit board, which can be a gate circuit or a module composed of gate circuits.
> * Wiring: Correctly connecting the pins of components/modules with wires.
>
> You can appreciate how data flow modeling and structured modeling embody these two tasks, while behavioral modeling complicates these straightforward tasks.


<!-- 所以, 我们不建议初学者在Verilog代码中编写任何always语句.
为了方便大家使用触发器和选择器, 我们提供了如下Verilog模板给大家进行调用: -->
Thus, we do not recommend beginners write any "always" statements in Verilog code. To facilitate the use of flip-flops and multiplexers, we provide the following Verilog templates for you to utilize:


<!-- ```verilog
// 触发器模板
module Reg #(WIDTH = 1, RESET_VAL = 0) (
  input clk,
  input rst,
  input [WIDTH-1:0] din,
  output reg [WIDTH-1:0] dout,
  input wen
);
  always @(posedge clk) begin
    if (rst) dout <= RESET_VAL;
    else if (wen) dout <= din;
  end
endmodule

// 使用触发器模板的示例
module example(
  input clk,
  input rst,
  input [3:0] in,
  output [3:0] out
);
  // 位宽为1比特, 复位值为1'b1, 写使能一直有效
  Reg #(1, 1'b1) i0 (clk, rst, in[0], out[0], 1'b1);
  // 位宽为3比特, 复位值为3'b0, 写使能为out[0]
  Reg #(3, 3'b0) i1 (clk, rst, in[3:1], out[3:1], out[0]);
endmodule
``` -->

```verilog
// Flip-Flop Template
module Reg #(WIDTH = 1, RESET_VAL = 0) (
  input clk,
  input rst,
  input [WIDTH-1:0] din,
  output reg [WIDTH-1:0] dout,
  input wen
);
  always @(posedge clk) begin
    if (rst) dout <= RESET_VAL;
    else if (wen) dout <= din;
  end
endmodule

// Example of using the Flip-Flop Template
module example(
  input clk,
  input rst,
  input [3:0] in,
  output [3:0] out
);
  // width of 1 bit, reset value of 1’b1, write enable always active
  Reg #(1, 1'b1) i0 (clk, rst, in[0], out[0], 1'b1);
  // width of 3 bits, reset value of 3’b0, write enable is out[0]
  Reg #(3, 3'b0) i1 (clk, rst, in[3:1], out[3:1], out[0]);
endmodule
```


<!-- ```verilog
// 选择器模板内部实现
module MuxKeyInternal #(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1, HAS_DEFAULT = 0) (
  output reg [DATA_LEN-1:0] out,
  input [KEY_LEN-1:0] key,
  input [DATA_LEN-1:0] default_out,
  input [NR_KEY*(KEY_LEN + DATA_LEN)-1:0] lut
);

  localparam PAIR_LEN = KEY_LEN + DATA_LEN;
  wire [PAIR_LEN-1:0] pair_list [NR_KEY-1:0];
  wire [KEY_LEN-1:0] key_list [NR_KEY-1:0];
  wire [DATA_LEN-1:0] data_list [NR_KEY-1:0];

  genvar n;
  generate
    for (n = 0; n < NR_KEY; n = n + 1) begin
      assign pair_list[n] = lut[PAIR_LEN*(n+1)-1 : PAIR_LEN*n];
      assign data_list[n] = pair_list[n][DATA_LEN-1:0];
      assign key_list[n]  = pair_list[n][PAIR_LEN-1:DATA_LEN];
    end
  endgenerate

  reg [DATA_LEN-1 : 0] lut_out;
  reg hit;
  integer i;
  always @(*) begin
    lut_out = 0;
    hit = 0;
    for (i = 0; i < NR_KEY; i = i + 1) begin
      lut_out = lut_out | ({DATA_LEN{key == key_list[i]}} & data_list[i]);
      hit = hit | (key == key_list[i]);
    end
    if (!HAS_DEFAULT) out = lut_out;
    else out = (hit ? lut_out : default_out);
  end
endmodule

// 不带默认值的选择器模板
module MuxKey #(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1) (
  output [DATA_LEN-1:0] out,
  input [KEY_LEN-1:0] key,
  input [NR_KEY*(KEY_LEN + DATA_LEN)-1:0] lut
);
  MuxKeyInternal #(NR_KEY, KEY_LEN, DATA_LEN, 0) i0 (out, key, {DATA_LEN{1'b0}}, lut);
endmodule

// 带默认值的选择器模板
module MuxKeyWithDefault #(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1) (
  output [DATA_LEN-1:0] out,
  input [KEY_LEN-1:0] key,
  input [DATA_LEN-1:0] default_out,
  input [NR_KEY*(KEY_LEN + DATA_LEN)-1:0] lut
);
  MuxKeyInternal #(NR_KEY, KEY_LEN, DATA_LEN, 1) i0 (out, key, default_out, lut);
endmodule
``` -->
```verilog
// Internal Implementation of the Multiplexer Template
module MuxKeyInternal #(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1, HAS_DEFAULT = 0) (
  output reg [DATA_LEN-1:0] out,
  input [KEY_LEN-1:0] key,
  input [DATA_LEN-1:0] default_out,
  input [NR_KEY*(KEY_LEN + DATA_LEN)-1:0] lut
);

  localparam PAIR_LEN = KEY_LEN + DATA_LEN;
  wire [PAIR_LEN-1:0] pair_list [NR_KEY-1:0];
  wire [KEY_LEN-1:0] key_list [NR_KEY-1:0];
  wire [DATA_LEN-1:0] data_list [NR_KEY-1:0];

  genvar n;
  generate
    for (n = 0; n < NR_KEY; n = n + 1) begin
      assign pair_list[n] = lut[PAIR_LEN*(n+1)-1 : PAIR_LEN*n];
      assign data_list[n] = pair_list[n][DATA_LEN-1:0];
      assign key_list[n]  = pair_list[n][PAIR_LEN-1:DATA_LEN];
    end
  endgenerate

  reg [DATA_LEN-1 : 0] lut_out;
  reg hit;
  integer i;
  always @(*) begin
    lut_out = 0;
    hit = 0;
    for (i = 0; i < NR_KEY; i = i + 1) begin
      lut_out = lut_out | ({DATA_LEN{key == key_list[i]}} & data_list[i]);
      hit = hit | (key == key_list[i]);
    end
    if (!HAS_DEFAULT) out = lut_out;
    else out = (hit ? lut_out : default_out);
  end
endmodule

// Multiplexer Template without Default Value
module MuxKey #(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1) (
  output [DATA_LEN-1:0] out,
  input [KEY_LEN-1:0] key,
  input [NR_KEY*(KEY_LEN + DATA_LEN)-1:0] lut
);
  MuxKeyInternal #(NR_KEY, KEY_LEN, DATA_LEN, 0) i0 (out, key, {DATA_LEN{1'b0}}, lut);
endmodule

// Multiplexer Template with Default Value
module MuxKeyWithDefault #(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1) (
  output [DATA_LEN-1:0] out,
  input [KEY_LEN-1:0] key,
  input [DATA_LEN-1:0] default_out,
  input [NR_KEY*(KEY_LEN + DATA_LEN)-1:0] lut
);
  MuxKeyInternal #(NR_KEY, KEY_LEN, DATA_LEN, 1) i0 (out, key, default_out, lut);
endmodule
```


<!-- 其中, `MuxKey`模块实现了"键值选择"功能, 即在一个`(键值, 数据)`的列表`lut`中,
根据给定的键值`key`, 将`out`设置为与其匹配的数据.
若列表中不存在键值为`key`的数据, 则`out`为`0`.
特别地, `MuxKeyWithDefault`模块可以提供一个默认值`default_out`,
当列表中不存在键值为`key`的数据, 则`out`为`default_out`. -->
In which, the `MuxKey` module implements the “key-value selection” function, 
which sets `out` to the matching data based on the provided key `key` from a list of `(key, data)` pairs `lut`.
If there is no data with the key value `key` in the list, `out` will be `0`. 
Specifically, the `MuxKeyWithDefault` module can provide a default value `default_out`, 
and when no key-value pair matches `key`, `out` will be `default_out`. 

<!-- 实例化这两个模块时需要注意如下两点:
* 需要使用者提供键值对的数量`NR_KEY`, 键值的位宽`KEY_LEN`以及数据的位宽`DATA_LEN`这三个参数,
并保证端口的信号宽度与提供的参数一致, 否则将会输出错误的结果
* 若列表中存在多个键值为`key`的数据, 则`out`的值是未定义的, 需要使用者来保证列表中的键值互不相同 -->
When instantiating these two modules, please note the following:
* Users need to provide the number of key-value pairs `NR_KEY`, the bit width of the key `KEY_LEN`, and the data width `DATA_LEN`, 
ensuring that the port signal widths match the parameters provided, or else incorrect results will be produced.
* If there are multiple data entries with the same key value in the list, the value of `out` is undefined, 
and it is the user’s responsibility to ensure that the key values in the list are unique.


<!-- `MuxKeyInternal`模块的实现中用到了很多高级的功能, 如`generate`和`for`循环等,
为了方便编写还使用了行为建模方式, 在这里我们不展开介绍,
通过结构化建模的抽象, 使用者可以无需关心这些细节. -->
The implementation of the `MuxKeyInternal` module utilizes various advanced features such as `generate` and `for` loops, 
and behavioral modeling has been used for convenience. 
Here, we do not elaborate on this; through the abstraction of structured modeling, users can ignore these details.


<!-- 以下代码通过使用选择器模板来分别实现2选1多路选择器和4选1多路选择器: -->
The following code uses the multiplexer templates to implement both a 2-to-1 multiplexer and a 4-to-1 multiplexer:


<!-- ```verilog
module mux21(a,b,s,y);
  input   a,b,s;
  output  y;

  // 通过MuxKey实现如下always代码
  // always @(*) begin
  //  case (s)
  //    1'b0: y = a;
  //    1'b1: y = b;
  //  endcase
  // end
  MuxKey #(2, 1, 1) i0 (y, s, {
    1'b0, a,
    1'b1, b
  });
endmodule

module mux41(a,s,y);
  input  [3:0] a;
  input  [1:0] s;
  output y;

  // 通过MuxKeyWithDefault实现如下always代码
  // always @(*) begin
  //  case (s)
  //    2'b00: y = a[0];
  //    2'b01: y = a[1];
  //    2'b10: y = a[2];
  //    2'b11: y = a[3];
  //    default: y = 1'b0;
  //  endcase
  // end
  MuxKeyWithDefault #(4, 2, 1) i0 (y, s, 1'b0, {
    2'b00, a[0],
    2'b01, a[1],
    2'b10, a[2],
    2'b11, a[3]
  });
endmodule
``` -->

```verilog
module mux21(a,b,s,y);
  input   a,b,s;
  output  y;

  // Implement the following always code through MuxKey
  // always @(*) begin
  //  case (s)
  //    1'b0: y = a;
  //    1'b1: y = b;
  //  endcase
  // end
  MuxKey #(2, 1, 1) i0 (y, s, {
    1'b0, a,
    1'b1, b
  });
endmodule

module mux41(a,s,y);
  input  [3:0] a;
  input  [1:0] s;
  output y;

  // Implement the following always code through MuxKeyWithDefault
  // always @(*) begin
  //  case (s)
  //    2'b00: y = a[0];
  //    2'b01: y = a[1];
  //    2'b10: y = a[2];
  //    2'b11: y = a[3];
  //    default: y = 1'b0;
  //  endcase
  // end
  MuxKeyWithDefault #(4, 2, 1) i0 (y, s, 1'b0, {
    2'b00, a[0],
    2'b01, a[1],
    2'b10, a[2],
    2'b11, a[3]
  });
endmodule
```


<!-- > #### hint::如果你使用Chisel, 也建议你不要使用when和switch
> 在Chisel中, `when`和`switch`的语义和Verilog的行为建模非常相似, 因此也不建议初学者使用.
> 相反, 你可以使用`Mux1H`等库函数来实现选择器的功能, 具体可以查阅Chisel的相关资料. -->
> ### hint:: if you use Chisel, it is also advised that you do not use "when" and "switch".
> In Chisel, the semantics of `when` and `switch` are very similar to Verilog’s behavioral modeling, so it is also not recommended for beginners to use them. 
> Instead, you can use library functions like `Mux1H` to implement multiplexer functionality. For specifics, you can refer to related materials on Chisel.


<!-- > #### caution::2. 如果你坚持使用Verilog的行为建模, 不要用negedge
> `posedge`和`negedge`混用, 会导致时序收敛更加困难, 增加后端物理实现的难度.
> 如果你不清楚如何在两者混用的情况下仍然保持很好的时序, 我们建议你只使用`posedge`.
> 否则, 如果你的处理器严重影响SoC整体的时序, 在流片时间节点紧张的情况下,
> "一生一芯"项目组将会把你的处理器移出该批次的流片名单.
>
> 如果你使用我们提供的上述Verilog模板, 或者使用Chisel, 你不必担心这一问题. -->
> #### caution: 2. if you insist on using Verilog’s behavioral modeling, do not use negedge.
> Mixing `posedge` and `negedge` can make timing convergence more difficult and increase the difficulty of backend physical implementation. 
> If you are unclear on how to maintain good timing while mixing both, we recommend you only use `posedge`. 
> Otherwise, if your processor severely affects the overall timing of the SoC, the OSOC project team will remove your processor from the batch of tape-out listings under tight tape-out deadlines. 
>
> If you use the Verilog templates we provided above or use Chisel, you do not need to worry about this issue.


<!-- > #### todo::尝试用negedge综合
> 以上述模块为例, 尝试评估以下模块的时序:
> ```verilog
> module test(input clk, input rst, input in, output out);
>   wire t0, t1;
>   Reg r1(clk, rst, in, t0, 1'b1);
>   Reg r2(clk, rst, t0, t1, 1'b1);
>   Reg r3(clk, rst, t1, out, 1'b1);
> endmodule
> ```
> 然后单独将`r2`修改为时钟下降沿触发, 并重新评估时序.
> 对比修改前后的时序报告, 你发现有什么不同之处?
> 如果你发现自己无法理解其中的细节, 不必担心,
> 我们会在B阶段进一步介绍时序分析的细节, 到时候将会重新讨论这个问题. -->
> #### todo: try synthesizing with negedge.
> Using the above modules as an example, attempt to evaluate the timing of the following module:
> ```verilog
> module test(input clk, input rst, input in, output out);
>   wire t0, t1;
>   Reg r1(clk, rst, in, t0, 1'b1);
>   Reg r2(clk, rst, t0, t1, 1'b1);
>   Reg r3(clk, rst, t1, out, 1'b1);
> endmodule
> ```
> Then modify `r2` to trigger on the falling edge of the clock and reevaluate the timing. 
> Compare the timing reports before and after the modification; what differences do you notice? 
> If you find yourself unable to understand the details, do not worry; 
> we will further introduce timing analysis details in Phase B, where we will revisit this issue.


<!-- > #### caution::3. 如果你坚持使用Verilog的行为建模, 不要使用锁存器(Latch)
> 锁存器的变化不受时钟驱动, 因此时序分析工具难以对其进行分析.
> 如果你不清楚如何避免锁存器, 我们建议你不要使用行为建模.
>
> 如果你使用我们提供的上述Verilog模板, 或者使用Chisel, 你不必担心这一问题. -->
> #### caution: 3. if you insist on using Verilog’s behavioral modeling, do not use latches.
> The changes in latches are not driven by the clock, making them difficult for timing analysis tools to analyze. 
> If you are unsure how to avoid latches, we recommend you not use behavioral modeling. 
>
> If you use the Verilog templates we provided above or use Chisel, you do not need to worry about this issue.


<!-- > #### caution::4. 需要在模块名前添加学号前缀
> 如`module IFU`需要修改为`module ysyx_22040000_IFU`.
> 这是因为大家将自己的处理器集成到SoC后, 名字相同的模块会导致工具报告重复定义的错误.
>
> 如果你使用Chisel, 我们将来会提供一个自动添加前缀的方法,
> 目前你编写代码时模块名不必添加学号前缀. -->
> #### caution:: 4. you need to add a student ID prefix before the module name.
> For example, `module IFU` needs to be modified to `module ysyx_22040000_IFU`. 
> This is because when everyone integrates their processor into the SoC, modules with the same name will lead to duplicate definition errors reported by the tools. 
>
> If you use Chisel, you do not need to add a student ID prefix to your module names while writing code for now.


<!-- > #### caution::5. 如果你使用Verilog, 需要在宏定义的标识符前添加学号前缀
> 如`` `define SIZE 5 ``需要修改为`` `define ysyx_22040000_SIZE 5 ``.
> 这是因为大家将自己的处理器集成到SoC后, 名字相同的宏会导致工具报告重复定义的错误.
>
> 如果你使用Chisel, 你不必担心这一问题. -->
> #### caution:: 5. if you use Verilog, you need to add a student ID prefix before the macro definition identifiers.
> For example, ``define SIZE 5` needs to be modified to ``define ysyx_22040000_SIZE 5`. 
> This is because when everyone integrates their processor into the SoC, macros with the same name will lead to duplicate definition errors reported by the tools. 
>
>If you use Chisel, you do not need to worry about this issue.


<!-- ## 完成数字电路实验 -->
## Complete Digital Circuit Experiments


<!-- 你之前已经通过在线学习网站HDLBits完成了不少数字电路的设计.
在搭建仿真环境并介绍EDA工具后, 我们已经可以支撑一个相对完整的数字电路设计流程: -->
You have previously completed several digital circuit designs through the online learning platform HDLBits. 
After setting up the simulation environment and introducing EDA tools, 
we can now support a relatively complete digital circuit design process:


<!-- ```
新需求 -> 架构设计 -> 逻辑设计 -> 功能验证 -> 电路评估
``` -->

```
New Requirements -> Architecture Design -> Logic Design -> Functional Verification -> Circuit Evaluation
```


<!-- 其中, `架构设计`是指"思考如何通过电路功能实现新需求的方案",
`逻辑设计`是指"用RTL代码实现设计方案",
`功能验证`目前通过Verilator仿真来实现, 以检查RTL代码实现的功能是否符合预期,
`电路评估`则是用开源EDA工具评估电路的性能, 面积, 功耗等指标. -->
Here, `Architecture Design` refers to “thinking about how to implement new requirements through circuit functionality,” 
`Logic Design` refers to “implementing the design plan using RTL code,” 
`Functional Verification` is currently achieved through Verilator simulation to check whether the functionality implemented by the RTL code meets expectations, 
and `Circuit Evaluation` uses open-source EDA tools to assess circuit performance, area, power consumption, and other metrics.


<!-- 接下来, 你将尝试按照上述流程来完成一些数字电路实验, 从而对其建立更深刻的认识. -->
Next, you will attempt to complete some digital circuit experiments according to the above process, thereby gaining a deeper understanding of it.


<!-- > #### hint::如果你想使用Chisel
> 请运行以下命令:
> ```bash
> cd ysyx-workbench
> bash init.sh npc-chisel
> ```
> 上述命令会将`npc`目录中的文件换成一个Chisel开发环境, 具体介绍可以阅读其中的`README.md`.
>
> 对于Chisel生成的Verilog代码, Verilator的静态代码检查功能产生的警告可能难以修复,
> 你可以在确定这些警告不影响代码正确性的情况下忽略它们.
> 但我们仍然建议你总是开启Verilator的静态代码检查功能,
> 因为在查阅这些警告的过程中, 你很有可能会发现一些代码逻辑相关的问题. -->
> #### hint:: if you want to use Chisel
> Please run the following command:
> ```bash
> cd ysyx-workbench
> bash init.sh npc-chisel
> ```
> This command will replace the files in the `npc` directory with a Chisel development environment; 
> specific details can be found in the `README.md` within it.
> 
> For Verilog code generated by Chisel, warnings from Verilator’s static code analysis may be difficult to fix, 
> but you can ignore them as long as you are sure these warnings do not affect code correctness. 
> However, we still recommend that you always enable Verilator’s static code check feature, 
> as you may discover some code logic-related issues while reviewing these warnings.


<!-- > #### info::vscode自动跳转插件
> * 如果选择Chisel编程,推荐metals插件
> * 如果选择Verilog编程, 推荐[digital ide][digital ide]插件 -->
> #### info:: VSCode Auto-Jump Plugin
> * If you choose Chisel programming, we recommend the metals plugin.
> * If you choose Verilog programming, we recommend the [digital ide][digital ide] plugin.


[digital ide]: https://digital-eda.github.io/DIDE-doc-Cn/#/?id=digital-ide-version-030



<!-- > #### todo::借助NVBoard完成数字电路实验
> 我们首先推荐南京大学的[数字电路与计算机组成实验][dlco].
>
> 南京大学开展教学改革, 将"数字电路"与"计算机组成原理"两门课程进行融合,
> 其实验内容贯穿从数字电路基础到简单的处理器设计.
> 有了NVBoard之后, 你就可以把它当作FPGA来使用, 用它来实现需要FPGA支持的实验内容.
>
> 你需要完成以下**必做内容**:
> * 实验二 译码器和编码器
> * 实验三 加法器与ALU
> * 实验六 移位寄存器及桶形移位器
> * 实验七 状态机及键盘输入
> * 实验八 VGA接口控制器实现
>
> 如果你打算使用Chisel来完成上述数字电路实验,
> 你只需要把编译出的Verilog代码接入Verilator和NVBoard就可以了. -->
> #### todo:: complete digital circuit experiments with NVBoard
> We first recommend Nanjing University's [Digital Circuit and Computer Composition Experiment][dlco].
> 
> Nanjing University has implemented a teaching reform that integrates “Digital Circuits” and “Computer Organization Principles” into a single course, 
> with experiment content spanning from the basics of digital circuits to simple processor design. 
> With NVBoard, you can treat it as an FPGA to implement experiments that require FPGA support.
>
> You need to complete the following mandatory content:
> * Experiment 2: Decoders and Encoders
> * Experiment 3: Adders and ALUs
> * Experiment 6: Shift Registers and Barrel Shifters
> * Experiment 7: State Machines and Keyboard Input
> * Experiment 8: VGA Interface Controller Implementation
>
> If you plan to use Chisel to complete the above digital circuit experiments, you just need to connect the compiled Verilog code to Verilator and NVBoard.

[dlco]: https://nju-projectn.github.io/dlco-lecture-note/en/index.html


<!-- ## 用RTL实现简单处理器 -->
## Implementing a Simple Processor with RTL


<!-- 终于到了用RTL来设计自己的第一个处理器的时刻了!
你已经用Logisim实现了sCPU, 要用RTL来实现sCPU,
就是根据Logisim中的电路结构图, 用RTL代码描述出每个模块的电路结构.
有了完成数字电路的经验, 这对你来说并不困难. -->
The moment has finally come to design your first processor using RTL! 
You have implemented sCPU using Logisim, and now to implement sCPU in RTL, 
you will describe the circuit structure of each module using RTL code based on the circuit schematic in Logisim. 
With your experience in completing digital circuits, this should not be difficult for you.


<!-- > #### todo::用RTL实现sCPU
> 尝试把sCPU作为NPC的设计目标, 根据之前你用Logisim设计的sCPU,
> 用RTL重新设计它, 用于计算`1+2+...+10`.
> 为了看到输出效果, 你可以在sCPU中添加`out rs`指令,
> 用于通过NVBoard的七段数码管显示数列求和的计算结果.
>
> 和sEMU不同, 我们暂时不要求你实现更强大的运行时环境,
> 目前只需要让这个处理器支持`1+2+...+10`的计算即可.
> 我们会在D阶段介绍运行时环境的更多相关内容. -->
> #### todo:: Implement sCPU with RTL
> Try to make sCPU the design target of NPC. 
> Based on the sCPU you designed with Logisim, redesign it using RTL for calculating `1+2+...+10`. 
> To see the output, you can add the `out rs` instruction in sCPU 
> to display the sum of the series on the seven-segment display of NVBoard.
>
> Unlike sEMU, we do not currently require you to implement a more powerful runtime environment; 
> we only need this processor to support the calculation of `1+2+...+10`.
> We will cover more about the runtime environment in the D phase.


<!-- > #### todo::对比sEMU和sCPU
> 针对sISA, 你已经分别实现了sEMU和sCPU.
> 尝试对比一下, 它们之间有什么不同? -->
> #### todo:: Compare sEMU and sCPU
> For sISA, you have implemented both sEMU and sCPU. 
> Try comparing them and see what differences there are.


<!-- > #### todo::评估sCPU的性能
> 尝试通过`yosys-sta`对你设计的sCPU进行评估. -->
> #### todo:: Evaluate the Performance of sCPU
> Try evaluating your designed sCPU using `yosys-sta`.

<!-- 恭喜你, 你已经基本完成了一个简单CPU的全流程设计了! -->
Congratulations, you have essentially completed a simple CPU’s full design process!

<!-- ```
新需求 -> 架构设计 -> 逻辑设计 -> 功能验证 -> 电路评估
``` -->
```
New Requirements -> Architecture Design -> Logic Design -> Functional Verification -> Circuit Evaluation
```

<!-- * sCPU设计的需求就是用RTL实现一个sISA的处理器
* F阶段的讲义内容已经帮助大家梳理了如何通过数字电路的功能来实现sCPU,
  这其实已经完成了架构设计, 其产出就是Logisim中的电路结构图
* 大家用RTL设计sCPU的过程, 就是逻辑设计的过程
* 用Verilator和NVBoard验证你的RTL代码能否成功运行`1+2+...+10`, 就是在进行功能验证
* 你已经用`yosys-sta`对sCPU进行了电路评估 -->
* The requirement for the sCPU design is to implement an sISA processor with RTL.
* The lecture content from phase F has already helped everyone to understand how to implement sCPU through digital circuit functionality, 
which essentially completes the architecture design, the output of which is the circuit schematic in Logisim.
* The process of designing sCPU with RTL is the logic design process.
* Verifying whether your RTL code can successfully run `1+2+...+10` using Verilator and NVBoard is the functional verification.
* You have conducted a circuit evaluation of sCPU using `yosys-sta`.


<!-- > #### option::使用开源EDA工具进行物理设计
> 目前"一生一芯"讲义只介绍了物理设计的过程,
> 暂未包含物理设计相关的动手实践内容.
> 如果你感兴趣, 你可以阅读[iEDA的入门教程][ieda guide],
> 并尝试用iEDA对sCPU进行物理设计, 生成相应的版图. -->
> #### option:: use open-source EDA tools for physical design
> Currently, the OSOC lecture only introduces the physical design process 
> and does not yet include hands-on practical content related to physical design. 
> If you are interested, you can read the [iEDA introductory tutorial][ieda guide] 
> and try to use iEDA for the physical design of sCPU to generate the corresponding layout.


[ieda guide]: https://ieda.oscc.cc/tools/ieda-platform/guide.html

<!-- 当然, sCPU的功能距离我们想要实现的CPU还差很远,
因此目前我们暂不要求大家去分析评估结果的好坏.
从项目流程上来看, 我们需要先设计出一个功能相对完整的CPU,
再考虑如何优化它, 这也是为了践行"先完成, 后完美"的法则.
后续的讲义内容将会按照上述流程,
指导大家如何设计功能更强大的处理器, 从而运行更复杂的程序. -->
Of course, the functionality of sCPU is still far from what we want to achieve in a CPU,
so we do not currently require everyone to analyze the evaluation results for quality. 
From the project process perspective, we need to first design a relatively complete CPU before considering how to optimize it, 
which also adheres to the principle of “complete first, perfect later.” 
Subsequent lecture content will follow this process, 
guiding everyone on how to design more powerful processors to run more complex programs.

<!-- ## 若干代码风格和规范

在往期的"一生一芯"计划中, 我们发现部分不规范的代码风格会给后期的SoC集成带来额外的问题.
为了避免将来影响SoC集成的进度, 我们建议大家遵守以下若干代码规范.

> #### caution::1. 如果你还没有深入理解Verilog的事件模型, 不要使用行为建模

事实上, 南京大学数字电路实验讲义中也提到"行为建模不利于初学者建立电路思维",
我们在这里引用相关的描述:

> #### caution::强烈建议初学者不要使用行为建模方式设计电路
> Verilog一开始并不是为了设计可综合电路而提出的, 它的本质是一门基于事件队列模型的电路建模语言.
> 因此, 行为建模很容易会让初学者偏离描述电路的初衷:
> 开发者需要看着电路图, 心里想象电路的行为, 然后转化成事件队列模型的思考方式,
> 最后再用行为建模方式来描述电路的行为, 综合器再来根据这样的描述推导出相应的电路.
> 从这个过程来看, 这不仅是没有必要的, 而且还很容易引入错误:
> * 如果开发者心里本身就已经有电路图, 直接描述它是最方便的
> * 如果开发者心里本身就已经有电路图, 而开发者对行为建模方式的理解所有偏差,
>   可能会采用了错误的描述方式, 从而设计出非预期的电路
> * 如果开发者心里没有电路图, 而是期望通过行为建模方式让综合器生成某种行为的电路,
>   这就已经偏离“描述电路”的本质了.
>   大部分同学非常容易犯这样的错误, 把行为建模当作过程式的C语言来写,
>   尝试把任意复杂的行为描述映射到电路, 最终综合器只会生成出延迟大, 面积大, 功耗高的低质量电路,
>   甚至因为代码包含数据竞争而被综合器综合成行为不符合预期的电路
>
> 所以, 直到大家掌握"描述电路"的思维而不被行为建模误导之前
> 我们强烈建议初学者远离行为建模方式, 仅通过数据流建模和结构化建模方式直接描述电路.
> 下面的问题可以帮助大家测试自己是否已经掌握Verilog的本质:
> * 在硬件描述语言中, "执行"的精确含义是什么?
> * 是谁在执行Verilog的语句? 是电路，综合器，还是其它的?
> * if的条件满足, 就不执行else后的语句, 这里的"不执行"又是什么意思? 和描述电路有什么联系?
> * 有"并发执行", 又有"顺序执行", 还有"任何一个变量发生变化就立即执行",
>   以及"在任何情况下都执行", 它们都是如何在设计出来的电路中体现的?
>
> 如果你无法对这些问题作出明确的回答, 我们强烈建议你不要使用行为建模方式.
> 如果你真的想弄懂它们, 你需要阅读[Verilog标准手册][verilog manual].

> #### caution:: 真正的描述电路 = 实例化 + 连线
> 忘记行为建模方式, 就可以很容易回归到描述电路的简单本质.
> 想象一下, 你手中有一张电路图纸, 如果你需要向其它人描述图纸上的内容, 你将会如何描述?
> 你一定会说出类似"有一个A元件/模块, 它的x引脚和另一个B元件/模块的y引脚相连"的描述,
> 因为这才是描述电路的最自然的方式.
> 用HDL设计电路, 就是在用HDL来描述电路图纸, 图纸上有什么, 就直接描述什么.
> 所以, 用HDL描述电路, 无非是做两件事情:
> * 实例化: 在电路板上放一个元件/模块, 可以是一个门电路, 或者是由门电路组成的模块
> * 连线: 用导线将元件/模块的引脚正确地连起来
>
> 大家可以体会一下, 数据流建模和结构化建模是如何体现这两件事的,
> 而行为建模又是如何把这两件简单的事情复杂化的.

所以, 我们不建议初学者在Verilog代码中编写任何always语句.
为了方便大家使用触发器和选择器, 我们提供了如下Verilog模板给大家进行调用:
```verilog
// 触发器模板
module Reg #(WIDTH = 1, RESET_VAL = 0) (
  input clk,
  input rst,
  input [WIDTH-1:0] din,
  output reg [WIDTH-1:0] dout,
  input wen
);
  always @(posedge clk) begin
    if (rst) dout <= RESET_VAL;
    else if (wen) dout <= din;
  end
endmodule

// 使用触发器模板的示例
module example(
  input clk,
  input rst,
  input [3:0] in,
  output [3:0] out
);
  // 位宽为1比特, 复位值为1'b1, 写使能一直有效
  Reg #(1, 1'b1) i0 (clk, rst, in[0], out[0], 1'b1);
  // 位宽为3比特, 复位值为3'b0, 写使能为out[0]
  Reg #(3, 3'b0) i1 (clk, rst, in[3:1], out[3:1], out[0]);
endmodule
```

```verilog
// 选择器模板内部实现
module MuxKeyInternal #(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1, HAS_DEFAULT = 0) (
  output reg [DATA_LEN-1:0] out,
  input [KEY_LEN-1:0] key,
  input [DATA_LEN-1:0] default_out,
  input [NR_KEY*(KEY_LEN + DATA_LEN)-1:0] lut
);

  localparam PAIR_LEN = KEY_LEN + DATA_LEN;
  wire [PAIR_LEN-1:0] pair_list [NR_KEY-1:0];
  wire [KEY_LEN-1:0] key_list [NR_KEY-1:0];
  wire [DATA_LEN-1:0] data_list [NR_KEY-1:0];

  genvar n;
  generate
    for (n = 0; n < NR_KEY; n = n + 1) begin
      assign pair_list[n] = lut[PAIR_LEN*(n+1)-1 : PAIR_LEN*n];
      assign data_list[n] = pair_list[n][DATA_LEN-1:0];
      assign key_list[n]  = pair_list[n][PAIR_LEN-1:DATA_LEN];
    end
  endgenerate

  reg [DATA_LEN-1 : 0] lut_out;
  reg hit;
  integer i;
  always @(*) begin
    lut_out = 0;
    hit = 0;
    for (i = 0; i < NR_KEY; i = i + 1) begin
      lut_out = lut_out | ({DATA_LEN{key == key_list[i]}} & data_list[i]);
      hit = hit | (key == key_list[i]);
    end
    if (!HAS_DEFAULT) out = lut_out;
    else out = (hit ? lut_out : default_out);
  end
endmodule

// 不带默认值的选择器模板
module MuxKey #(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1) (
  output [DATA_LEN-1:0] out,
  input [KEY_LEN-1:0] key,
  input [NR_KEY*(KEY_LEN + DATA_LEN)-1:0] lut
);
  MuxKeyInternal #(NR_KEY, KEY_LEN, DATA_LEN, 0) i0 (out, key, {DATA_LEN{1'b0}}, lut);
endmodule

// 带默认值的选择器模板
module MuxKeyWithDefault #(NR_KEY = 2, KEY_LEN = 1, DATA_LEN = 1) (
  output [DATA_LEN-1:0] out,
  input [KEY_LEN-1:0] key,
  input [DATA_LEN-1:0] default_out,
  input [NR_KEY*(KEY_LEN + DATA_LEN)-1:0] lut
);
  MuxKeyInternal #(NR_KEY, KEY_LEN, DATA_LEN, 1) i0 (out, key, default_out, lut);
endmodule
```
其中, `MuxKey`模块实现了"键值选择"功能, 即在一个`(键值, 数据)`的列表`lut`中,
根据给定的键值`key`, 将`out`设置为与其匹配的数据.
若列表中不存在键值为`key`的数据, 则`out`为`0`.
特别地, `MuxKeyWithDefault`模块可以提供一个默认值`default_out`,
当列表中不存在键值为`key`的数据, 则`out`为`default_out`.
实例化这两个模块时需要注意如下两点:
* 需要使用者提供键值对的数量`NR_KEY`, 键值的位宽`KEY_LEN`以及数据的位宽`DATA_LEN`这三个参数,
并保证端口的信号宽度与提供的参数一致, 否则将会输出错误的结果
* 若列表中存在多个键值为`key`的数据, 则`out`的值是未定义的, 需要使用者来保证列表中的键值互不相同

`MuxKeyInternal`模块的实现中用到了很多高级的功能, 如`generate`和`for`循环等,
为了方便编写还使用了行为建模方式, 在这里我们不展开介绍,
通过结构化建模的抽象, 使用者可以无需关心这些细节.

以下代码通过使用选择器模板来分别实现2选1多路选择器和4选1多路选择器:
```verilog
module mux21(a,b,s,y);
  input   a,b,s;
  output  y;

  // 通过MuxKey实现如下always代码
  // always @(*) begin
  //  case (s)
  //    1'b0: y = a;
  //    1'b1: y = b;
  //  endcase
  // end
  MuxKey #(2, 1, 1) i0 (y, s, {
    1'b0, a,
    1'b1, b
  });
endmodule

module mux41(a,s,y);
  input  [3:0] a;
  input  [1:0] s;
  output y;

  // 通过MuxKeyWithDefault实现如下always代码
  // always @(*) begin
  //  case (s)
  //    2'b00: y = a[0];
  //    2'b01: y = a[1];
  //    2'b10: y = a[2];
  //    2'b11: y = a[3];
  //    default: y = 1'b0;
  //  endcase
  // end
  MuxKeyWithDefault #(4, 2, 1) i0 (y, s, 1'b0, {
    2'b00, a[0],
    2'b01, a[1],
    2'b10, a[2],
    2'b11, a[3]
  });
endmodule
```

> #### hint::如果你使用Chisel, 也建议你不要使用when和switch
> 在Chisel中, `when`和`switch`的语义和Verilog的行为建模非常相似, 因此也不建议初学者使用.
> 相反, 你可以使用`Mux1H`等库函数来实现选择器的功能, 具体可以查阅Chisel的相关资料.

> #### caution::2. 如果你坚持使用Verilog的行为建模, 不要用negedge
> `posedge`和`negedge`混用, 会导致时序收敛更加困难, 增加后端物理实现的难度.
> 如果你不清楚如何在两者混用的情况下仍然保持很好的时序, 我们建议你只使用`posedge`.
> 否则, 如果你的处理器严重影响SoC整体的时序, 在流片时间节点紧张的情况下,
> "一生一芯"项目组将会把你的处理器移出该批次的流片名单.
>
> 如果你使用我们提供的上述Verilog模板, 或者使用Chisel, 你不必担心这一问题.

> #### todo::尝试用negedge综合
> 以上述模块为例, 尝试评估以下模块的时序:
> ```verilog
> module test(input clk, input rst, input in, output out);
>   wire t0, t1;
>   Reg r1(clk, rst, in, t0, 1'b1);
>   Reg r2(clk, rst, t0, t1, 1'b1);
>   Reg r3(clk, rst, t1, out, 1'b1);
> endmodule
> ```
> 然后单独将`r2`修改为时钟下降沿触发, 并重新评估时序.
> 对比修改前后的时序报告, 你发现有什么不同之处?
> 如果你发现自己无法理解其中的细节, 不必担心,
> 我们会在B阶段进一步介绍时序分析的细节, 到时候将会重新讨论这个问题.

> #### caution::3. 如果你坚持使用Verilog的行为建模, 不要使用锁存器(Latch)
> 锁存器的变化不受时钟驱动, 因此时序分析工具难以对其进行分析.
> 如果你不清楚如何避免锁存器, 我们建议你不要使用行为建模.
>
> 如果你使用我们提供的上述Verilog模板, 或者使用Chisel, 你不必担心这一问题.

> #### caution::4. 需要在模块名前添加学号前缀
> 如`module IFU`需要修改为`module ysyx_22040000_IFU`.
> 这是因为大家将自己的处理器集成到SoC后, 名字相同的模块会导致工具报告重复定义的错误.
>
> 如果你使用Chisel, 我们将来会提供一个自动添加前缀的方法,
> 目前你编写代码时模块名不必添加学号前缀.

> #### caution::5. 如果你使用Verilog, 需要在宏定义的标识符前添加学号前缀
> 如`` `define SIZE 5 ``需要修改为`` `define ysyx_22040000_SIZE 5 ``.
> 这是因为大家将自己的处理器集成到SoC后, 名字相同的宏会导致工具报告重复定义的错误.
>
> 如果你使用Chisel, 你不必担心这一问题.

## 完成数字电路实验

你之前已经通过在线学习网站HDLBits完成了不少数字电路的设计.
在搭建仿真环境并介绍EDA工具后, 我们已经可以支撑一个相对完整的数字电路设计流程:
```
新需求 -> 架构设计 -> 逻辑设计 -> 功能验证 -> 电路评估
```
其中, `架构设计`是指"思考如何通过电路功能实现新需求的方案",
`逻辑设计`是指"用RTL代码实现设计方案",
`功能验证`目前通过Verilator仿真来实现, 以检查RTL代码实现的功能是否符合预期,
`电路评估`则是用开源EDA工具评估电路的性能, 面积, 功耗等指标.

接下来, 你将尝试按照上述流程来完成一些数字电路实验, 从而对其建立更深刻的认识.

> #### hint::如果你想使用Chisel
> 请运行以下命令:
> ```bash
> cd ysyx-workbench
> bash init.sh npc-chisel
> ```
> 上述命令会将`npc`目录中的文件换成一个Chisel开发环境, 具体介绍可以阅读其中的`README.md`.
>
> 对于Chisel生成的Verilog代码, Verilator的静态代码检查功能产生的警告可能难以修复,
> 你可以在确定这些警告不影响代码正确性的情况下忽略它们.
> 但我们仍然建议你总是开启Verilator的静态代码检查功能,
> 因为在查阅这些警告的过程中, 你很有可能会发现一些代码逻辑相关的问题.

> #### info::vscode自动跳转插件
> * 如果选择Chisel编程,推荐metals插件
> * 如果选择Verilog编程, 推荐[digital ide][digital ide]插件

[digital ide]: https://digital-eda.github.io/DIDE-doc-Cn/#/?id=digital-ide-version-030

> #### todo::借助NVBoard完成数字电路实验
> 我们首先推荐南京大学的[数字电路与计算机组成实验][dlco].
>
> 南京大学开展教学改革, 将"数字电路"与"计算机组成原理"两门课程进行融合,
> 其实验内容贯穿从数字电路基础到简单的处理器设计.
> 有了NVBoard之后, 你就可以把它当作FPGA来使用, 用它来实现需要FPGA支持的实验内容.
>
> 你需要完成以下**必做内容**:
> * 实验二 译码器和编码器
> * 实验三 加法器与ALU
> * 实验六 移位寄存器及桶形移位器
> * 实验七 状态机及键盘输入
> * 实验八 VGA接口控制器实现
>
> 如果你打算使用Chisel来完成上述数字电路实验,
> 你只需要把编译出的Verilog代码接入Verilator和NVBoard就可以了.

[dlco]: https://nju-projectn.github.io/dlco-lecture-note/index.html

## 用RTL实现简单处理器

终于到了用RTL来设计自己的第一个处理器的时刻了!
你已经用Logisim实现了sCPU, 要用RTL来实现sCPU,
就是根据Logisim中的电路结构图, 用RTL代码描述出每个模块的电路结构.
有了完成数字电路的经验, 这对你来说并不困难.

> #### todo::用RTL实现sCPU
> 尝试把sCPU作为NPC的设计目标, 根据之前你用Logisim设计的sCPU,
> 用RTL重新设计它, 用于计算`1+2+...+10`.
> 为了看到输出效果, 你可以在sCPU中添加`out rs`指令,
> 用于通过NVBoard的七段数码管显示数列求和的计算结果.
>
> 和sEMU不同, 我们暂时不要求你实现更强大的运行时环境,
> 目前只需要让这个处理器支持`1+2+...+10`的计算即可.
> 我们会在D阶段介绍运行时环境的更多相关内容.

> #### todo::对比sEMU和sCPU
> 针对sISA, 你已经分别实现了sEMU和sCPU.
> 尝试对比一下, 它们之间有什么不同?

> #### todo::评估sCPU的性能
> 尝试通过`yosys-sta`对你设计的sCPU进行评估.

恭喜你, 你已经基本完成了一个简单CPU的全流程设计了!
```
新需求 -> 架构设计 -> 逻辑设计 -> 功能验证 -> 电路评估
```
* sCPU设计的需求就是用RTL实现一个sISA的处理器
* F阶段的讲义内容已经帮助大家梳理了如何通过数字电路的功能来实现sCPU,
  这其实已经完成了架构设计, 其产出就是Logisim中的电路结构图
* 大家用RTL设计sCPU的过程, 就是逻辑设计的过程
* 用Verilator和NVBoard验证你的RTL代码能否成功运行`1+2+...+10`, 就是在进行功能验证
* 你已经用`yosys-sta`对sCPU进行了电路评估

> #### option::使用开源EDA工具进行物理设计
> 目前"一生一芯"讲义只介绍了物理设计的过程,
> 暂未包含物理设计相关的动手实践内容.
> 如果你感兴趣, 你可以阅读[iEDA的入门教程][ieda guide],
> 并尝试用iEDA对sCPU进行物理设计, 生成相应的版图.

[ieda guide]: https://ieda.oscc.cc/tools/ieda-platform/guide.html

当然, sCPU的功能距离我们想要实现的CPU还差很远,
因此目前我们暂不要求大家去分析评估结果的好坏.
从项目流程上来看, 我们需要先设计出一个功能相对完整的CPU,
再考虑如何优化它, 这也是为了践行"先完成, 后完美"的法则.
后续的讲义内容将会按照上述流程,
指导大家如何设计功能更强大的处理器, 从而运行更复杂的程序. -->
