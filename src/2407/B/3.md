<!-- # B3 时序分析和优化 -->
# B3 Time Analysis and Optimization

<!-- > #### flag::建设中
> 本页面的内容仍在建设中, 但暂无编程内容. -->

> #### flag::Under Construction
> The content of this page is still under construction, no programming assignments at this time.

<!--

## 组合逻辑的延迟

考虑两个具有上下游关系的触发器$FF_1$和$FF_2$, 它们由相同的时钟信号$clk$驱动,
$FF_1$的输出经过一系列组合逻辑电路后连接到$FF_2$的数据输入端.
假设时钟工作在100MHz, 也即每个周期为10ns, 那么, 对于这对触发器而言,
当$FF_1$的数据更新时, $FF_1.Q$需要在10ns之内经过组合逻辑计算出新数据并传递到$FF_2.D$,
才能在下一个时钟到来之前将正确的数据更新到$FF_2$中.

```
         FF1                          FF2
       +-----+   +-------------+    +-----+
  -----|D   Q|---|Combinational|----|D   Q|-----
       |     |   |    Logic    |    |     |
     +-|>C   |   +-------------+  +-|>C   |
     | +-----+                    | +-----+
     |                            |
clk--+----------------------------+
```

为了方便分析, 一般会引入三个和时序相关的概念:
* 到达时间(Arrival Time, AT):
  指信号从上游触发器输出端传播到下游触发器输入端所需的时间.
* 要求到达时间(Required Arrival Time, RAT):
  指信号要求到达下游触发器输入端的最晚时间, 以满足时序约束.
* 时序余量$slack = RAT - AT$, 用于表示在满足时序约束的情况下还有多少余量,
  若为负, 表示发生时序违例(timing violation), 即电路无法在指定的时序约束下正确工作.

因此, 要让电路满足时序约束, 则需要slack不为负数:
$$slack = RAT(FF_2.D) - AT(FF_2.D) \ge 0$$
如果只考虑组合逻辑延迟, 则有
* $AT(FF_2.D) = T_{comb}(FF_1.Q \to FF_2.D)$, 即图中组合逻辑的延迟.
* $RAT(FF_2.D) = T_{cycle}$, 即时钟周期.

组合逻辑电路中一条路径的延迟由路径上的所有门电路的延迟累加得到,
例如, 对于2选1选择器电路, 从输入端$D_0$到输出端$Y$需要经过一个与门和一个或门,
因此相应路径的延迟为$T_{comb}(D_0 \to Y) = T_{and} + T_{or}$.
而每个门电路的延迟都以元件参数的形式记录在标准单元库中,
通过查阅标准单元库中记录的条目或相应手册, 可以计算出$T_{comb}(D_0 \to Y)$的具体值.

实际上, 信号经过一个门电路的延迟比你想象中要复杂很多,
这是因为在不同情况下, 门电路中晶体管的工作情况也有所不同:
* 门电路的负载(load)多, 则延迟高:
  一个门电路的负载是指其输出端连接的下游电路, 当门电路的负载增加时,
  它需要花费更多时间来让下游门电路的晶体管进行翻转, 从而造成更大的延迟.
  这意味着, 即使是结构相同的与门, 位于电路拓扑中不同位置时, 延迟也不同.
* 输入信号的翻转时间长, 则延迟高:
  受不同负载的影响, 下游门电路的输入信号翻转时间也不完全相同.
  而门电路的输入信号稳定不变后, 其输出才有可能稳定.
  显然, 若输入信号翻转得快, 则门电路的延迟低.
* 信号翻转方向不同, 延迟也不同: 这是由晶体管的电气特性决定的.
  由于nMOS中电子的移动能力(专业术语称为`迁移率`)比pMOS中空穴的移动能力强,
  因此在同等条件下, nMOS从截止状态变为导通状态所需时间比pMOS短.
  以与非门为例, 要让与非门的输出从`0`变成`1`,
  需要将pMOS从截止变为导通, 延迟较大;
  而输出从`1`变成`0`, 则需要将nMOS从截止变为导通. 延迟较小.
* 信号由门电路的不同输入端输入, 延迟也不同: 这是由晶体管在门电路中的排布特性决定的.
  从逻辑上来说, 门电路的输入是对称的, 但从物理上的排布方式来说并不是.
  以下图的与非门为例, 两个pMOS通过并联方式排布, 因此从pMOS来看是对称的;
  但两个nMOS却通过串联方式排布, 其中`N2`距离输出端更远,
  导致输入端`B`的信号变化需要经过`N1`才能传递到输出端, 因此延迟更高.

![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/0ec7da12ad700070140f4216bc8d596c89a9a92b.png)

因此, EDA工具需要综合考虑上述各种情况,
建立一个与真实情况尽可能接近的延迟模型,
再借助这个模型来估算门电路的延迟.
但即使不考虑上述情况, 对于一个真实的门电路来说,
其延迟也并非固定不变, 而是服从一定的概率分布.
EDA工具在评估延迟时, 还需要根据概率分布选择一个合适的取值,
使得生产出的绝大部分真实芯片都能满足EDA工具的设置的约束条件而正确工作.

一般来说, 从$FF_1.Q$到$FF_2.D$有多条路径.
继续以2选1选择器电路为例, 假设$FF_1.Q$与选择器的选择输入端$S$连接,
$FF_2.D$与选择器的输出端$Y$连接, 则从$FF_1.Q$到 $FF_2.D$有两条路径:
第一条路径通过1-2译码器和上方的与门$and_1$连接到$Y$,
第二条路径通过1-2译码器和下方的与门$and_2$连接到$Y$.
注意到, 对于第一条路径, 它需要经过1-2译码器中的一个非门,
而第二条路径在1-2译码器中不需要经过任何门而直接通过.
根据这些分析, 我们可以分别列出两条路径的延迟:
$$T_{comb}(path_1 : not \to and_1 \to or) = T_{not} + T_{and} + T_{or}$$
$$T_{comb}(path_2 : and_2 \to or) = T_{and} + T_{or}$$
组合逻辑电路的延迟由延迟最大的路径决定,
经过该延迟后, 组合逻辑电路中的所有信号都已达到稳定值, 不再发生变化,
从而满足下游的触发器更新数据的条件.
上例中, 应取$T_{comb}(path_1)$作为整个2选1选择器电路的延迟.

#### 时序逻辑的延迟

刚才我们假设时钟信号到来的瞬间, 数据就会写入触发器.
但这只是理想的行为, 在真实的电路中, 这一写入操作并非瞬间完成的.

回顾主从式D触发器的结构, 其工作过程分如下阶段:
1. 数据准备阶段. 此时`clk`为`0`, 输入数据`D`进入主锁存器;
   但从锁存器的使能端无效, 输入数据`D`无法进入从锁存器, 从而无法传播到输出端`Q`.
1. 采样阶段. 此时`clk`从`0`变为`1`, 主锁存器使能端无效,
   将当前的输入数据`D`锁存在主锁存器,
   输入数据`D`的后续变化将无法对主锁存器造成影响.
   同时, 从锁存器的使能端开始有效, 主锁存器锁存的数据将进入从锁存器, 并传递到输出端`Q`.
1. 维持阶段. 此时`clk`为`1`, 主锁存器的使能端无效, 因此不受输入数据`D`变化的影响;
   从锁存器的使能端虽然有效, 但由于主锁存器保持不变, 故从锁存器也保持不变.

![image](https://ysyx.oscc.cc/slides/2306/resources/img/tikz-images/9ab76d4a01bbe8d6031ccd52a10667193d756e31.png)

不要忘了, 图中的D锁存器也是由门电路组成的.
根据D锁存器的结构, 输入数据`D`从输入端写入到主锁存器内部,
还需要经过非门, 与门, 或非门等一系列门电路, 这些都需要经过一定的延迟.
最保险的做法是, 让输入数据`D`在`clk`到来之前的一段时间内稳定不变,
从而保证在`clk`到来进行数据采样时, 输入数据`D`就已经写入到主锁存器内部.
这样的一段时间称为建立时间(setup time).

另一方面, `clk`的变化也需要经过一定的延迟才能传播到主锁存器内部,
经过这段延迟后, 输入数据`D`才算是真正锁存在主锁存器中.
因此, 我们还需要让输入数据`D`在`clk`到来之后的一段时间内稳定不变,
从而保证主锁存器锁存的数据符合预期.
这样的一段时间称为保持时间(hold time).

```
           +------+      +------+      +------
clk        |      |      |      |      |
     ------+      +------+      +------+
                     |-+-|-+-|
         setup time <--+   +-> hold time
```

因此, 为了保证数据成功写入触发器, 我们还需要让数据在时钟信号到来前后各自一段时间内都保持稳定.
如果数据在建立时间内发生变化, 就无法保证主锁存器采样的值符合预期;
如果数据在保持时间内发生变化, 就无法保证主锁存器采样到一个预期的值.
更糟糕的是, 如果数据变化的时刻和时钟到来的时刻非常接近,
主锁存器可能会在内部门电路延迟的作用下进入亚稳态, 整个电路无法按预期工作.

保持时间描述的是从时钟到来到新数据被成功锁存的时间,
但这并不代表已经可以从触发器的输出端读到新数据.
以上文的主从式D触发器为例, 保持时间描述的是新数据被成功锁存在主锁存器的所需时间,
而要从触发器的输出端读到新数据, 还需要经过从锁存器.
因此, 触发器需要另一个参数来描述从时钟到来到输出端稳定输出新数据之间的时间,
这个参数称为称为Clock-to-Q延迟.

## 静态时序分析

### 建立时间分析

考虑两个具有上下游关系的触发器$FF_1$和$FF_2$,
并同时考虑组合逻辑延迟和时序逻辑延迟, 则
$$AT(FF_2.D) = T_{Clock-to-Q}(FF_1) + T_{comb}(FF_1.Q \to FF_2.D)$$
$$RAT_{setup}(FF_2.D) = T_{cycle} - T_{setup}(FF_2)$$
其中, RAT需要扣除$T_{setup}(FF_2)$是因为建立时间的要求,
即数据信号$FF_2.D$需要在下个时钟到来之前的一段时间内保持稳定,
因此实际上$FF_2.D$的RAT比一个时钟周期要短.

类似地, 要让电路满足时序约束, 则需要slack不为负数:
$$slack = RAT_{setup}(FF_2.D) - AT(FF_2.D) \ge 0$$
即
$$T_{comb}(FF_1.Q \to FF_2.D) \le T_{cycle} - T_{setup}(FF_2) - T_{Clock-to-Q}(FF_1)$$
这一不等式给出了满足时序约束时的组合逻辑最大延迟,
当实际的组合逻辑延迟大于该值, 则发生建立时间违例(setup violation).

todo: 如何修复setup违例

https://www.vlsi-expert.com/2014/01/10-ways-to-fix-setup-and-hold-violation.html

### 保持时间分析

另一方面, 我们还需要考虑$FF_2$的保持时间:
$$RAT_{hold}(FF_2.D) = T_{hold}(FF_2)$$
并要求slack不为负数:
$$slack = AT(FF_2.D) - RAT_{hold}(FF_2.D) \ge 0$$
注意对于保持时间来说, slack的计算方式和建立时间的slack有所不同,
这是因为$FF_2$的保持时间要求信号$FF_2.D$不能过早到达,
避免覆盖了当前周期$FF_2$正在锁存的, 由上一周期计算得到的$FF_2.D$的旧值.
化简后可得
$$T_{comb}(FF_1.Q \to FF_2.D) \ge T_{hold}(FF_2) - T_{Clock-to-Q}(FF_1)$$
这一不等式给出了满足时序约束时的组合逻辑最小延迟,
当实际的组合逻辑延迟小于该值, 则发生保持时间违例(hold violation).

因此, 对于一个时序逻辑元件(如触发器或存储器), 我们都可以计算出

-->
