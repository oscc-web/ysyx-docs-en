<!-- # D4 用RTL实现迷你RISC-V处理器 -->
# D4 Implementing a mini RISC-V Processor using RTL

<!-- 有了AM, 我们就可以考虑用RTL实现一个更强大的处理器, 并在处理器上运行更多程序.
不过如F阶段所分析, sISA由于过于简单, 很难支撑更多程序的运行,
因此, 我们先考虑将E阶段用RTL实现的NPC"升级"为一个minirv处理器.
借助minirv的完备性, 我们就可以在NPC上运行更多程序了. -->
With AM, we can consider using RTL to implement a more powerful processor and run more programs on it.
However, as analysed in F Stage, sISA is too simple to support running more programs.
Therefore, we first consider 'upgrading' the NPC implemented in RTL in E Stage to a minirv processor.
With the completeness of minirv, we can run more programs on the NPC.

<!-- ## 模块化的RTL设计

和sCPU不同, 将来我们还会不断改进NPC, 在其中添加更多的功能.
因此, 我们有必要维护好NPC项目, 为将来的改进做好准备.
维护代码的一个方式就是模块化. -->
## Modular RTL Design
Unlike sCPU, we will continue to improve NPC in the future and add more features to it.
Therefore, it is necessary to maintain the NPC project and prepare for future improvements.
One way to maintain code is through modularisation.

<!-- 回顾minirv的ISA规范:
* PC初值为`0`
* GPR数量与RV32E中定义的GPR数量一致
* 支持如下8条指令: `add`, `addi`, `lui`, `lw`, `lbu`, `sw`, `sb`, `jalr`
* 其他的ISA细节与RV32I相同 -->
Review of minirv's ISA specification:
* PC initial value is `0`
* Number of GPRs is consistent with the number of GPRs defined in RV32E
* Supports the following 8 instructions: `add`, `addi`, `lui`, `lw`, `lbu`, `sw`, `sb`, `jalr`
* Other ISA details are the same as RV32I

<!-- 从指令类型来看, minirv的指令涵盖的功能包括加法, 位拼接, 访存和跳转.
我们可以根据这些功能, 结合处理器的工作流程给NPC划分模块:
* IFU(Instruction Fetch Unit): 负责根据当前PC从存储器中取出一条指令
* IDU(Instruction Decode Unit): 负责对当前指令进行译码, 准备执行阶段需要使用的数据和控制信号
* EXU(EXecution Unit): 负责根据控制信号控制ALU, 对数据进行计算
* LSU(Load-Store Unit): 负责根据控制信号控制存储器, 从存储器中读出数据, 或将数据写入存储器
* WBU(WriteBack Unit): 将数据写入寄存器, 并更新PC -->
From the perspective of instruction types, minirv instructions cover functions such as addition, bit concatenation, memory access, and jumps.
Based on these functions, we can divide NPC into modules according to the processor's workflow:
* IFU(Instruction Fetch Unit): Responsible for fetching an instruction from memory based on the current PC.
* IDU(Instruction Decode Unit): Responsible for decoding the current instruction, preparing the data and control signals needed for the execution stage.
* EXU(EXecution Unit): Responsible for controlling the ALU based on control signals and performing calculations on data
* LSU(Load-Store Unit): Responsible for controlling the memory based on control signals, reading data from memory, or writing data to memory
* WBU(WriteBack Unit): Writes data to registers and updates the PC

<!-- 你需要自行梳理出模块之间的接口.
当然, 你也可以自行决定将哪些部件放置在哪一个模块中.
一个例外是存储器, 为了方便测试, 我们不打算通过RTL来实现这个存储器, 而是用C++来实现它.
当前, 我们先考虑一种最简单的实现方式:
将存储器访问接口的信号拉到顶层, 通过C++代码来访问存储器. -->
You need to sort out the interfaces between modules yourself.
Of course, you can also decide for yourself which components to place in which module.
One exception is memory. To facilitate testing, we implement memory in C++ instead of RTL.
For now, let's consider the simplest implementation method:
pull the memory access interface signals to the top layer and access the memory using C++ code.
```c
while (???) {
  ...
  top->inst = pmem_read(top->pc);
  top->eval();
  ...
}
```
<!-- 你可以很容易地通过C++代码来实现一个简单的存储器. -->
You can easily implement a simple memory using C++ code.

<!-- ## 只有两条指令的minirv处理器 -->
## Minirv Processor with Only Two Instructions

<!-- 接下来, 我们来实现一条最简单的指令: `addi`.
你已经在F阶段中用Logisim实现了minirv处理器,
因此你应该已经有一个相对完整的处理器架构图, 或者能够在心中想象指令如何在上述模块中执行.
有了架构图或者指令执行流程, 要用RTL描述相关的模块, 就很容易了. -->
Next, we will implement the simplest instruction: `addi`.
You have already implemented the minirv processor in Logisim in Phase F,
so you should already have a relatively complete processor architecture diagram, or be able to imagine how instructions are executed in the above modules.
With the architecture diagram or instruction execution flow, it is easy to describe the relevant modules using RTL.

<!-- > #### todo::在NPC中实现addi指令
> 具体地, 你需要注意以下事项:
> * 存储器中可以放置若干条`addi`指令的二进制编码(可以利用0号寄存器的特性来编写行为确定的指令)
> * 由于目前未实现跳转指令, 因此NPC只能顺序执行, 你可以在NPC执行若干指令之后停止仿真
> * 可以通过查看波形, 或者在RTL代码中打印通用寄存器的状态, 来检查`addi`指令是否被正确执行
> * 关于通用寄存器, 其电路本质是一个存储器.
>   为了避免选择Verilog的同学编写出不太合理的行为建模代码,
>   我们给出如下不完整的代码供大家补充(大家无需改动`always`代码块中的内容):
> ```verilog
> module RegisterFile #(ADDR_WIDTH = 1, DATA_WIDTH = 1) (
>   input clk,
>   input [DATA_WIDTH-1:0] wdata,
>   input [ADDR_WIDTH-1:0] waddr,
>   input wen
> );
>   reg [DATA_WIDTH-1:0] rf [2**ADDR_WIDTH-1:0];
>   always @(posedge clk) begin
>     if (wen) rf[waddr] <= wdata;
>   end
> endmodule
> ```
> * 你还需要思考如何实现0号寄存器的特性
> * 使用NVBoard需要RTL代码比较好地支持设备, 我们会在B阶段再讨论这个问题, 目前不必接入NVBoard -->
> #### todo::Implement the addi instruction in NPC
> Specifically, you need to consider the following:
> * Place the binary encoding of several `addi` instructions in memory (you can utilize the behavior of register 0 to write behavior-determined instructions).
> * Since jump instructions are not implemented yet, NPC can only execute sequentially. You can stop the simulation after NPC executes several instructions.
> * You can check whether the `addi` instruction is executed correctly by viewing the waveform or printing the state of general-purpose registers in the RTL code.
> * Regarding general-purpose registers, their circuitry is essentially a memory.
>   Furthermore, to avoid students who choose Verilog from writing less reasonable behavioral modeling code, we provide the following incomplete code for everyone to complete (you don't need to change the contents of the `always` block):
> ```verilog
> module RegisterFile #(ADDR_WIDTH = 1, DATA_WIDTH = 1) (
>   input clk,
>   input [DATA_WIDTH-1:0] wdata,
>   input [ADDR_WIDTH-1:0] waddr,
>   input wen
> );
>   reg [DATA_WIDTH-1:0] rf [2**ADDR_WIDTH-1:0];
>   always @(posedge clk) begin
>     if (wen) rf[waddr] <= wdata;
>   end
> endmodule
> ```
> * You need to think about how to implement the feature of register 0.
> * Using NVBoard requires better support for devices in RTL code, we will discuss this issue again in B Stage. There is no need to connect to NVBoard for now.

<!-- > #### hint::不知道如何下手?
> 你很可能会遇到以下问题:
> * 如何通过PC值正确地访问存储器?
> * 如何在存储器中放置`addi`指令?
> * 如何仅执行若干指令后结束仿真?
> * 通用寄存器模块的端口应该如何设计?
>
> 在预学习阶段搭建verilator框架的时候, 我们就已经提醒过大家:
> <font color=red>项目里面的所有细节都是和大家有关系的</font>.
> 每当你觉得没有思路的时候, 这很大概率是在提醒你, 你很可能在之前的学习中有什么没做好.
> 相比于询问同学, 你其实更应该回顾之前的实验内容, 并尽自己最大努力理解每一处细节, 从而找到上述问题的答案. -->
> #### hint::Don't know where to start?
> You might encounter the following questions:
> * How to access memory correctly based on the PC value?
> * How to place `addi` instructions in memory?
> * How to end simulation after executing a certain number of instructions?
> * How should the ports of the general-purpose register module be designed?
>
> During the pre-learning stage when setting up the Verilator framework, we have already reminded you:
> <font color=red>Every detail in the project matters to you</font>.
> Whenever you feel stuck, it's likely reminding you that there might be something you didn't do well in your previous learning.
> Instead of asking your peers, you should review the previous lab materials and make your best effort to understand every detail, thus finding the answers to the above questions.

<!-- > #### todo::在NPC中实现jalr指令
> 实现后`addi`和`jalr`指令后, 让NPC运行之前在Logisim上运行过的那个两条指令的测试程序,
> 并检查NPC的运行结果是否符合预期. -->
> #### todo::Implement the jalr instruction in NPC.
> After implementing the `addi` and `jalr` instructions, run the test program with those two instructions that was previously run on Logisim on NPC,
> and check whether the NPC's results match expectations.

<!-- ## 让程序决定仿真何时结束 -->
## Let the program decide when simulation ends

<!-- 我们刚才是让仿真环境(C++代码)来决定执行多少条指令后结束仿真,
或者让NPC一直执行, 直到陷入一个预期的死循环, 来表示程序运行结束.
但这些做法并不具有很好的通用性: 你需要提前知道一个程序执行多少条指令才能结束.
有没有方法可以在程序执行结束的时候自动结束仿真呢? -->
Previously, we let the simulation environment (C++ code) determine when to end the simulation after executing a certain number of instructions.
Or let the NPC continue executing until it enters an expected infinite loop to indicate that the program has finished running.
However, these approaches are not very versatile: you need to know in advance how many instructions a program will execute. 
Is there a way to automatically end the simulation when the program finishes executing?

<!-- 事实上, NEMU已经给了一个很好的解决方案了: trap指令.
NEMU实现了一条特殊的`nemutrap`指令, 用于指示客户程序的结束,
具体地, 在RISC-V中, NEMU选择了`ebreak`指令来作为`nemutrap`指令.
事实上在NPC中, 我们也可以实现类似的功能:
如果程序执行了`ebreak`指令, 就通知仿真环境结束仿真. -->
In fact, NEMU has already provided a good solution: the trap instruction. NEMU implements a special `nemutrap` instruction, which indicates the end of the client program. Specifically, in RISC-V, NEMU chooses the `ebreak` instruction to act as the `nemutrap` instruction. In NPC, we can also implement similar functionality: if the program executes the `ebreak` instruction, notify the simulation environment to end the simulation.

<!-- 要实现这一功能并不困难, 你首先需要在NPC中添加`ebreak`指令的支持.
不过, 为了让NPC在执行`ebreak`指令的时候可以通知仿真环境,
你还需要实现一种RTL代码和C++代码之间的交互机制.
我们借用system verilog中的DPI-C机制来实现这一交互. -->
Implementing this functionality is not difficult. First, you need to add support for the `ebreak` instruction in NPC. However, to allow NPC to notify the simulation environment when executing the `ebreak` instruction, you also need to implement an interaction mechanism between RTL code and C++ code. We will use the DPI-C mechanism in SystemVerilog to achieve this interaction.

<!-- > #### todo::尝试DPI-C机制
> 阅读verilator手册, 找到DPI-C机制的相关内容, 并尝试运行手册中的例子. -->
> #### todo::Try DPI-C mechanism
> Read the Verilator manual to find the relevant content about the DPI-C mechanism, and try running the examples provided in the manual.

<!-- > #### todo::通过DPI-C实现ebreak
> 在RTL代码中利用DPI-C机制, 使得在NPC执行`ebreak`指令的时候通知仿真环境结束仿真.
> 实现后, 在上述程序中`halt()`函数的位置放置一条`ebreak`指令来进行测试.
> 如果你的实现正确, 仿真环境就无需关心程序何时结束仿真了,
> 它只需要不停地进行仿真, 直到程序执行`ebreak`指令为止.
>
> 如果你使用Chisel, 你可以借助Chisel中的BlackBox机制调用Verilog代码,
> 然后让Verilog代码通过DPI-C机制与仿真环境交互.
> 关于BlackBox的使用方式, 请查阅相关资料. -->
> #### todo::Implement ebreak via DPI-C
> Utilize the DPI-C mechanism in RTL code to notify the simulation environment to end simulation when NPC executes the `ebreak` instruction.
> Once implemented, place an `ebreak` instruction at the location of the `halt()` function in the above program for testing purposes.
> If your implementation is correct, the simulation environment no longer needs to worry about when the program ends simulation; it just needs to continue simulation until the program executes the `ebreak` instruction.
>
> If you are using Chisel, you can utilize the BlackBox mechanism to call Verilog code and then let the Verilog code interact with the simulation environment through the DPI-C mechanism.
> Please refer to relevant documentation for how to use BlackBox.

<!-- ## 实现完整的minirv处理器

你需要实现剩下的6条minirv指令, 包括`add`, `lui`, `lw`, `lbu`, `sw`, `sb`.
其中, 前两条都是整数计算指令, 它们和sISA中的`add`和`li`指令非常类似.
你已经在E阶段中实现过sISA的这两条指令了, 因此这对你来说并不困难. -->
## Implementing the complete minirv processor

You need to implement the remaining six minirv instructions, including `add`, `lui`, `lw`, `lbu`, `sw`, and `sb`.
The first two are integer arithmetic instructions, which are very similar to the `add` and `li` instructions in sISA.
You have already implemented these two instructions in sISA during the E phase, so this should not be difficult for you.

<!-- 为了实现剩下的4条访存指令, 我们需要进行一些额外的考量.
访存指令需要访问存储器, 与取指不同, 访存指令还可能需要将数据写入存储器.
我们之前把取指的接口拉到顶层的简单实现方式, 并不能正确实现访存指令,
这是因为访存接口的信号会依赖于当前取到的指令, 而仿真环境无法正确地处理这个依赖关系.
为了解决这个问题, 我们可以通过DPI-C机制来实现访存:-->
In order to implement the remaining four memory access instructions, we need to consider some additional factors.
Memory access instructions require accessing the memory. Unlike instruction fetching, memory access instructions may also involve writing data into memory.
Our previous simplistic implementation of bringing the instruction fetch interface to the top level couldn't correctly handle memory access instructions.
This is because the signals for memory access depend on the currently fetched instruction, which the simulation environment cannot handle correctly.
To address this issue, we can implement memory access through the DPI-C mechanism:
<!--  ``verilog
import "DPI-C" function int pmem_read(input int raddr);
import "DPI-C" function void pmem_write(
  input int waddr, input int wdata, input byte wmask);
reg [31:0] rdata;
always @(*) begin
  if (valid) begin // 有读写请求时
    rdata = pmem_read(raddr);
    if (wen) begin // 有写请求时
      pmem_write(waddr, wdata, wmask);
    end
  end
  else begin
    rdata = 0;
  end
end ```
-->
```verilog
import "DPI-C" function int pmem_read(input int raddr);
import "DPI-C" function void pmem_write(
  input int waddr, input int wdata, input byte wmask);
reg [31:0] rdata;
always @(*) begin
  if (valid) begin // When there are read or write requests
    rdata = pmem_read(raddr);
    if (wen) begin // When there are write requests
      pmem_write(waddr, wdata, wmask);
    end
  end
  else begin
    rdata = 0;
  end
end
``` 

<!-- ```c
extern "C" int pmem_read(int raddr) {
  // 总是读取地址为`raddr & ~0x3u`的4字节返回
}
extern "C" void pmem_write(int waddr, int wdata, char wmask) {
  // 总是往地址为`waddr & ~0x3u`的4字节按写掩码`wmask`写入`wdata`
  // `wmask`中每比特表示`wdata`中1个字节的掩码,
  // 如`wmask = 0x3`代表只写入最低2个字节, 内存中的其它字节保持不变
}
``` -->
```c
extern "C" int pmem_read(int raddr) {
  // Always read 4 bytes from address `raddr & ~0x3u` and return to `rdata`
}
extern "C" void pmem_write(int waddr, int wdata, char wmask) {
  // Always write `wdata` into 4 bytes aligned to the address `waddr & ~0x3u` according to the write mask `wmask`
  // Each bit in `wmask` acts as a byte-level mask for a byte in wdata
  // For example, `wmask = 0x3` means only write the lowest 2 bytes, leaving the other bytes in memory unchanged
}
```
<!-- 我们在这两个内存读写函数中模拟了32位总线的行为: 它们只支持地址按4字节对齐的读写,
其中读操作总是返回按4字节对齐读出的数据, 需要由RTL代码根据读地址选择出需要的部分.
这样是为了将来在实现总线的时候不必改动太多的代码.
你需要在Verilog代码中为这两个函数的调用传入正确的参数, 并在C++代码中实现这两个函数的功能.
对于取指, 你需要删除之前把信号拉到顶层的实现, 然后额外调用一次`pmem_read()`来实现它. -->
These memory read and write functions simulate the behavior of a 32-bit bus: they only support read and write operations aligned to 4 bytes.
Read operations always return data aligned to 4 bytes, which needs to be selected by the RTL code based on the read address.
This setup ensures that minimal changes are required when implementing the bus in the future.
You need to pass the correct parameters to these function calls in Verilog code and implement the functionality of these two functions in C++ code.
For instruction fetching, you need to remove the previous implementation of bringing signals to the top level and instead call `pmem_read()` once extra to implement it.

<!-- 和实现minirvEMU的时候一样, 为了运行更大的程序, 手动对存储器进行初始化是很低效的.
为了提高效率, 我们可以让仿真环境从命令行中读入程序的路径, 然后把程序内容放置到存储器中. -->
As with the implementation of minirvEMU, manually initialising memory is inefficient when running larger programs.
To improve efficiency, we can have the simulation environment read the program path from the command line and then place the program content in memory.

<!-- > #### todo::实现完整的minirv处理器
> 为NPC添加剩余的6条minirv指令, 并通过更新加载程序的方式,
> 然后在NPC上运行之前在Logisim上运行过的`sum`和`mem`两个程序.
> 为了判断程序是否成功结束运行, 你可以在NPC开始仿真之前,
> 在存储器中`halt()`函数对应的位置放置一条`ebreak`指令. -->
> #### todo::Implement a complete minirv processor
> Add the remaining 6 minirv instructions to the NPC, and update the loader accordingly.
> Then run the `sum` and `mem` programs on the NPC that were previously run on Logisim.
> To determine if the program has successfully completed execution, you can place an `ebreak` instruction at the location corresponding to the `halt()` function in memory before starting the NPC simulation.

<!-- ## 搭建面向minirv的AM运行时环境 -->
## Build a runtime environment of AM for minirv.

<!-- 你已经可以通过AM项目将方便地将程序编译到`riscv32-nemu`上.
类似地, 我们也可以通过类似的方式, 快速地将程序编译到`minirv-npc`上,
从而通过更多的程序来测试NPC的实现是否正确. -->
You can now easily compile programs to `riscv32-nemu` using the AM project.
Similarly, we can also quickly compile programs to `minirv-npc` in the same way,
so that we can test whether the NPC implementation is correct with more programs.

<!-- > #### danger::更新AM
> 我们在2025/05/03 12:30:00将在AM中添加了`minirv-npc`的支持.
> 如果你在上述时间之前获得AM的代码, 你可以通过以下命令获取新版本:
> ```bash
> cd ysyx-workbench
> cp -r abstract-machine/klib .  # 备份klib的实现, 如果你之前还改动了AM中的其他代码, 请手动备份它们
> rm -rf abstract-machine
> bash init.sh abstract-machine
> rm -rf abstract-machine/klib
> mv klib abstract-machine       # 恢复klib, 如果你之前还备份了AM中的其他代码, 请手动恢复它们
> ``` -->
> #### danger::Update AM
> We added support for `minirv-npc` to AM on 2025/05/03 12:30:00.
> If you obtained the AM code before the above time, you can get the new version with the following command:
> ```bash
> cd ysyx-workbench
> cp -r abstract-machine/klib .  # Backup the klib implementation. If you have made changes to other parts of AM, please manually backup those as well.
> rm -rf abstract-machine
> bash init.sh abstract-machine
> rm -rf abstract-machine/klib
> mv klib abstract-machine       # Restore klib. If you have backed up other parts of AM, please manually restore those as well.
> ```

<!-- AM项目已经提供了`minirv-npc`的基本框架, 你只需要在`am-kernels/tests/cpu-tests/`目录下执行
```bash
make ARCH=minirv-npc ALL=xxx
```
即可将名为`xxx`的测试编译到`minirv-npc`的运行时环境中.
不过, 为了兼容加接下来的设备功能, `minirv-npc`约定程序从`0x80000000`开始,
你需要修改PC的初值, 从而满足`minirv-npc`这个运行时环境的约定. -->
The AM project has already provided the basic framework for `minirv-npc`. You only need to execute the following command in the `am-kernels/tests/cpu-tests/` directory
```bash
make ARCH=minirv-npc ALL=xxx
```
to compile the test named `xxx` into the `minirv-npc` runtime environment.
However, to ensure compatibility with future device features, `minirv-npc` specifies that programs must start at `0x80000000`.
You need to modify the initial value of the PC to comply with this runtime environment specification.

<!-- 为了熟悉流程, 我们先尝试在NPC中运行dummy程序. -->
To familiarise ourselves with the process, we will first try running a dummy program in NPC.

<!-- > #### todo::一键编译并在NPC上运行AM程序
> 在AM项目中, Makefile并没有为`minirv-npc`提供`run`目标. 尝试为`minirv-npc`提供`run`目标,
> 使得键入`make ARCH=minirv-npc ALL=dummy run`即可把AM程序编译并在NPC上运行.
> 不过目前`minirv-npc`的`halt()`函数是一个死循环,
> 你可以通过查看波形来检查NPC是否成功进入了`halt()`函数. -->
> #### todo::Compile and run AM programs on NPC with one command
> In the AM project, the Makefile does not provide a `run` target for `minirv-npc`.
> Try to provide a `run` target for `minirv-npc` so that typing `make ARCH=minirv-npc ALL=dummy run` will compile the AM program and run it on NPC.
> However, currently, the `halt()` function of `minirv-npc` is an infinite loop.
> You can check whether the NPC has successfully entered the `halt()` function by viewing the waveform.

<!-- > #### todo::实现minirv-npc中的halt()函数
> 为了可以自动地结束程序, 你需要在`minirv-npc`中实现TRM的halt()函数, 在其中添加一条`ebreak`指令.
> 这样以后, 在NPC上运行的AM程序在结束的时候就会执行`ebreak`指令, 从而通知NPC的仿真环境结束仿真.
>
> 实现之后, 你就可以通过一条命令自动在NPC上运行AM程序并自动结束仿真了. -->
#### todo::Implement the `halt()` function in `minirv-npc`
> To automatically end the program, you need to implement the `halt()` function in `minirv-npc`, where you add an `ebreak` instruction.
> After this, when an AM program running on NPC finishes, it will execute the `ebreak` instruction, signaling the NPC's simulation environment to end the simulation.
>
> Once implemented, you can run AM programs on NPC and automatically end the simulation with a single command.

<!-- > #### todo::为NPC实现HIT GOOD/BAD TRAP
> NEMU可以输出"程序是否成功结束执行"的信息, 尝试在NPC中实现相似的功能,
> 这样以后, 你就可以快速了解程序在NPC上是否成功结束了. -->
#### todo::Implement HIT GOOD/BAD TRAP for NPC
> NEMU can output information about whether the program has successfully completed execution. Try implementing similar functionality in NPC.
> This way, you'll be able to know whether the program has successfully ended on NPC in the future.

<!-- 得益于minirv指令集的完备性, 之前你在`riscv32-nemu`上能运行的程序,
都能通过重新编译到`minirv-npc`, 从而运行在NPC上.
你无需为了运行它们而在NPC上实现更多的指令. -->
Thanks to the completeness of the minirv instruction set, programs that previously ran on riscv32-nemu
can be recompiled to minirv-npc and run on NPC.
You do not need to implement additional instructions on NPC to run them.

<!-- > #### todo::在NPC上运行更多程序
> 在`minirv-npc`上运行`cpu-tests`, `riscv-tests`和`riscv-arch-test`,
> 来测试NPC的实现是否正确. -->
> #### todo::Run more programs on NPC
> Run `cpu-tests`, `riscv-tests`, and `riscv-arch-test` on `minirv-npc`
> to test whether the NPC implementation is correct.
