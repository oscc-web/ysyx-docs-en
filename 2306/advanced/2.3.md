## 精彩纷呈的用户程序

本节需要更多的[RTFM](https://www.libsdl.org/release/SDL-1.2.15/docs/)来学习多媒体库的使用，当你足够熟练的时候，也许你也能写出[NVBOARD](https://github.com/NJU-ProjectN/nvboard)。同时需要现更多功能来支持Navy中的应用程序，运行仙剑奇侠传。南京大学的操作系统课程实现了一些基于AM的[小游戏](https://github.com/NJU-ProjectN/oslab0-collection), 尝试在NAVY上运行。

> #### option::可选:自制小游戏
> 参考 [amgame](http://jyywiki.cn/OS/2022/labs/L0)

为了提升效率，你还需要实现更多的基础设施：自由开关Difftest模式和快照，展示批处理系统等等。

> #### todo::根据PA讲义完成除选做之外的内容，完成必答题
> 直到你看到如下提示框:
> > #### flag::温馨提示
> > PA3到此结束...

> #### todo::在NPC中运行仙剑奇侠传
> 到目前为止，我们已经实现了PA3的全部内容。
> 我们需要在NPC上通过DPI-C机制运行仙剑奇侠传，验证自己的处理器代码。
>  

> #### caution::验证自己的NPC——先完成后完美
> 在B线的PA和NPC中，我们往往会通过cpu-tests对代码进行测试。
> 有些同学可能会有疑问：为什么我的代码已经通过了cpu-tests的测试，但在后续实验中，例如运行仙剑时依然出现了difftest报错的问题呢？
> 事实上，如果大家阅读过cpu-tests的源码，可以看到其实这些测试只是一些很简单的程序。
> 也就是说，这些测试程序的强度很弱，完备性很差，往往并不能检测出代码中存在的错误。
> 
> 在PA和一生一芯的讲义中多次提到，大家可以编写自己的测试集。
> 我们可以针对一些边界情况、特殊情况进行单独测试，尽量保证代码的正确性。
> 如果我们的代码无法通过这些测试，一定可以说明我们的代码中存在问题；但即使我们的代码通过了全部测试，我们也无法保证代码是一定正确的。
> 感兴趣的同学可以学习一些形式化验证的相关内容，或许在未来，形式化验证也可以应用在我们的代码中。
> 
> 在后续讲义中，我们会对NPC添加AXI总线、乘除法模块、高速缓存、流水线等相关内容，大家也会频繁对自己的处理器结构进行优化和改进。
> 倘若我们一直使用cpu-tests进行测试，由于cpu-tests的测试强度比较弱，在我们添加这些功能时，可能没有办法及时发现代码中隐藏的bug。
> 当我们实现所有的功能并优化处理器结构后，最终在NPC上运行仙剑奇侠传时，由于仙剑是比较复杂的程序，这些残留的bug可能会同时触发。
> 同时，由于这些bug分布在NPC的各个功能模块中，有些是关于总线，有些关于缓存，有些关于流水化，所有bug混杂在一起，导致调试十分困难。
> 
> 因此，我们希望大家在NPC中添加每个功能之后，都通过运行仙剑奇侠传测试自己的代码。
> 一方面，仙剑是比较复杂的程序，比较容易检测出代码中的bug；
> 同时，我们也贯彻落实了先完成后完美的观念，每完成一个功能或模块都对该模块进行测试。
> 当我们实现AXI总线后，我们通过运行仙剑验证总线实现的正确性；
> 加入乘除法模块后验证乘除法模块的正确性；
> 添加高速缓存后验证cache实现的正确性；
> 接入流水线后验证流水线的正确性。
> 这样，可以把bug尽量限制在比较小的范围内，方便我们的调试。


