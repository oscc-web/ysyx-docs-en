
## 如何阅读手册

在以后的PA中, 你需要反复阅读之前获得的生存手册.
鉴于有同学片面地认为"看手册"就是"把手册全看一遍", 因而觉得"不可能在短时间内看完",
我们在PA1的最后来聊聊如何科学地看手册.

### 学会使用目录

了解一本书都有哪些内容的最快方法就是查看目录, 尤其是当你第一次看一本新书的时候.
查看目录之后并不代表你知道它们具体在说什么, 但你会对这些内容有一个初步的印象,
提到某一个概念的时候, 你可以大概知道这个概念会在手册中的哪些章节出现.
这对查阅手册来说是极其重要的, 因为我们每次查阅手册的时候总是关注某一个问题,
如果每次都需要把手册从头到尾都看一遍才能确定关注的问题在哪里, 效率是十分低下的.
事实上也没有人会这么做, 阅读目录的重要性可见一斑.
纸上得来终觉浅, 还是来动手体会一下吧!

> #### todo::尝试通过目录定位关注的问题
> 假设你现在需要了解一个叫`selector`的概念, 请通过i386手册的目录确定你需要阅读手册中的哪些地方.
> 即使你选择的ISA并不是x86, 也可以尝试去查阅这个概念.

怎么样, 是不是很简单?
虽然你还是不明白`selector`是什么, 但你已经知道你需要阅读哪些地方了,
要弄明白`selector`, 那也是指日可待的事情了.

### 逐步细化搜索范围

有时候你关注的问题不一定直接能在目录里面找到, 例如"CR0寄存器的PG位的含义是什么".
这种细节的问题一般都是出现在正文中, 而不会直接出现在目录中,
因此你就不能直接通过目录来定位相应的内容了.
根据你是否第一次接触CR0, 查阅这个问题会有不同的方法:
* 如果你已经知道CR0是个control register, 你可以直接在目录里面查看"control register"所在的章节,
然后在这些章节的正文中寻找"CR0".
* 如果你对CR0一无所知, 你可以使用阅读器中的搜索功能, 搜索"CR0", 还是可以很快地找到"CR0"的相关内容.
不过最好的方法是首先使用搜索引擎, 你可以马上知道"CR0是个control register", 然后就可以像第一种方法那样查阅手册了.

不过有时候, 你会发现一个概念在手册中的多个地方都有提到.
这时你需要明确你要关心概念的哪个方面, 通常一个概念的某个方面只会在手册中的一个地方进行详细的介绍.
你需要在这多个地方中进行进一步的筛选, 但至少你已经过滤掉很多与这个概念无关的章节了.
筛选也是有策略的, 你不需要把多个地方的所有内容全部阅读一遍才能进行筛选,
小标题, 每段的第一句话, 图表的注解, 这些都可以帮助你很快地了解这一部分的内容大概在讲什么.
这不就是高中英语考试中的快速阅读吗?
对的, 就是这样. 如果你觉得目前还缺乏这方面的能力, 现在锻炼的好机会来了.

搜索和筛选信息是一个trial and error的过程, 没有什么方法能够指导你在第一遍搜索就能成功, 但还是有经验可言的.
搜索失败的时候, 你应该尝试使用不同的关键字重新搜索.
至于怎么变换关键字, 就要看你对问题核心的理解了, 换句话说, 怎么问才算是切中要害.
这不就是高中语文强调的表达能力吗? 对的, 就是这样.

事实上, 你只需要具备一些基本的交际能力, 就能学会查阅资料, 和资料的内容没有关系,
来一本"民法大全", "XX手机使用说明书", "YY公司人员管理记录", 照样是这么查阅.
"查阅资料"是一种与领域无关的基本能力, 无论身处哪一个行业都需要具备,
如果你不想以后工作的时候被查阅资料的能力影响了自己的前途, 从现在开始就努力锻炼吧!

<!-- -->
> #### todo::必答题
> 你需要在实验报告中回答下列问题:
> * <u>程序是个状态机</u> 画出计算`1+2+...+100`的程序的状态机, 具体请参考[这里](1.2.md#从状态机视角理解程序运行).
> * <u>理解基础设施</u> 我们通过一些简单的计算来体会简易调试器的作用.
> 首先作以下假设:
>   * 假设你需要编译500次NEMU才能完成PA.
>   * 假设这500次编译当中, 有90%的次数是用于调试.
>   * 假设你没有实现简易调试器, 只能通过GDB对运行在NEMU上的客户程序进行调试.
>   在每一次调试中, 由于GDB不能直接观测客户程序, 你需要花费30秒的时间来从GDB中获取并分析一个信息.
>   * 假设你需要获取并分析20个信息才能排除一个bug.
>
>   那么这个学期下来, 你将会在调试上花费多少时间?
>
>   由于简易调试器可以直接观测客户程序, 假设通过简易调试器只需要花费10秒的时间从中获取并分析相同的信息.
> 那么这个学期下来, 简易调试器可以帮助你节省多少调试的时间?
>
>   事实上, 这些数字也许还是有点乐观,
> 例如就算使用GDB来直接调试客户程序, 这些数字假设你能通过10分钟的时间排除一个bug.
> 如果实际上你需要在调试过程中获取并分析更多的信息, 简易调试器这一基础设施能带来的好处就更大.
> * <u>RTFM</u> 理解了科学查阅手册的方法之后,
> 请你尝试在你选择的ISA手册中查阅以下问题所在的位置, 把需要阅读的范围写到你的实验报告里面:
>   * x86
>     * EFLAGS寄存器中的CF位是什么意思?
>     * ModR/M字节是什么?
>     * mov指令的具体格式是怎么样的?
>   * mips32
>     * mips32有哪几种指令格式?
>     * CP0寄存器是什么?
>     * 若除法指令的除数为0, 结果会怎样?
>   * riscv32
>     * riscv32有哪几种指令格式?
>     * LUI指令的行为是什么?
>     * mstatus寄存器的结构是怎么样的?
> * <u>shell命令</u> 完成PA1的内容之后, `nemu/`目录下的所有.c和.h和文件总共有多少行代码?
> 你是使用什么命令得到这个结果的? 和框架代码相比, 你在PA1中编写了多少行代码?
> (Hint: 目前`pa0`分支中记录的正好是做PA1之前的状态, 思考一下应该如何回到"过去"?)
> 你可以把这条命令写入`Makefile`中, 随着实验进度的推进, 你可以很方便地统计工程的代码行数,
> 例如敲入`make count`就会自动运行统计代码行数的命令.
> 再来个难一点的, 除去空行之外, `nemu/`目录下的所有`.c`和`.h`文件总共有多少行代码?
> * <u>RTFM</u> 打开`nemu/scripters/build.mk`文件, 你会在`CFLAGS`变量中看到gcc的一些编译选项.
> 请解释gcc中的`-Wall`和`-Werror`有什么作用? 为什么要使用`-Wall`和`-Werror`?

<!-- -->
> #### flag::温馨提示
> PA1到此结束. 请你编写好实验报告(不要忘记在实验报告中回答必答题),
> 然后把命名为`学号.pdf`的实验报告文件放置在工程目录下,
> 执行`make submit`将工程提交到指定网站.
